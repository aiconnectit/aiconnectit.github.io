<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Web/Node知识理解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/08/11/Web/Node%E7%9F%A5%E8%AF%86%E7%90%86%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2020-08-11T09:22:49.000Z" itemprop="datePublished">2020-08-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/nodejs/">nodejs</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/08/11/Web/Node%E7%9F%A5%E8%AF%86%E7%90%86%E8%A7%A3/">Nodejs基础性知识点总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Node-js是什么"><a href="#Node-js是什么" class="headerlink" title="Node.js是什么"></a>Node.js是什么</h3><p>1、node.js 平台是基于 Chrom V8 javsaScript 引擎构建的。</p>
<p>2、基于 node.js 可以开发控制台程序（命令行程序、CLI程序）、桌面应用程序（GUI）（需要借助 node - webkit、electron等框架实现）、web应用程序（网站）</p>
<h3 id="node-js有哪些特点"><a href="#node-js有哪些特点" class="headerlink" title="node.js有哪些特点"></a>node.js有哪些特点</h3><p>1、事件驱动（当事件被触发时，执行传递过去的回调函数）</p>
<p>2、非阻塞I/O模型（当执行I/O操作时，不会阻塞线程）</p>
<p>3、单线程（javascript也是单线程语言）</p>
<p>4、拥有世界最大的开源生态系统 – npm （一个非常丰富的开源生态库）</p>
<h3 id="node-js网站"><a href="#node-js网站" class="headerlink" title="node.js网站"></a>node.js网站</h3><p>1、官方网站<a target="_blank" rel="noopener" href="https://nodejs.org/">https://nodejs.org/</a></p>
<p>2、中文网<a target="_blank" rel="noopener" href="http://nodejs.cn/">http://nodejs.cn/</a></p>
<p>3、中文社区<a target="_blank" rel="noopener" href="https://cnodejs.org/">https://cnodejs.org/</a></p>
<h3 id="Node-js安装与配置"><a href="#Node-js安装与配置" class="headerlink" title="Node.js安装与配置"></a>Node.js安装与配置</h3><p>1、安装完毕后通过在CMD输入node -v检查是否安装成功，如果输入命令出现版本号的话就说明安装成功了。如果没有出现版本号，就说明安装不成功，那么需要配置环境变量（参考网上环境配置方法），配置完成后重新输入那个命令，直到出现版本号，那么这样的话就算时安装成功了。</p>
<p>2、通过 nvm - windows 管理一台计算机上的多个 node 版本</p>
<h3 id="Node-js多个版本管理器"><a href="#Node-js多个版本管理器" class="headerlink" title="Node.js多个版本管理器"></a>Node.js多个版本管理器</h3><p>nvm -window(window上安装)</p>
<p> 1、<a target="_blank" rel="noopener" href="https://github.com/coreybutler/nvm-windows">https://github.com/coreybutler/nvm-windows</a></p>
<p>   常用命令：</p>
<pre><code> nvm version 意思是当前版本

 nvm install latest 安装最新版本

 nvm install 版本号 意思是指定版本号安装

 nvm uninstall 版本号 ，意思是卸载哪个版本的

 nvm list 列出所有node.js版本

 nvm use 版本号， 意思是: 切换版本
</code></pre>
<h3 id="Node-js开发web应用程序和PHP、Java、ASP-Net等传统模式开发Web应用程序的区别"><a href="#Node-js开发web应用程序和PHP、Java、ASP-Net等传统模式开发Web应用程序的区别" class="headerlink" title="Node.js开发web应用程序和PHP、Java、ASP.Net等传统模式开发Web应用程序的区别"></a>Node.js开发web应用程序和PHP、Java、ASP.Net等传统模式开发Web应用程序的区别</h3><p>1、传统模式</p>
<p>   有Web容器</p>
<p>   必需有Web容器开发模型</p>
<p>2、node.js开发web应用程序 （可以自己创建一个服务器，或者说本     身就是一个服务器）</p>
<p>   没有 web 容器</p>
<p>   node.js没有Web容器开发模型</p>
<h3 id="node-js程序编写注意事项"><a href="#node-js程序编写注意事项" class="headerlink" title="node.js程序编写注意事项"></a>node.js程序编写注意事项</h3><p>1、不要用中文</p>
<p>2、不要包含空格</p>
<p>3、不要出现node关键字</p>
<p>4、建议以’-‘分割单词</p>
<h3 id="JS知识补充"><a href="#JS知识补充" class="headerlink" title="JS知识补充"></a>JS知识补充</h3><p>js为什么是单线程的和异步非阻塞的呢？</p>
<p>解释： 同步就是阻塞的意思。</p>
<h3 id="文件读写（可以同查阅官方文档去掌握）"><a href="#文件读写（可以同查阅官方文档去掌握）" class="headerlink" title="文件读写（可以同查阅官方文档去掌握）"></a>文件读写（可以同查阅官方文档去掌握）</h3><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>  使用到的模块 var fs = require(‘fs’);</p>
<p>1、写文件：’fs.writeFile(file,data[,options],callback);’</p>
<p>   参数1：要写入文件的路径，<strong>必填</strong></p>
<p>   参数2：要写入的数据，<strong>必填</strong></p>
<p>   参数3：写入文件时的选项，比如文件编码，<strong>选填</strong>、</p>
<p>   参数4：文件写入完毕后的回调函数，<strong>必填</strong></p>
<p>   写文件注意：</p>
<pre><code>*该操作采用异步执行

*如果文件已经存在则替换掉

*默认写入文件编码为utf8

*回调函数有一个参数：err,表示再写入文件的操作过程中是否出错。

-如果出错了 &#39;err  != null &#39; ,否则 &#39;err === null&#39;
</code></pre>
<p> 注意：<br>   process 在使用的时候无需通过 require()函数来加载该模块，可以直接使用</p>
<p>   fs模块，在使用的时候，必须通过require()函数来加载该模块，方可使用 var fs = require(‘fs’)</p>
<p> 原因：process模块是全局的模块，而fs不是全局模块，全局模块可以直接使用，而非全局模块需要先通过require()加载该模块</p>
<p> 写入文件代码示例：</p>
<pre><code> var fs = require(&#39;fs&#39;);

var msg = &#39;hello word ，世界&#39;;

fs.writeFile(&#39;./hello.txt&#39;,msg,&#39;utf8&#39;,function(err)&#123;

    /**
     * 如果 err === null ,表示写入文件成功，没有错误
     * 如果 err !=nll,表示写入文件失败，
     */

    if(err)&#123;
       console.log(&#39;写入的文件错误&#39;+err);
    &#125;else&#123;
        console.log(&#39;写入文件成功&#39;);
    &#125;
&#125;)
</code></pre>
<p> <img src="https://s1.ax1x.com/2020/08/27/dhCNQ0.png"></p>
<h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>2、读文件：’fs.readFile(file[,options],callback)’</p>
<p>   参数1：要读取文件的路径，<strong>必填</strong></p>
<p>   参数2：读取文件时的选项，比如文件编码，<strong>选填</strong>、</p>
<p>   参数3、文件读取完毕后的回调函数，<strong>必填</strong></p>
<p>   写文件注意：</p>
<pre><code>*该操作采用异步执行

*回调函数有两个参数，分别是err和data
</code></pre>
<p> 实现步骤： </p>
<pre><code>1、加载 fs 模块

2、调用 fs.readFlile() 方法来读取文件

   fs.readFile(file[,options],callback)

读取的是 buffer 类型字节数组

3、将buffer对象转换为字符串，调用toString方法 (不传参数的话默认是utf8编码，建议写上)
</code></pre>
<p> 代码写法：<br>   一、不传递utf8编码</p>
<pre><code>// 1、加载fs模块
var fs = require(&#39;fs&#39;);

//2、调用 fs.readFile() 方法来读取文件

fs.readFile(&#39;./hello.txt&#39;, function (err, data) &#123;

    if (err) &#123;
        throw err;
    &#125;
    //data 参数的数据类型是一个Buffer对象，里面保存的是一个一个字节（可以理解为字节数组）

    console.log(data);

    //3、将buffer对象转换为字符串，调用toString方法 (不传参数的话默认是utf8编码，建议写上)
        
    console.log(data.toString(&#39;utf8&#39;));
&#125;)
</code></pre>
<p>   <img src="https://s1.ax1x.com/2020/08/30/dbiWyF.png"></p>
<p>   一、传递utf8编码</p>
<pre><code>   // 1、加载fs模块
var fs = require(&#39;fs&#39;);

//2、调用 fs.readFile() 方法来读取文件

//在读取文件的时候，如果传递了编码,那么回调函数中的 data 会默认转换为字符串
fs.readFile(&#39;./hello.txt&#39;, &#39;utf8&#39;, function (err, data) &#123;
    if (err) &#123;
        throw err;
    &#125;
    //data 参数的数据类型是一个Buffer对象，里面保存的是一个一个字节（可以理解为字节数组）
    console.log(data);
    //3、将buffer对象转换为字符串，调用toString方法 (不传参数的话默认是utf8编码，建议写上)
&#125;)
</code></pre>
<p>  <img src="https://s1.ax1x.com/2020/08/30/dbiNz8.png"></p>
<p> 读取文件中的注意事项：</p>
<p>   “./“这是一个相对路径，相对的是执行命令的路径，而不是相对于正在执行的这个JS文件来查找 hello.txt.</p>
<p>   解决上述问题方法：__dirname 、 __filename （这两个并不是全局的）</p>
<pre><code> __dirname:表示，当前真在执行的js文件所在的目录

 __filename:表示，当前正在执行的js文件的完整路径
</code></pre>
<p>   代码示例：</p>
<pre><code> // 1、加载fs模块
var fs = require(&#39;fs&#39;);

var dirname = __dirname + &#39;\\&#39; + &#39;hello.txt&#39;;
//2、调用 fs.readFile() 方法来读取文件

//在读取文件的时候，如果传递了编码,那么回调函数中的 data 会默认转换为字符串
fs.readFile(dirname, &#39;utf8&#39;, function (err, data) &#123;
    if (err) &#123;
        throw err;
    &#125;
    //data 参数的数据类型是一个Buffer对象，里面保存的是一个一个字节（可以理解为字节数组）
    console.log(data);
    //3、将buffer对象转换为字符串，调用toString方法 (不传参数的话默认是utf8编码，建议写上)
&#125;)
</code></pre>
<h3 id="通过path进行路径拼接"><a href="#通过path进行路径拼接" class="headerlink" title="通过path进行路径拼接"></a>通过path进行路径拼接</h3><p> 一、需要用到的语句<br>    var path = require(‘path’);</p>
<pre><code>var dirname = path.join(__dirname,&#39;hello.txt&#39;);
</code></pre>
<p> 二、代码示例：</p>
<pre><code>// 1、加载fs模块
var fs = require(&#39;fs&#39;);

//加载path模块
var path = require(&#39;path&#39;);

// var dirname = __dirname + &#39;\\&#39; + &#39;hello.txt&#39;;

var dirname = path.join(__dirname,&#39;hello.txt&#39;);

//2、调用 fs.readFile() 方法来读取文件

//在读取文件的时候，如果传递了编码,那么回调函数中的 data 会默认转换为字符串
fs.readFile(dirname, &#39;utf8&#39;, function (err, data) &#123;
    if (err) &#123;
        throw err;
    &#125;
    //data 参数的数据类型是一个Buffer对象，里面保存的是一个一个字节（可以理解为字节数组）
    console.log(data);
    //3、将buffer对象转换为字符串，调用toString方法 (不传参数的话默认是utf8编码，建议写上)
&#125;)
</code></pre>
<h3 id="如何创建文件夹"><a href="#如何创建文件夹" class="headerlink" title="如何创建文件夹"></a>如何创建文件夹</h3><pre><code>var fs = require(&#39;fs&#39;);

fs.mkdir(&#39;./test-mkdir/test&#39; , function(err)&#123;
    if(err)&#123;
        console.log(err);
    &#125;else&#123;
        console.log(&#39;创建成功&#39;);
    &#125;

&#125;)
</code></pre>
<h3 id="之前知识点总结及注意事项"><a href="#之前知识点总结及注意事项" class="headerlink" title="之前知识点总结及注意事项"></a>之前知识点总结及注意事项</h3><p> 1、异步操作无法通过 try - catch 来捕获异常，要通过判断error 来判断是否出错</p>
<p> 2、同步操作可以通过 try - catch 来捕获异常</p>
<p> 3、不要使用 fs.exists(path,callback) 来判断文件是否存在，直接判断error即可</p>
<p> 4、文件操作时的路径问题</p>
<p>   在读写文件的时候 ‘./‘ 表示的是当前执行 node 命令的哪个路径，不是被执行的js文件的路径</p>
<p>   __dirname 表示永远是“当前被执行的js目录”</p>
<p>   __firename 表示的是“被执行的js文件名（含路径”</p>
<p> 5、error - first 介绍（错误优先）</p>
<h2 id="通过-node-js-编写-http-服务程序-极简版本"><a href="#通过-node-js-编写-http-服务程序-极简版本" class="headerlink" title="通过 node.js 编写 http 服务程序 - 极简版本"></a>通过 node.js 编写 http 服务程序 - 极简版本</h2><p> 步骤：</p>
<p>  1、加载http模块</p>
<p>  2、创建http服务</p>
<p>  3、为http服务添加 request 事件处理程序</p>
<p>  4、启动http服务监听，准备接收客户端请求</p>
<p> 代码示例：</p>
<pre><code>//1、加载http模块

 var http = require(&#39;http&#39;);

 //2、创建一个tttp服务对象
 var server = http.createServer();

 //3、监听用户的请求事件（request 事件）
 // request 包含了用户请求报文中的所有内容，通过request 对象可以获得所有用户提交过来的所有数据
 // reponse 对象用来向用户响应一些数据，当服务器要向客户端响应数据的时候必须使用response对象
 
 //有了request 对象和 response 对象，就可以获取用户提交的数据，也可以向用户响应数据
 server.on(&#39;request&#39; , function(req,res)&#123;

     res.write(&quot;hello word&quot;);
   //对于每一个请求，服务器必须结束响应，否则客户端（浏览器）会一直等待服务器响应结束
     res.end();
 &#125;)

 server.listen(8080,function()&#123;
   console.log(&#39;服务器启动成功，请访问:http://localhost:8080&#39;);
 &#125;);
</code></pre>
<p> 通过设置http响应报文头来解决浏览器显示html的问题（能够以html的形式展示）</p>
<p>  加一条语句： res.setHeader(‘Content-Type’,’text/html; charset=utf-8’);</p>
<p>  <strong>代码示例</strong>：</p>
<pre><code> //1、加载http模块

 var http = require(&#39;http&#39;);

 //2、创建一个tttp服务对象
 var server = http.createServer();

 //3、监听用户的请求事件（request 事件）
 // request 包含了用户请求报文中的所有内容，通过request 对象可以获得所有用户提交过来的所有数据

 // reponse 对象用来向用户响应一些数据，当服务器要向客户端响应数据的时候必须使用response对象
 
 //有了request 对象和 response 对象，就可以获取用户提交的数据，也可以向用户响应数据
 server.on(&#39;request&#39; , function(req,res)&#123;

    //只要和响应有关的就用response

    //解决乱码的思路：服务器通过设置http响应报文头，告诉浏览器使用相应的编码来解析网页
       
    res.setHeader(&#39;Content-Type&#39;,&#39;text/html; charset=utf-8&#39;);

     res.write(&quot;hello word &lt;h1&gt; 你好 世界 &lt;\h1&gt;&quot;);
   //对于每一个请求，服务器必须结束响应，否则客户端（浏览器）会一直等待服务器响应结束
     res.end();
 &#125;)

 server.listen(8080,function()&#123;
   console.log(&#39;服务器启动成功，请访问:http://localhost:8080&#39;);
 &#125;);    
  
</code></pre>
<p> 注意：</p>
<p>  1、<strong>浏览器显示的可能是乱码</strong>，所以可以通过 res.setHeader(‘Content - Type’,’text/plain;charset = utf-8’); 设置浏览器显示时所使用的编码。</p>
<pre><code>**解决乱码的思路：服务器通过设置http响应报文头，告诉浏览器使用相应的编码来解析网页**
</code></pre>
<p>  2、Chrome 浏览器默认无法手动设置编码，需要安装”Set character Encoding”扩展</p>
<p>  3、Content - Type = text/html 和 Content - Type = text/plain 的区别。</p>
<h3 id="根据用户的不同请求，服务器做出不同响应"><a href="#根据用户的不同请求，服务器做出不同响应" class="headerlink" title="根据用户的不同请求，服务器做出不同响应"></a>根据用户的不同请求，服务器做出不同响应</h3><p>  代码思路：  </p>
<pre><code>//1、加载http模块
var http = require(&#39;http&#39;);

//2、创建HTTP服务
http.createServer(function (req, res) &#123;

    //  console.log(req.url);

    //  //结束响应
    //  res.end();

    res.setHeader(&#39;Content-Type&#39;, &#39;text/plain;charset=utf-8&#39;);

    //通过req.ulr获取用户请求的路径，根据不同的请求路径服务器做出不同的响应
    if(req.url === &#39;/&#39; || req.url === &#39;/index&#39;)&#123;
        res.end(&#39;hello index&#39;);
    &#125;else if(req.url === &#39;/login&#39;)&#123;
        res.end(&#39;hello login&#39;);
    &#125;else if(req.url === &#39;/list&#39;)&#123;
        res.end(&#39;hello list&#39;);
    &#125;else if(req.url === &#39;/register&#39;)&#123;
        res.end(&#39;hello register&#39;);
    &#125;else&#123;
        res.end(&#39;404,not Found.客户端错误&#39;)
    &#125;

&#125;).listen(8080, function () &#123;
    console.log(&#39;服务器启动成功，请访问:http://localhost:8080&#39;);
&#125;)
</code></pre>
<h3 id="根据用户不同请求，加载不同的文件"><a href="#根据用户不同请求，加载不同的文件" class="headerlink" title="根据用户不同请求，加载不同的文件"></a>根据用户不同请求，加载不同的文件</h3><pre><code>var http = require(&#39;http&#39;);

var fs = require(&#39;fs&#39;);

var path = require(&#39;path&#39;);

http.createServer(function (req, res) &#123;
    
    var urling;
    //通过req.ulr获取用户请求的路径，根据不同的请求路径服务器做出不同的响应
    if(req.url === &#39;/&#39; || req.url === &#39;/index&#39;)&#123;
        //读取 index.html文件
    //    fs.readFile(path.join(__dirname,&#39;htmls&#39;,&#39;index.html&#39;),function(err,data)&#123;
    //        if(err)&#123;
    //            throw err;
    //        &#125;else&#123;
    //          res.end(data);  
    //        &#125;
    //    &#125;)
      urling = &#39;index.html&#39;;
    &#125;else if(req.url === &#39;/login&#39;)&#123;
        // fs.readFile(path.join(__dirname,&#39;htmls&#39;,&#39;login.html&#39;),function(err,data)&#123;
        //   if(err)&#123;
        //       throw err;
        //   &#125;else&#123;
        //       res.end(data);
        //   &#125;
        // &#125;)
        urling = &#39;login.html&#39;;
    &#125;else if(req.url === &#39;/list&#39;)&#123;
        urling = &#39;list.html&#39;;
    &#125;else if(req.url === &#39;/reglist&#39;)&#123;
        urling = &#39;reglist.html&#39;;
    &#125;else&#123;
        urling = &#39;404.html&#39;;
    &#125;

    fs.readFile(path.join(__dirname,&#39;htmls&#39;, urling),function(err,data)&#123;
        if(err)&#123;
            throw err;
        &#125;else&#123;
            res.end(data);
        &#125;
     &#125;)

&#125;).listen(8080, function () &#123;
    console.log(&#39;http://localhost:8080&#39;);
&#125;)
</code></pre>
<p>  <strong>文件操作时，无需判断文件是否存在，直接操作即可，如果文件不存在会反应在 error 中</strong></p>
<h3 id="try-cath的使用"><a href="#try-cath的使用" class="headerlink" title="try-cath的使用"></a>try-cath的使用</h3><p>作用：捕获异常</p>
<p>结论：只能捕获同步操作异常，不能捕获异步操作异常</p>
<p>  对于异步操作，只能通过判断错误号（err.code）来进行出错处理</p>
<h3 id="模拟Apache服务器"><a href="#模拟Apache服务器" class="headerlink" title="模拟Apache服务器"></a>模拟Apache服务器</h3><p>  模拟Apache服务器的 5 个步骤：</p>
<p>   1、获取用户请求路径</p>
<p>   2、获取 public 目录的完整路径</p>
<p>   3、根据public的路径和用户请求的路径，最终计算出用户请求的静态资源的完整路径</p>
<p>   4、根据文件的完整路径去读取该文件，则把文件返回给用户，如果找不到，则返回404</p>
<p>   5、通过第三方模块 mime = require(‘mime’) ;，来判断不同资源 Content-Type 的类型</p>
<p> 具体示例代码如下：</p>
<pre><code>//加载服务器模块
var http = require(&#39;http&#39;);

//加载文件路径模块
var path = require(&#39;path&#39;);

//加载文件模块
var fs = require(&#39;fs&#39;);

//加载外部模块mime 来判读读取文件的后缀名是什么的
var mime = require(&#39;mime&#39;);

//创建服务器
http.createServer(function (req, res) &#123;
    //1、获取用户请求路径
    //req.url
    // /css/index.css
    // /images/index.png

    //2、获取 public 目录的完整路径
    var publicdir = path.join(__dirname, &#39;public&#39;);
    
    //3、根据public的路径和用户请求的路径，最终计算出用户请求的静态资源的完整路径
    var filename = path.join(publicdir, req.url);
    // console.log(filename);
   
    //4、根据文件的完整路径去读取该文件，则把文件返回给用户，如果找不到，则返回404
    fs.readFile(filename, function (err, data) &#123;
        if (err) &#123;
            res.end(&#39;不存在此页面&#39;);
        &#125; else &#123;

            //通过第三方模块，来判断不同资源 Content-Type 的类型
            res.setHeader(&#39;Content-Type&#39;,mime.getType(filename));
            
            //如果找到了要读取的文件则直接将文件返回给用户
            res.end(data);
        &#125;

    &#125;)


&#125;).listen(8080, function () &#123;
    console.log(&#39;http://localhost:8080&#39;);
&#125;)
</code></pre>
<p>   <strong>在请求服务器的时候，请求的 url 就是一个标识，找到标识主要的是服务器返回的是什么文件</strong></p>
<h2 id="request（文档对应的位置-http-IncomingMessage-）-和-response-（文档中对应的位置-http-ServerResponse）对象介绍"><a href="#request（文档对应的位置-http-IncomingMessage-）-和-response-（文档中对应的位置-http-ServerResponse）对象介绍" class="headerlink" title="request（文档对应的位置 http.IncomingMessage ） 和 response （文档中对应的位置 http.ServerResponse）对象介绍"></a>request（文档对应的位置 http.IncomingMessage ） 和 response （文档中对应的位置 http.ServerResponse）对象介绍</h2><p>  request ：服务器解析用户提交的 http 请求报文 ，将结果解析到 request 对象中，凡是获取和用户请求相关的数据都可以通过 request 对象来进行。</p>
<p>  response：在服务器端用来向用户做出向应的对象。凡是需要向用户（客户端）响应的操作，都需要通过 response 对象来进行</p>
<h3 id="resquest对象"><a href="#resquest对象" class="headerlink" title="resquest对象"></a>resquest对象</h3><p> resquest 对象类型 &lt;http.IncomingMessage&gt; ,继承自 stream.Readable</p>
<p> resquest对象 常用成员</p>
<p>   1、resquest.headers (请求报文头)</p>
<pre><code> resquest.headers 返回的是一个对象，这个对象中包含了所有的请求报文头
</code></pre>
<p>   2、resquest.rawHeaders (原生的请求报文头)</p>
<pre><code> resquest.rawHeaders 返回的是一个数组，数组中保存的都是请求报文的字符串
</code></pre>
<p>   3、resquest.httpVersion （获取客户端请求的http版本号）</p>
<pre><code> resquest.httpVersion 获取请求客户端所使用的http版本号
</code></pre>
<p>   4、resquest.method （获取的是请求方法）</p>
<pre><code> resquest.method 获取客户端请求使用的方法（POST、GET、、、）
</code></pre>
<p>   5、resquest.url （获取的是请求的文件路径）</p>
<pre><code> resquest.url 获取本次请求的路径
</code></pre>
<h3 id="response对象介绍"><a href="#response对象介绍" class="headerlink" title="response对象介绍"></a>response对象介绍</h3><p>重点说明 response.writeHead() 的使用</p>
<p>1、一般在设置响应报文头都是用res.setHeader()去设置，当我们设置了响应报文头时，一定要在res.write() 和 res.end() 前设置，因为我们不设置响应报文头，系统也会有默认的响应报文头，并且默认发送给浏览器，当已经发送给浏览器响应报文头时就不能再给浏览器发送响应报文头了，所以得提前发送，才不会报错。</p>
<p>2、和res.setHeader() 配合一起使用的还有 ，res.statusCode() //设置 http 响应状态码 ，res.statusMessage() //设置http响应状态码对应的信息</p>
<p>3、这时我们就需要设置三条语句，node.js也为我们提供了一个 res.writeHead（）可同时将三条语句的内容同时设置</p>
<p>比如：res.writeHead(200,’ok’,{</p>
<p>   ‘Content-Type’:’text/plain;charset=utf-8’    </p>
<p>})</p>
<p>注意：当我们采用三条语句设置响应报文头时，服务器内部也会去调用res.writeHead() 这个方法将三条语句填写进去，相当于我你们手动写的简单一条语句完成的动作，但系统会自动转换。</p>
<p>解析：第一个参数是状态码，第二个参数是状态码对应的状态信息，第三个参数是对象设置报文头类型</p>
<p><img src="https://s1.ax1x.com/2020/08/31/dOstk6.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/31/dOskOs.png"></p>
<h2 id="npm介绍"><a href="#npm介绍" class="headerlink" title="npm介绍"></a>npm介绍</h2><h3 id="npm-node包管理器介绍"><a href="#npm-node包管理器介绍" class="headerlink" title="npm node包管理器介绍"></a>npm node包管理器介绍</h3><p> npm node.js代码的包管理器</p>
<p> npm install mime -g </p>
<p>-g 是全局安装的意思，我们的理解是安装好后可以在命令行中直接使用</p>
<p> 当我们需要用命令行使用时才需要全局安装，不然没必要使用全局安装</p>
<p> 当使用npm时一定要执行一次本地安装</p>
<h5 id="npm常用命令介绍："><a href="#npm常用命令介绍：" class="headerlink" title="npm常用命令介绍："></a>npm常用命令介绍：</h5><p> <img src="https://s1.ax1x.com/2020/08/31/dO51wF.png"></p>
<h4 id="模块和包的区别"><a href="#模块和包的区别" class="headerlink" title="模块和包的区别"></a>模块和包的区别</h4><p> <img src="https://s1.ax1x.com/2020/08/31/dOIruV.png"></p>
<h4 id="node-js-错误调试步骤"><a href="#node-js-错误调试步骤" class="headerlink" title="node.js 错误调试步骤"></a>node.js 错误调试步骤</h4><p> <img src="https://s1.ax1x.com/2020/08/31/dOoWdS.png"></p>
<h3 id="package-json-文件介绍"><a href="#package-json-文件介绍" class="headerlink" title="package.json 文件介绍"></a>package.json 文件介绍</h3><p> <strong>描述自身的信息就是 “元数据”</strong></p>
<p> package.json 就是描述包自身的数据信息的文件，也能叫元数据</p>
<p> 一、package.json 文件的作用</p>
<p>   1、package.json 文件是一个包说明文件（项目描述文件），用来管理组织一个包（一个项目）</p>
<p>   2、package.json 文件是一个json格式的文件</p>
<p>   3、位于当前项目的根目录下</p>
<p>   元数据</p>
<p> 二、package.json 文件中常见的项有哪些</p>
<p>  1、 name 包的名字 （必须要有）</p>
<p>  2、 version 包的版本（必须要有）</p>
<p>  3、 description 包描述</p>
<p>  4、author 作者</p>
<p> 三、如何创建一个 package.json 文件</p>
<p>  1、通过 npm init 命令或者npm init -y 或 -npm init -yes 命令</p>
<p> 注意：</p>
<p>  1、通过 npm init -y 或 -npm init -yes 创建 package.json 文件时，执行命令所在的目录接名称中不能包含大写字母</p>
<p>  2、package.json 文件中，项目名称本身不能包含大写字母</p>
<p>  3、npm更新新版本后，项目所在的文件夹如果包含中文等特殊字符，创建的时候不会提示一步一步的输入，直接报错</p>
<h3 id="package-lock-json-文件介绍"><a href="#package-lock-json-文件介绍" class="headerlink" title="package-lock.json 文件介绍"></a>package-lock.json 文件介绍</h3><p>  npm 5.0版本以上的版本才能出现这个文件</p>
<p>  引进这个文件目的：让包文件安装速度加快</p>
<p>  package-lock.json 下载快的原因：</p>
<p>  package.json 里面是保存了包名，当我们项目需要下载其他包时就需要从包名中逐级查找搜索，这样搜索下来肯定很慢</p>
<p>  package-lock.json 里面保存你当前项目依赖的所有的包的地址和版本号都保存到了这个文件中，当项目需要其他包的时候，只需要找到对应的包的地址和版本就可以找到下载了，这样速度就快不少（保存了被依赖包的详细信息）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/08/11/Web/Node%E7%9F%A5%E8%AF%86%E7%90%86%E8%A7%A3/" data-id="ckxvocqyq0029couqaav8etl6" data-title="Nodejs基础性知识点总结" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Web/正则表达式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/03/Web/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2020-07-03T07:45:50.000Z" itemprop="datePublished">2020-07-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BA%94%E7%94%A8/">js正则表达式应用</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/03/Web/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式初步理解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="正则表达式前期知识补充"><a href="#正则表达式前期知识补充" class="headerlink" title="正则表达式前期知识补充"></a>正则表达式前期知识补充</h2><p> 转义字符”&quot; 会把反斜杠后面的字符取消掉原来的意思，加个反斜杠之后就会将反斜杠后面的字符以文本的形式输出。转义符号不会显示出来，如果转义符号想显示出来的话反斜杠前面再加反斜杠就能将反斜杠显示出来。</p>
<p> \r：行结束符</p>
<p> \n:换行</p>
<p> \t:制表符</p>
<p> 多行字符串</p>
<p> 字符串换行符\n</p>
<h2 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h2><p> 正则表达式的作用：匹配特殊字符或有特殊搭配原则的字符的最佳选择。</p>
<p> 用于判读字符串里面有没有特殊的字符</p>
<p> 两种创建方式</p>
<p>   直接量 /添加字符/</p>
<p>   var reg = /abcd/pattern; //pattern这个地方可以放三个参数,分别式”i”,”g”,”m”。分别指定区分大小写、全局匹配、多行匹配</p>
<p>   mew RefExp(“ “ ，” “);//前面的值可以是正则表达式或则是字符串，后面的值式属性包括i、g、m/。</p>
<h2 id="正则表达式的应用"><a href="#正则表达式的应用" class="headerlink" title="正则表达式的应用"></a>正则表达式的应用</h2><p> 一、正则表达式的应用主要提供了两个方法</p>
<p>   reg.test(); //正则表达式上面的方法，用法只能判断字符串上面有没有符合要求的片段，返回值只有” true “或” flase “。</p>
<p>   str.match(); //是可以将匹配到的字符串返回回来。</p>
<p>   reg.exec(); //也是一个匹配的方法，会返回一个类数组</p>
<p>   var reg = /ab/g;<br>   var str = “abababab”;</p>
<p>   lastIndex 就是显示游标的位置。可以手动改变游标而改变显示的位置。</p>
<p> 二、表达式的书写规则</p>
<p> 1、[abc]表达式用于查找方括号之间的任何字符。方括号可以是任何字符或字符串。</p>
<p>   ^放到[]表达式里面[^abcdef]意思是查找给定集合外的任何字符</p>
<p>   示例：查找一串字符串包含的连续数字有哪些</p>
<pre><code>var reg = /[1234567890][1234567890][1234567890]/g;

var str = &quot;123dhsjkadhas883uhjdks888&quot;

str.match(reg);
</code></pre>
<p> 2、（abc|bdf|nyh）表达式查找指定的选项</p>
<p> 3、正则表达式有种贪婪匹配原则</p>
<h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><p>  解释：代表数量的词</p>
<p>  var reg = /\w+/g;意思是能出现多次，从1开始</p>
<p>  var str = “” </p>
<h2 id="支持正则表达式的String-对象的方法"><a href="#支持正则表达式的String-对象的方法" class="headerlink" title="支持正则表达式的String 对象的方法"></a>支持正则表达式的String 对象的方法</h2><p>  search 检索与正则表达式相匹配的值 （返回的是匹配到的这个值的位置，匹配不到的话就是返回-1）</p>
<p>  match 找到一个或多个正则表达式的匹配值（里面添加的是正则表达式）</p>
<p>  split 把字符串分割为字符串数组，按双向重复的拆开，将重复的分割开来</p>
<p>  replace 替换与正则表达式相匹配的子串（最常用）</p>
<p>  示例：var str = “aa”;</p>
<p>  str.replace(“a”,”b”); //这种情况只能匹配一个</p>
<p>  var = /a/g; //这种情况下的才能全部匹配， </p>
<p>  var str = “100000000000”;</p>
<p>  var reg = /(?=(\B)(\d{3})+$)/g;</p>
<p>  console.log(str.replace(reg,”.”));</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/03/Web/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" data-id="ckxvocqyp0024couqblvbcvzc" data-title="正则表达式初步理解" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/WEB/" rel="tag">WEB</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Web/json，异步加载，时间线" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/02/Web/json%EF%BC%8C%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%EF%BC%8C%E6%97%B6%E9%97%B4%E7%BA%BF/" class="article-date">
  <time class="dt-published" datetime="2020-07-02T06:13:16.000Z" itemprop="datePublished">2020-07-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Javascript/">Javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/02/Web/json%EF%BC%8C%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%EF%BC%8C%E6%97%B6%E9%97%B4%E7%BA%BF/">json 异步加载 时间线</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>  JSON是一种传输数据的格式（以对象为样板，本质上就是对象，但用途有区别，对象就是本地用的，json是用来传输的）</p>
<p>  JSON.parse(); string —&gt; json</p>
<p>  JSON.stringify();json —&gt; string</p>
<h2 id="js异步加载"><a href="#js异步加载" class="headerlink" title="js异步加载"></a>js异步加载</h2><p>  javascript异步加载的三种方案</p>
<p>   1、defer异步加载，但要等到dom文档全部解析完才会被执行。只有IE能用，也可以将代码写到内部</p>
<p>   2、async异步加载，加载完就执行，async只能加载外部脚本，不能把JS写到script标签里面</p>
<p>   1.2执行时也不阻塞页面</p>
<p>   3、创建script，插入到DOM中，加载完毕后callBack(按需加载，常用这种方法)</p>
<p>   scroll load（不能将主程序放到这个里面，可以将广告之类的最后执行的事件放里面,意思是其他程序执行完之后执行load事件)</p>
<p>  <img src="https://s1.ax1x.com/2020/07/02/Nbq2Fg.png"></p>
<p>   函数封装后的结果</p>
<p>  <img src="https://s1.ax1x.com/2020/07/02/NbOxZ6.png"></p>
<p>  IE里面用的是onreadytatechange</p>
<p>   callback 回调函数</p>
<h2 id="JS加载时间线"><a href="#JS加载时间线" class="headerlink" title="JS加载时间线"></a>JS加载时间线</h2><p>   主要用处：用于优化代码使用的，用于提升代码执行效率而作用的</p>
<p> 1、创建Document对象，开始解析WEB界面。解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中，阶段document.readyState = ‘loading’.</p>
<p> 2、遇到link外部CSS，创建线程加载，并继续解析文档</p>
<p> 3、遇到script外部JS，并且没有设置async、defer，浏览器加载，并阻塞，等待JS加载完成并执行该脚本，然后继续解析文档</p>
<p> 4、遇到script外部JS,并且设置async、defer,浏览器创建线程加载，并解析文档。对于async属性的脚本，脚本加载完成后立即执行。（异步禁止使用document.write())</p>
<p> 5、遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。</p>
<p> 6、当文档解析文成，document.readyState = “interactive”。</p>
<p> 7、文档解析完成后，所有设置有defer的脚本会按照顺序执行。（注意于anysc的不同，但同样禁止使用document.write()）</p>
<p> 8、document对象触发DOMContentLoaded事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。</p>
<p> 9、当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState = ‘complete’,window对象触发事件。</p>
<p> 10、从此，以异步响应方式处理用户输入，网络事件等。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/02/Web/json%EF%BC%8C%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%EF%BC%8C%E6%97%B6%E9%97%B4%E7%BA%BF/" data-id="ckxvocqz1003ocouq9osz7fsg" data-title="json 异步加载 时间线" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/" rel="tag">web</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Web/JS笔记(3)DOM方法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/06/06/Web/JS%E7%AC%94%E8%AE%B0(3)DOM%E6%96%B9%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2020-06-06T11:45:00.000Z" itemprop="datePublished">2020-06-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Javascript/">Javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/06/06/Web/JS%E7%AC%94%E8%AE%B0(3)DOM%E6%96%B9%E6%B3%95/">Javascript DOM操作方法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>  什么是Dom</p>
<p>  1.DOM —&gt;Document Object Model</p>
<p>  2.DOM定义了表示修改文档所需的方法。DOM对象即为宿主对象，有浏览器厂商定义，用来操作html和Xml功能的一类对象的集合。也有人称DOM是对HTML以及XML的标准编程接口。</p>
<p>  3、DOM开始一切系统给我们生成成组的方式基本上时类数组</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>   构造函数是干嘛的是生成对象的</p>
<h2 id="DOM基本操作"><a href="#DOM基本操作" class="headerlink" title="DOM基本操作"></a>DOM基本操作</h2><p>  一、对节点的增、删、改、改、查</p>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><pre><code>      查看元素节点（以下都是查看元素的方法）

      document代表整个文档（是一个对象，里面有对象和方法）

      document.getElementById() //元素id在Ie8以下的浏览器，不区分id大小写，而且也返回匹配name属性的元素

      .getElementsByTagName(); //标签名,在所有浏览器中都可以说适用

      .getElementByName(); //需注意，只有部分标签name可生效（表单，表单元素，img,iframe）

      .getElementsByClassName() //类名 -&gt; ie8和ie8以下的ie版本中没有这个方法，可以多个class一起

      .querySelector() //CSS选择器 在ie7和ie7以下的版本中没有，可以当CSS选择器一样选择，选择出来的不是一组

      .querySelectorAll() //CSS选择器 在ie7和ie7以下的的版本中没有，选择出来的是一组 
</code></pre>
<p>   only = document.getElementById(“only”) //这语法不能选择出一组id</p>
<p>   div = document.getElementsByTagName(“div”)[0]; //这个语法选中出来的是标签名，是成组的方式呈现的</p>
<p>   2、遍历节点数</p>
<pre><code> parentNode -&gt; 父节点（最顶端的parentNode为#document)；

 childNodes -&gt; 子节点们

 firstChild -&gt; 第一个子节点

 lastChild -&gt; 最后一个子节点

 nextSibling -&gt; 后一个兄弟节点 

 previousSilbling -&gt; 前一个兄弟节点
</code></pre>
<p>  3、基于元素节点树的遍历 （用的较多，重点记忆）</p>
<pre><code> prentElement -&gt; 返回当前元素的父元素的节点（IE不兼容）

 children -&gt; 只返回当前元素的元素子节点（用的频率较高）

 node.childElementCount === node.children.length当前元素节点的子节点 

 firstElementChild -&gt; 返回的是第一个元素节点（IE不兼容）

 lastElementChild -&gt;返回的是最后一个元素节点（IE不兼容）

 nextElementSibling / previousElementSibling -&gt;返回后一个/前一个兄弟元素
</code></pre>
<p>   4、每一个节点都有四个属性</p>
<pre><code>  nodeName

     元素的标签名以大写形式表示，只读

  nodeValue

     Text节点或Comment（注释）节点的文本内容，可读写

  nodeType（最重要重点，判断元素是什么类型的）

     该节点的类型，只读(能够显示元素是什么类型的)

  attributes

     Element 节点的属性集合
</code></pre>
<p>   5、节点的一个方法 Node.hasChildNodes()；   </p>
<p>   6、节点类型</p>
<pre><code>  元素节点 ----1  

  属性节点 ----2

  文本节点 ----3

  注释节点 ----4

  document ----9

  DocumentFragment -----11
</code></pre>
<p>  7、获取节点类型 nodeType   </p>
<p>  8、DOM结构树</p>
<p>   <strong>DOM结构树就是代表的一系列的继承关系</strong></p>
<p>   document —-&gt;(继承) HTMLDocument.prototype —-&gt;Document.portotype</p>
<p>   <img src="https://s1.ax1x.com/2020/06/12/tXNdSg.th.png"></p>
<p>   9、DOM原型链上的基本操作</p>
<pre><code>  1、getElementById 方法定义在Doument.prototype上，即Element节点上不能使用。

  2、getElementsByName方法定义在HTMLDocument.prototype上，即非html中的documen以外不能使用(xml documen,element)

  3、getElementsByTagName方法定义在Document.prototype和Elemen.prototype上

  4、HTMLDocument.prototype定义了一些常用属性，body,head,分别指代HTML文档中的&lt;body&gt;&lt;head&gt;标签
 
  5、Document.prototype上定义了documentElement属性，指代文档的更元素，在HTML文档中，他总是指代&lt;html&gt;元素

  6、getElementsByClassName\querySelectorAll、querySelector在Document,Element类中均有定义
     
 ![](https://s1.ax1x.com/2020/06/13/tvE6J0.png)
</code></pre>
<h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><p>  示例：var div = document.createElement(“div”); //可以创建一个标签，但还没有给到HTML;</p>
<p>  1、document.createElement(); //创建元素节点（<strong>常用</strong>）</p>
<p>  2、document.createTextNode(); //创建文本节点</p>
<p>  3、document.createComment(); //创建注释节点（不常用）</p>
<p>  4、document.createDocumentFragment(); //创建文档碎片节点</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>   1、PARENTNODE.appendChild(); //任何一个元素节点都会有这个属性</p>
<p>   2、PARENTNODE.inserBefore(a,b); // 读法inser”a” , Before”b”  ，把”a”插入到”b”之前。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>   1、parent.removeChild(); //将标签元素剪切出来 （<strong>常用</strong>）</p>
<p>   2、child.remove(); //这是真的销毁掉选择的标签元素（<strong>常用</strong>）</p>
<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p>   1、parent.replaceChild(new,origin); //那”new”的元素去替换”origin”元素 ，理解：用新的元素去替换老的元素</p>
<h3 id="下面是常用方法（重点）"><a href="#下面是常用方法（重点）" class="headerlink" title="下面是常用方法（重点）"></a>下面是常用方法（重点）</h3><p>  二、Element节点的一些属性</p>
<p>  innerHTML</p>
<pre><code>  innerHtml改变一个元素的HTML内容

  innerHtml写啥就能识别啥，还能够写入CSS属性也是能够识别并且引用的
</code></pre>
<p>  innerText(老版本火狐不兼容，现在的基本都兼容)/textContent(老版本IE不好使)</p>
<pre><code>   innerText 可以取元素里面的内容，会把结构覆盖掉
</code></pre>
<p>  三、Eelement节点的一些方法</p>
<pre><code> ele.setAttribute(&quot;class&quot;,&quot;demo&quot;); //给标签设置一个行间属性 ，前面是属性名，后面是属性值

 ele.getAttribute(&quot;class&quot;); //能够获取属性名上的属性值,括号里面填写属性名 ，取行间属性值
</code></pre>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>   一、setInterval（） //每隔一段时间就会去执行里面的内容</p>
<p>   语法：</p>
<pre><code>   setInterval(function()&#123;

&#125;,1000)
</code></pre>
<p>   不能改变time的值来让这个改变时间执行<br>    var time =1000;</p>
<pre><code>setInterval(function()&#123;

&#125;,time)

time = 2000;
</code></pre>
<p>   每一个setInterval都会返回一个标识符</p>
<p>   二、setTimeout() //只执行一次</p>
<p>   三、clearInterval() //清除定时器</p>
<p>   四、clearTimeout()</p>
<p>  重点注意：全局对象window上的方法，内部函数this指向window</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/06/06/Web/JS%E7%AC%94%E8%AE%B0(3)DOM%E6%96%B9%E6%B3%95/" data-id="ckxvocqyh001hcouq5id1fu1o" data-title="Javascript DOM操作方法" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS%E7%AC%94%E8%AE%B0/" rel="tag">JS笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Web/JS笔记（2）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/19/Web/JS%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2020-05-19T02:07:50.000Z" itemprop="datePublished">2020-05-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Javascript/">Javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/19/Web/JS%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/">Javascript基础理解-2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="继承的发展史"><a href="#继承的发展史" class="headerlink" title="继承的发展史"></a>继承的发展史</h2><p>   1、传统形式 —–&gt;原型链</p>
<p>   弊端：过多的继承了没有用的属性</p>
<p>   2、借用构造函数 call/apply</p>
<p>   弊端：（1）不能继承借用构造函数的原型</p>
<p>   （2）每次构造函数都要多走一个函数</p>
<p>   3、共享原型(公有原型)</p>
<p>   弊端：不能随便改变自己的原型，改变了自己的原型也会把继承的那个的原型也一同改变</p>
<p>   4、圣杯模式</p>
<h3 id="共享原型"><a href="#共享原型" class="headerlink" title="共享原型"></a>共享原型</h3><p>   代码格式</p>
<pre><code>   Father.prototype.lastName = &quot;Deng&quot;;

   function Father()&#123;

  
   &#125;

   function Son()&#123;

  
   &#125;

   Son.prototype = Father.prototype
</code></pre>
<p>   添加下面两条语句就可以继承公有原型</p>
<pre><code>   var son = new Son(); //创建对象

   var father = new Father();
</code></pre>
<p>   抽象出一个功能封装成函数，函数就代表功能，函数代表功能的复用，哪块能复用，哪块能定义化就是通过参数来实现的。 </p>
<p>   构造一个函数封装继承</p>
<pre><code>    Father.prototype = lastName = &quot;Deng&quot;;
    
    function Father()&#123;
    
    &#125;
    
    function Son()&#123;
    
    &#125;
    
    function inherit(Target,Origin)&#123;
    
        Target.prototype = Origin.prototype;
    
    &#125;
    
    inherit(Son,Father); //将继承关系封装在这个函数里面
    
    var son = new Son();
    
    var father = new Father();  
</code></pre>
<p>   总结：这种继承方式的弊端是，当我改变son里面的属性的时候Father里面的属性也会改变，我就不能单独给son添加一个自己的的原型。这样也不怎好。后面引申出圣杯模式</p>
<h2 id="圣杯模式"><a href="#圣杯模式" class="headerlink" title="圣杯模式"></a>圣杯模式</h2><p>  方法：还是公有原型，通过添加一个中间的构造函数</p>
<pre><code>  ather.prototype.lastName = &quot;Deng&quot;;

function Father()&#123;

&#125;

function Son()&#123;

&#125;

function inherit(Target,Origin)&#123;

    function F()&#123;&#125;;

    F.prototype = Origin.prototype;
    Target.prototype = new F();

&#125;

inherit(Son,Father);

var son = new Son();

var father = new Father();
</code></pre>
<p>   这种继承方式就不会改变继承的属性方法了。可以访问继承过来的属性</p>
<p>   每一个原型上都有一个系统给我们自带的一个属性叫做constuctor,constuctor默认的值是指向自己的构造函数，那么上面的代码的问题来了，son.constuctor理应指向    function Son(){</p>
<p>}这个函数的</p>
<p>  但这里当我们访问son.constuctor时会指向function Father(){</p>
<p>}这个函数</p>
<p>  为解决这种constuctor指向混乱错误时，我们要让son.constuctor指向的还是    function Son(){</p>
<p>}这个函数的</p>
<p>   我们需要添加下面两条代码</p>
<pre><code> Target.prototype.constuctor = Target;
 Target.prototype.uber = Origin.prototype;//信息的储存
</code></pre>
<p>  代码改正</p>
<pre><code>Father.prototype.lastName = &quot;Deng&quot;;

function Father()&#123;

&#125;

function Son()&#123;

&#125;

function inherit(Target,Origin)&#123;
    function F()&#123;&#125;;

    //一定要先继承才能new
    F.prototype = Origin.prototype;

    Target.prototype = new F();

    Target.prototype.constuctor = Target;
    Target.prototype.uber = Origin.prototype;

&#125;

inherit(Son,Father);

var son = new Son();

var father = new Father();

 
</code></pre>
<p>   还有一种写法</p>
<pre><code>   Father.prototype.lastName = &quot;Deng&quot;;

    function Father()&#123;
    
    &#125;
    
    function Son()&#123;
    
    &#125;
     var inherit = (function()&#123;

     var F = function()&#123;&#125;;

     return function (Target,Origin)&#123;

        F.prototype = Origin.prototype;

       Target.prototype = new F();

       Target.prototype.constuctor = Target;
       Target.prototype.uber = Origin.prototype;
     &#125;
  &#125;());

  var son = new Son();

  var father = new Father();
</code></pre>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>   管理变量，防止污染全局，适用于模块化开发</p>
<p>   1、通过闭包来使变量私有化</p>
<p>   代码格式</p>
<p>   <img src="https://s1.ax1x.com/2020/05/19/Y5m8XR.png"></p>
<h2 id="对象的枚举"><a href="#对象的枚举" class="headerlink" title="对象的枚举"></a>对象的枚举</h2><p>   枚举也叫遍历</p>
<p>   for in 循环写法：</p>
<pre><code>    //就是将属性名放到prop里面

        for(var prop in obj)&#123;
        
           console.log(prop);
        
         &#125;
</code></pre>
<p>   在枚举里面也可以写成  console.log(obj[prop]);这一块只能写成方括号</p>
<p>   for in 循环可以把对象里面的属性提取出来   </p>
<p>   for in 循环作用：就是给对象遍历的，就是给对象设立一个遍历的。</p>
<p>   1.hasOwnProperty（方法）</p>
<p>   2.in （只能访问对象里面的是否有这个属性，包括原型）</p>
<p>   3.instanceof </p>
<h3 id="利用for-in循环遍历不打印原型属性的方法"><a href="#利用for-in循环遍历不打印原型属性的方法" class="headerlink" title="利用for in循环遍历不打印原型属性的方法"></a>利用for in循环遍历不打印原型属性的方法</h3><p>  ** 引入一个方法 hasOwnProperty()**</p>
<p>   hasOwnProperty()这个方法可以找到自己本省的属性，然后利用判断的方法查找是否是本身方法</p>
<p>   系统自带的原型是不会打印出来的</p>
<p>   Object.prototype.abc = “567”; </p>
<p>   这种也是系统自带的，需要特别注意</p>
<p>   代码模式如下</p>
<pre><code>    var obj = &#123;
       name:&quot;nwe&quot;,
       age:123,
       Height:180,
    
       __proto__ :&#123;
          lastName:&quot;deng&quot;
       &#125;
    
    &#125;
    
    for(var prop in obj)&#123;
    
       if(obj.hasOwnProperty(prop))&#123;
    
           console.log(obj[prop]);
       &#125;
    
     &#125;

![](https://s1.ax1x.com/2020/05/20/YoU25D.png)
</code></pre>
<h3 id="instanceof-的使用"><a href="#instanceof-的使用" class="headerlink" title="instanceof 的使用"></a>instanceof 的使用</h3><p>  A instanceof B</p>
<p>  官方解释：A对象 是不是 B构造函数构造出来的 （不全）</p>
<p>  数组也是对象</p>
<p>  A instanceof B</p>
<p>  总结说明：看A对象的原型链上  有没有  B的原型</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>  1、函数预编译过程this —-&gt;window</p>
<p>  2、全局作用域里this —-&gt;window</p>
<p>  3、call/apply 可以改变函数运行时的 this 指向</p>
<p>  4、obj.func();（func里面的 this 指向obj）</p>
<h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>   1、arguments.calle （指向函数自生引用，在哪个函数里面就指向哪个函数）</p>
<p>   举例：<br>        采用立即执行函数的方式求阶乘，arguments.calle 调用自身函数执行多次。</p>
<pre><code>    var num = (function (n)&#123;
      
        if(n==1)&#123;
            return 1;
        &#125;
    
        return n*arguments.callee(n-1); 
    
    &#125;(10))        
</code></pre>
<p>   2、func.caller （在哪调用就是指向的调用哪个函数）</p>
<h2 id="数组运用"><a href="#数组运用" class="headerlink" title="数组运用"></a>数组运用</h2><p>  数组的定义,有两种方式</p>
<pre><code>   new Array(length/content);

   字面量 var arr=new Array();
</code></pre>
<p>  这两种方式的唯一区别</p>
<pre><code>   var arr = new Array(10); //这种方式只会是创建了10位，位数

   var arr1 = [10]; //这种方式会给数组的第一位为10，会赋值给数组的第一位
</code></pre>
<p>  数组的读和写</p>
<pre><code>   arr[num] //不可以溢出读，结果是undefine
 
   arr[num] = xxx; //可以溢出读
</code></pre>
<h3 id="数组的方法运用"><a href="#数组的方法运用" class="headerlink" title="数组的方法运用"></a>数组的方法运用</h3><p>  改变原数组</p>
<pre><code> push, pop, shift, unshift, sort, reverse,splice
</code></pre>
<p>  不改变原数组</p>
<pre><code>  concat,join ---&gt;split,toString,slice
</code></pre>
<p>  重写系统push方法<br>   把最后一位去增加</p>
<pre><code>  var arr = [1,2,3];

  Array.prototype.push = function()&#123;

     for(var i;i&lt;arguments.length ; i++)&#123;

        this[this.length] = arguments[i];
 
     &#125;
 
  return this.length;

 &#125;
</code></pre>
<p>  pop 方法</p>
<p>   把数组的最后一位剪切出来 </p>
<p>  shift方法</p>
<p>   在前面面增加</p>
<p>  unshift方法</p>
<p>   在前面减少</p>
<p>  reverse方法</p>
<p>   逆转顺序</p>
<p>  <strong>splice方法（可以传好些个参数）</strong></p>
<p>  <strong>运用：</strong></p>
<pre><code>var arr = [1,1,2,3,5,6,7];

arr.splice(从第几位开始，截取多少个长度，在截取处添加新的数据)

第几位可以用负数，意思就是从数组的后面倒数几位
</code></pre>
<p> ** 这个方法需要重点掌握，可以在任意位置添加数据**</p>
<p>   sort方法是在原数组上给数组排序的（是按A排序的）</p>
<pre><code>sort留了一个接口，可以让数组安照任意方式进行排序

  var arr = [1,1,2,3,5,6,7];
    
   
  arr.sort(function(a,b)&#123; //这个方法就是没有方法名，相当于函数引用
    
    //1、必须写俩返回值
    //2、看返回值 
          1）当返回值为负数时， 那么前面的数放在前面
          2）为正数， 那么后面的数在前
          3）为0， 不动

    //这里面可以添加任意的排序代码，让数组按照我们想要的方式进行排序

   
  &#125;);
</code></pre>
<p>   <strong>改变</strong></p>
<p>   concat 的方法的使用 （将两个数组连接成一个数组）</p>
<p>   toString 把数组变成字符形式的数组</p>
<p>   slice(从该位开始截取，截取到该位)</p>
<p>   slice 使用举例：</p>
<pre><code>  arr = [1,2,3,4,5,6,7];

  var newArr = arr.slice(1,3);//两个参数的情况

  var newArr = arr.slice(从第几位开始截取，截取到最后); //这是一个参数的情况
</code></pre>
<p>  join —&gt;split (split和数组的方法是可逆的)</p>
<p>  传的是什么就用什么来连接数组之间的值</p>
<pre><code>join（&quot;?&quot;）执行后的形式 1?2?3
</code></pre>
<p>  split 可以让数组按什么形式连接的就可以将什么形式的连接符给去除</p>
<h2 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h2><p>   长的像数组的属性</p>
<p>   <strong>类数组能够当数组使用也能当对象使用，要使用数组时加上数组方法，要使用对象时加上对象的方法。</strong></p>
<p>   1、arguments类数组</p>
<pre><code>  function test()&#123;

    console.log(arguments);
    arguments.push(7);

 &#125;
</code></pre>
<p>   2、有着对象一样的类数组</p>
<pre><code>var obj =&#123;

  &quot;0&quot; : &#39;1&#39;,
  &quot;1&quot; : &#39;2&#39;,
  &quot;2&quot; : &#39;3&#39;,
  &quot;length&quot; :3,
  &quot;push&quot; : Array.prototype.push
   
 
&#125;  
</code></pre>
<p>  注意点：属性要为索引（数字）属性，必须要有length属性，最好加上push</p>
<p>  加上”splice” :Array.prototype.splice这个属性后就更像数组形式了，可以去验证。</p>
<h2 id="this指向的问题在理解"><a href="#this指向的问题在理解" class="headerlink" title="this指向的问题在理解"></a>this指向的问题在理解</h2><pre><code>1、预编译 this ---&gt; window (this指向window)
  
2、谁调用的this指向谁

3、call apply

4、全局this---&gt;window
</code></pre>
<p>  当我们每写一个函数的时候，系统就会预编译环节建立一个AO，AO里面不仅会包含你自己写的属性，也会增加系统隐式给的两个属性，分别是 arguments : {} 这个类数组 ，还有一个 this :window 此时这个this指向的是 window</p>
<p>   函数和函数.call执行是一样的</p>
<p>   函数会有一个隐式的this,</p>
<pre><code>    var this = Object.areate(Student.prototype);Student是函数名
</code></pre>
<p>   <img src="https://s1.ax1x.com/2020/05/25/tClJde.png"></p>
<h2 id="try-catch-e-用法"><a href="#try-catch-e-用法" class="headerlink" title="try{  }catch(e){  }用法"></a>try{  }catch(e){  }用法</h2><p>  e是形参可以自行定义。</p>
<p>   在try里面的代码发生错误是不会再执行try里面报错的后续代码的，然后在try里面的那行错误代码的错误信息可以在catch里面打印出来。只会让try错误后面的代码终止。</p>
<p>   查找错误的错误信息。</p>
<p>   Error.name的六种值对应的信息</p>
<p>   1、EvalError : eval()的使用与定义不一致</p>
<p>   2、RangeError : 数值越界</p>
<p>   3、ReferenceError : 非法或不能识别的引用数值</p>
<p>   4、SyntaError : 发生语法解析错误</p>
<p>   5、TypeError : 操作数据类型错误</p>
<p>   6、URIError ：URI处理函数使用不当</p>
<h2 id="es5标准模式"><a href="#es5标准模式" class="headerlink" title="es5标准模式"></a>es5标准模式</h2><pre><code>“use strict”
不再兼容es3的一些不规则语法。使用全新的es5规范。
两种用法：
   全局严格模式
   局部函数内严格模式（推荐）
就是一行字符串，不会对不兼容严格模式的浏览器产生影响。

不支持with,arguments.callee,func.caller,变量赋值前必须声明，局部this必须被赋值(Person.call(null/undefined) 赋值什么就是什么),拒绝重复属性和参数
</code></pre>
<p>   浏览器是基于 es3.0 和 es5.0 新增方法 去执行的</p>
<p>   es3.0 和es5.0产生冲突的部分</p>
<p>   es5.0严格模式 那么es3.0和es5.0 产生冲突的部分就是用es5.0否则会用es3.0</p>
<p>   es5.0严格模式的启动 “use strict”; (写在页面代码的最顶端就可以启动es5.0严格模式的方法，也可以写在函数里面的最顶端，但这个时候就是启动的这个函数是遵循es5.0严格模式，但其他函数是不受影响的)</p>
<p>   用字符串来表示的用意是为了兼容老浏览器，如果没有更新的话也能安照老版本去执行而字符串表达式也不会报错，如果更新了也能识别到，这个时候就能执行es5.0版本的严格模式了</p>
<h2 id="执行期上下文with的用法"><a href="#执行期上下文with的用法" class="headerlink" title="执行期上下文with的用法"></a>执行期上下文with的用法</h2><pre><code>var obj = &#123;
  name : &quot;123&quot;,
&#125;

function test()&#123;
  name =&quot;235&quot;;
  with(obj)&#123; //with（可以直接访问）

   console.log(name);
  &#125;
&#125;

test();
</code></pre>
<p>   es5的严格模式不能用这个with</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/19/Web/JS%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/" data-id="ckxvocqyl001qcouq7nrk08rd" data-title="Javascript基础理解-2" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" rel="tag">JS学习记录</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Web/JS笔记（1）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/11/Web/JS%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2020-05-11T12:39:00.000Z" itemprop="datePublished">2020-05-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Javascript/">Javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/11/Web/JS%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/">Javascript基础理解-1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="函数的定义和函数的执行是分隔开来的，一般是先定义函数的，然后再执行函数"><a href="#函数的定义和函数的执行是分隔开来的，一般是先定义函数的，然后再执行函数" class="headerlink" title="函数的定义和函数的执行是分隔开来的，一般是先定义函数的，然后再执行函数"></a>函数的定义和函数的执行是分隔开来的，一般是先定义函数的，然后再执行函数</h1><p>   <strong>函数的定义和函数的执行是分隔开来的，重点注意函数的执行顺序，什么时候定义的，然后又是什么时候去执行的</strong></p>
<p>   <strong>形参：形式参数，比如字符代替的参数</strong><br>   <strong>实参：实际参数，比如完整的数字，给的完全的数据</strong></p>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>   AO{</p>
<p>   最开始每个变量都是 undefined 然后查找变量是否为函数 最后查找函数是有变为实参被定义。按这种方法来查找函数的执行顺序</p>
<p>  }</p>
<p>   GO{</p>
<p>  }全局变量</p>
<p>  <img src="https://s1.ax1x.com/2020/05/13/YaQtET.png"></p>
<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>函数声明和函数表达式是不一样的</p>
<pre><code>function test()&#123;&#125; //函数声明
</code></pre>
<p>  只有表达式才能被执行符号执行</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>  当内部函数被保存到外部时，将会生成闭包。闭包会导致所有作用域链不释放，造成内存泄漏</p>
<h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><p>  过多的使用会导致内存的泄露</p>
<p>  累加器就是用这个闭包实现的</p>
<p>  <strong>闭包的四个应用</strong></p>
<pre><code>   1、实现公有变量

         比如：函数累加器

   2、可以做缓存（存储结构）

        比如：eater

   3、可以实现封装，属性私有化

        比如：Person

   4、模块化开发防止污染全局
</code></pre>
<p>  <img src="https://s1.ax1x.com/2020/05/11/YJLWz8.png"></p>
<p>  闭包可以做缓存应用的代码示例</p>
<pre><code> //代码思路：最先new一个方法，方法里面写一个对象，对象包含两个方法，也可以是对象里面有属性


function eater()&#123; //新建一个方法
     var food=&quot;&quot;;

    var obj=&#123; //创建一个对象
        //编写属于对象的两个属性
        eat :function()&#123; 
            console.log(&quot;i am &quot;+food);
            food=&quot;&quot;;
            &#125;, 
        //注意两个属性之间要用逗号隔开
        push :function(myfood)&#123; 
            food = myfood;

        &#125;

    &#125;

    return obj;

&#125;

    var eater1 = eater(); //将返回的对象值赋值给一个值
    
    eater1.push(&quot;apple&quot;);//要先写这个，给对象的属性一个值，才能执行到下一句
    eater1.eat();

//要先给push属性一个值，下面那个方法才能打印出之前给的值
</code></pre>
<p>  <img src="https://s1.ax1x.com/2020/05/11/YJxI5d.png"></p>
<h2 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h2><p>   针对初始化功能的函数，执行完函数，就会将函数立即释放，执行完函数就是被销毁。</p>
<p>   编程的形式代码</p>
<pre><code>     (function abc()&#123;

        var a=123;
        var b=567;
    
        console.log(a+b);
    &#125;())
</code></pre>
<p>   <img src="https://s1.ax1x.com/2020/05/11/YYP5a8.png"></p>
<p>   立即执行函数返回值的接收方法</p>
<pre><code>  var num  = (function abc(a,b)&#123;

       var d= a+b;
       return d; 
      
    &#125;(1,2))
</code></pre>
<h1 id="数组应用方法"><a href="#数组应用方法" class="headerlink" title="数组应用方法"></a>数组应用方法</h1><pre><code>function test()&#123;
    var arr = [];
    for(var i=0; i&lt;10; i++)&#123;
        
            arr[i]=function()&#123;
            console.log(i+&quot; &quot;);
        &#125;
       
    &#125;

    return arr;

&#125;

var myArr = test();
for(var j=0; j&lt;10;j++)
&#123;
    myArr[j](); //对前面执行的函数形成了一个闭包，在这里打印的10个数据都是10。这里就促发了闭包。

&#125;
</code></pre>
<h2 id="闭包理解"><a href="#闭包理解" class="headerlink" title="闭包理解"></a>闭包理解</h2><p>  <strong>循环最容易触发闭包，需要特别注意循环是否触发闭包</strong></p>
<p>  闭包的效果是让函数的执行顺序改变。</p>
<pre><code>function a()&#123;  
  
    function b()&#123;
        var bbb=234;
        document.write(aaa);
    &#125;
   
     var aaa=123;

     return b;//就是将内部函数导入到外部去执行
&#125;


var demo = a();
demo();
    
</code></pre>
<p>   不用return 的第二种实现方式<br>   <img src="https://s1.ax1x.com/2020/05/12/YtK79I.png"></p>
<h2 id="闭包的原理"><a href="#闭包的原理" class="headerlink" title="闭包的原理"></a>闭包的原理</h2><p>  如果想让for循环里面的函数立即执行，而不是等到外部访问了之后才去执行，那么我们就可以利用立即执行函数，将每一次的循环都执行到那个函数，然后当我们去访问这个函数的时候就可以得到每一次都执行的结果，而不是等到外部访问的时候执行的结果是总的结果。</p>
<pre><code>   function test()&#123;
        var arr = [];
        for(var i=0; i&lt;10; i++)&#123;
            
                arr[i]=function()&#123;
                console.log(i+&quot; &quot;);
            &#125;
           
        &#125;
    
        return arr;
    
    &#125;
    
    var myArr = test();
    for(var j=0; j&lt;10;j++)
    &#123;
        myArr[j]();
    
    &#125;
</code></pre>
<p>   <strong>解决办法在触发闭包后的解决办法</strong></p>
<h3 id="触发闭包后的解决办法"><a href="#触发闭包后的解决办法" class="headerlink" title="触发闭包后的解决办法"></a>触发闭包后的解决办法</h3><p>  多个函数嵌套时，容易触发闭包，把里面的这个函数保存到外部函数的外部，保存到了全局，这种情况必然会生成闭包。然后里面的函数在外部执行时，就一定能够调用得了原来他在的那个环境里面的变量。</p>
<p>  <strong>利用闭包解决闭包</strong></p>
<pre><code>function test()&#123;
    var arr = [];
    for(var i=0; i&lt;10; i++)&#123;
        
        (function (j)&#123;

               arr[j]= function()&#123;
                document.write(j+&quot; &quot;);
               &#125;
        &#125;(i))
     
       //用闭包的方式解决问题
    &#125;

    return arr;

&#125;

var myArr = test();
for(var j=0; j&lt;10;j++)
&#123;
      myArr[j]();

&#125;
</code></pre>
<h2 id="内存泄漏意思理解"><a href="#内存泄漏意思理解" class="headerlink" title="内存泄漏意思理解"></a>内存泄漏意思理解</h2><p>   意思是过多的占用内存资源。剩的资源空间就会少了</p>
<h1 id="闭包作用示例"><a href="#闭包作用示例" class="headerlink" title="闭包作用示例"></a>闭包作用示例</h1><h2 id="累加器"><a href="#累加器" class="headerlink" title="累加器"></a>累加器</h2><p>   <strong>不依赖于外部变量并且能够反复执行的函数累加器</strong></p>
<p>  <img src="https://s1.ax1x.com/2020/05/12/YtTJm9.png"> </p>
<h2 id="闭包的第三点应用"><a href="#闭包的第三点应用" class="headerlink" title="闭包的第三点应用"></a>闭包的第三点应用</h2><p>   私有化变量</p>
<p>   访问的时是函数内部自己的变量</p>
<p>   <img src="https://s1.ax1x.com/2020/05/19/Y44v4A.png"></p>
<h2 id="只有表达式才能被执行"><a href="#只有表达式才能被执行" class="headerlink" title="只有表达式才能被执行"></a>只有表达式才能被执行</h2><p>   函数声明</p>
<pre><code>    function test()&#123;

    &#125;
</code></pre>
<p>  函数表达式</p>
<pre><code>    var demo = function()&#123;

        console.log(&#39;a&#39;);
    &#125;
</code></pre>
<p>  这下面这种执行也是表达式。<br>   test(); //创建的方法去执行</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>  生活中任何一个事物都可以抽象成一个对象</p>
<p>  基础的变量类型</p>
<p>  可以有属性，有方法</p>
<h3 id="属性的-增、删、改、查"><a href="#属性的-增、删、改、查" class="headerlink" title="属性的 增、删、改、查"></a>属性的 增、删、改、查</h3><p>  探索任何东西都要符合一个原则，怎么操作的，怎么构成的</p>
<p>  计算机通用操作就是增、删、改、查</p>
<p>  删除属性要用到 delete</p>
<pre><code>     delete mrDERAN.name
</code></pre>
<h3 id="对象的创建方法"><a href="#对象的创建方法" class="headerlink" title="对象的创建方法"></a>对象的创建方法</h3><p>   1、var obj = {}  plainObject 对象字面量/对象直接量</p>
<p>   2、构造函数</p>
<p>   1）系统自带的构造函数  new Object() Object<br>   2)自定义</p>
<pre><code> var obj = new Object();

 obj.name = &#39;abc&#39;; // 添加属性
 obj.sex = &#39;male&#39;; //添加属性

 obj.say = function()&#123;&#125; //这里面也可以添加方法,但这里面的方法需要用等号连接
</code></pre>
<p>   3、通过添加new创建一个对象</p>
<pre><code>     function person()&#123; &#125; //创建一个方法或者说是构造函数

    var person1 = new person();  //给创建的方法添加上一个new就可以创建一个对象了，和前面几种创建对象的方法基本上没有什么去别
</code></pre>
<p>   大驼峰式命名规则 TheHeName (命名规则)</p>
<p>   4、”new”一个对象之后函数里面会添加一个this</p>
<pre><code>var this = Object.create(函数名.prototype)//隐式的
</code></pre>
<p>   <img src="https://s1.ax1x.com/2020/05/22/YXr0Xt.png"></p>
<h3 id="构造函数的内部原理"><a href="#构造函数的内部原理" class="headerlink" title="构造函数的内部原理"></a>构造函数的内部原理</h3><p>   有new之后内部自动将构造的函数转换成 var this = {}</p>
<p>   返回                         return this  这个样式之后就能形成以一个对象</p>
<p>   <img src="https://s1.ax1x.com/2020/05/14/YDJMX8.png"></p>
<p>   注意最后会返回一个this</p>
<p>   <img src="https://s1.ax1x.com/2020/05/14/YD3MXF.png"></p>
<p>   构造函数如何实现的三段论</p>
<pre><code>   现在函数体最前面隐式的加上 var this = &#123;&#125;
   先隐式的来个 this
   隐式的返回 return this
</code></pre>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>   原始值不单单指的是数字，其他定义的原始变量都可以指原始值</p>
<p>   只有原始值数字才是原始值</p>
<p>   原始值不可能有属性和方法，只有转换成对象才能够有属性和方法</p>
<p>   隐式的环节就是经过包装类之后的结果</p>
<pre><code> 常见包装类：
       new String();
       new Boolean();
       new Number();
</code></pre>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>   1、定义：原型是function的对象的一个属性，他定义了构造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。</p>
<p>   2、利用原型特点和概念，可提取共用属性（可以将共有的属性提取出来，下面是使用示例）</p>
<p>   使用示例</p>
<p>   <img src="https://s1.ax1x.com/2020/05/15/Yrec24.png"></p>
<p>   原型也是有增、删、改、查</p>
<p>   修改的话是要在原型的对象上进行。<br>   Person.prototype.lastname</p>
<p>   <img src="https://s1.ax1x.com/2020/05/15/YrmfSg.png"></p>
<p>   3、对象如何查看原型 -&gt;隐式属性 <strong>proto</strong></p>
<p>   4、对象如何查看对象的构造函数 -&gt;constructor</p>
<p>   Prototype原型空对象，可以将固有的公共的属性写在这个原型空对象上面，就可以最大限度的使用内存空间</p>
<p>  常用方式</p>
<pre><code> var obj = &#123;&#125; 这种方式构建对象常用

 var obj1 = new Object(); 这种构建对象方式不常用并且比较麻烦
</code></pre>
<h2 id="绝大多数对象的最终都会继承自Object-prototype"><a href="#绝大多数对象的最终都会继承自Object-prototype" class="headerlink" title="绝大多数对象的最终都会继承自Object.prototype"></a>绝大多数对象的最终都会继承自Object.prototype</h2><h2 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h2><p>   系统也会有自带的属性的方法，但我们用系统自带的属性的名字重新写一个也叫做方法的重写</p>
<p>   我在原型链的中间截断写一个自己需要的方法就是说方法的重写，写一个自己需要用到了方法</p>
<p>   <img src="https://s1.ax1x.com/2020/05/18/YhfPsg.png"></p>
<p>   在页面中能够打印出字符的底层原理</p>
<p>   <img src="https://s1.ax1x.com/2020/05/18/Yh45in.png"></p>
<pre><code>    Object.prototype.toString
    Number.prototype.toString
    Array.prototype.toString
    Boolean.prototype.toString
    String.prototype.toString
</code></pre>
<h2 id="call-apply的作用"><a href="#call-apply的作用" class="headerlink" title="call/apply的作用"></a>call/apply的作用</h2><p>   <strong>call/apply的作用：改变this指向，利用别人的方法实现自己的功能</strong></p>
<p>   call/apply的区别：</p>
<p>   call需要把实参按照形参的个数传进去</p>
<p>   apply 需要传一个arguments,按照数组形式传入</p>
<p>   总结：后面传的参数的形式不同（传参列表不同）</p>
<p>   自行理解：当两个对象需要用到同一个属性的时候就可以用这种方法去实现。可以将第一个对象的属性写齐，然后第二个对象就可以利用call去共同使用第一个对象的属性</p>
<pre><code>    function Person(name,age)&#123;
    
      相当于this = obj

        this.name = name;
        this.age = age;
    &#125;
    
    var person = new Person(&quot;laodeng&quot;,100);
    
    var obj = &#123;
    
    &#125;
    
    Person.call(obj,&#39;cheng&#39;,300); //添加上这条语句时就可以让this指向obj这个对象里面的属性,那么Person.call(obj,后面的值就可以添加的obj对象里面的那个属性里去了
</code></pre>
<p>   实现的结果</p>
<p>   <img src="https://s1.ax1x.com/2020/05/18/YhL9qP.png"></p>
<p>   一般用到这个的地方形式</p>
<pre><code>        function Person(name,age)&#123;
        
            this.name = name;
            this.age = age;
        &#125;
        
        function Student(name,age,sex,tel)&#123;
            
            Person.call(this,name,age); //重要语句
        
            this.sex = sex;
            this.tel = tel;
        
        &#125;
        
        var student = new Student(&quot;laodeng&quot;,100,&#39;male&#39;,1237);
</code></pre>
<p>   这样就能将Person里面的属性调用到Sudent这个对象里面去使用</p>
<p>   apply </p>
<h2 id="原型总结"><a href="#原型总结" class="headerlink" title="原型总结"></a>原型总结</h2><p>   <strong>先继承后引用</strong></p>
<p>   原型是一个prototype ，原型是一个function的一个属性。</p>
<p>   是函数就有这个属性，每个函数都有</p>
<p>   原型这个函数构造对象的共有祖先</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/11/Web/JS%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/" data-id="ckxvocqyi001mcouq0auuglhd" data-title="Javascript基础理解-1" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" rel="tag">js学习记录</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Web/经典例题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/09/Web/%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2020-05-09T14:28:50.000Z" itemprop="datePublished">2020-05-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Javascript/">Javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/09/Web/%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98/">JS经典例题总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="第一题、构造函数和对象的知识运用"><a href="#第一题、构造函数和对象的知识运用" class="headerlink" title="第一题、构造函数和对象的知识运用"></a>第一题、构造函数和对象的知识运用</h2><p>  这个题目也有考闭包的问题</p>
<pre><code>  function Person(name,age ,sex)&#123;
    var a=0;
    this.name = age;
    this.age = age;
    this.sex = sex;
    function abc()&#123;
        a++;
        console.log(a);
        
    &#125;

    this.say = abc;

&#125;
//这个函数做的运算最后会将this的值返回出来给函数

var person3 = new Person(); //将构造函数转换成对象
  
person3.say(); //得出的结果是1
person3.say(); //得出的结果是2

var person5 = new Person(); //又会将构造函数再一次的转换成对象，是一个全新的

person5.say(); //由于上面又会将构造函数再一次的转换成一个全新的对象，所以这里打印的值依旧是 “ 1 ”。
</code></pre>
<p>  <img src="https://s1.ax1x.com/2020/05/14/YDwos1.png"></p>
<h2 id="第二题、求字符串的长度"><a href="#第二题、求字符串的长度" class="headerlink" title="第二题、求字符串的长度"></a>第二题、求字符串的长度</h2><p>   第一种方法实现</p>
<pre><code>   function retbyteslen(target)&#123;

    var count = target.length; //设定字符的长度

    for(var i=0; i &lt;target.length;i++)&#123;

        if(target.charCodeAt(i)&lt;=255)&#123;
            count++; // 让字符的长度加一

        &#125;else if(target.charCodeAt(i)&gt;255)&#123;
            count+=2;  //如果是汉字的话加二

        &#125;

    &#125;
    console.log(count);

&#125;
</code></pre>
<p>   <img src="https://s1.ax1x.com/2020/05/14/YD6vA1.png"></p>
<pre><code>function retbyteslen(target)&#123;

    var count = target.length;
    for(var i; i &lt;target.length;i++)&#123;

        if(target.charCodeAt(i)&gt;255)&#123;
            count++;
        &#125;

    &#125;
    console.log(count);

&#125;
</code></pre>
<p>  <img src="https://s1.ax1x.com/2020/05/14/YD6TpT.png"></p>
<h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>   以下表达式的结果为true(A C D)</p>
<pre><code>A、undefined == null; //这个两个类型，当undefined &lt; 0或者是undefined&gt;0或者是undefined=0，都是返回false ,然而当null&lt;0 或者是 null&gt;0 null=0 也都是返回false ,所以这时系统会认为这两个时相等的。

B、undefined === null;//(三个等于号是绝对等于，就是完全一摸一样，像镜子找出来的一样)

C、isNaN(&quot;100&quot;)

D、parseInt(&quot;la&quot;)==1;
</code></pre>
<h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2><p>   这是一题比较新颖的写法  </p>
<pre><code>function print()&#123;
    bar.a = &#39;a&#39;;
    Object.prototype.b = &#39;b&#39;;
    
    return function inner()&#123;
        console.log(bar.a);
        console.log(bar.b);
    &#125;
&#125;

prin()(); //第一个括号就是返回的一个函数，第二个括号是返回的那个函数执行   
</code></pre>
<h2 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h2><p>  ** 浅度克隆**</p>
<pre><code>var test=&#123;
    name : &quot;int&quot;,
    sex: &quot;mlea&quot;,
    age: 789
&#125;

var obj = &#123;

&#125;

function inherit(Origin,target)&#123;
    var target = target||&#123;&#125;;
    for(pro in test)
    &#123;
         target[pro]=Origin[pro] ;
    &#125;

    return target;
&#125;
inherit(test,obj);
</code></pre>
<p> ** 深度克隆** </p>
<pre><code>遍历对象 for(var prop in obj)
</code></pre>
<p>   步骤：<br>       1、判断是不是原始值 (方法：typeof() object)</p>
<pre><code>   2、判断是数组还是对象 （方法：instanceof toString constructor）一般不用instanceof和constructor会出现一些问题，但是有这三种方法去判断是数组还是对象

   3、建立相应的数组或对象

   4、递归
   
</code></pre>
<p>   代码：</p>
<pre><code>var test=&#123;
    name : &quot;int&quot;,
    sex: &quot;mlea&quot;,
    age: 789,
    card:[&#39;visa&#39;,&#39;unionpay&#39;]
&#125;

var obj = &#123;

&#125;
function deepclone(origin,target)&#123;
  var  target = target||&#123;&#125;,
       tostr = Object.prototype.toString,
        arrstr =&quot;[object Arry]&quot;;
        for(var prop in origin)
        &#123;
            if(origin.hasOwnProperty(prop))
            &#123;
               if(origin[prop] !=&quot;null&quot;&amp;&amp;typeof(origin[prop])==&#39;object&#39;)
               &#123;
                    if(tostr.call(origin[prop])==arrstr)
                    &#123;
                      target[prop]=[];   
                    &#125;else&#123;
                      target[prop]=&#123;&#125;;
                   &#125;    
                  
                   deepclone(origin[prop],target[prop]);//递归
                
                &#125;else
                &#123;
                  target[prop] = origin[prop];
                &#125;   
            &#125;
       
    &#125;
 return target;
&#125;

deepclone(test,obj);
</code></pre>
<p>   <img src="https://s1.ax1x.com/2020/05/22/YX7Izt.png"></p>
<h2 id="第六题-区分typeof-里面的原始值和引用值"><a href="#第六题-区分typeof-里面的原始值和引用值" class="headerlink" title="第六题 区分typeof()里面的原始值和引用值"></a>第六题 区分typeof()里面的原始值和引用值</h2><pre><code>function typein(target)&#123;
 
  var objtype = &#123;
    &quot;[object Object]&quot; : &quot;object&quot;,
    &quot;[object Array]&quot;  : &quot;array&quot;,
    &quot;[object Number]&quot; : &quot;Number -object&quot;,
    &quot;[object Boolean]&quot;: &quot;boolean - object&quot;,
    &quot;[object String]&quot; : &quot;String - object&quot;
  &#125;
 

  if(target === null)&#123;
    return &quot;null&quot;;
  &#125;
   
  if(typeof(target) == &quot;object&quot;)&#123;
    var str = Object.prototype.toString.call (target); //取出对象里面的字符 ---&gt; 重点语句
    
    return objtype[str];
  &#125;else&#123;
    return typeof(target);
  &#125;

&#125;
</code></pre>
<p>  下面是简化代码</p>
<p>  <img src="https://s1.ax1x.com/2020/05/25/tp4Icn.png"></p>
<h2 id="第七题-数组去重，在原型链上写"><a href="#第七题-数组去重，在原型链上写" class="headerlink" title="第七题 数组去重，在原型链上写"></a>第七题 数组去重，在原型链上写</h2><pre><code>var arr= [1,1,2,2,5,5,6,6,8,8];

Array.prototype.unique = function ()&#123;

  var arr = [],obj = &#123;&#125;,len =this.length;

  for(var i=0;i&lt;len;i++)&#123;
    if(!obj[this[i]])&#123;
      obj[this[i]] = &quot;abc&quot;;
      arr.push(this[i]);
    &#125;
  &#125;
  return arr;

&#125;
console.log(arr.unique());
</code></pre>
<p>  <img src="https://s1.ax1x.com/2020/05/25/tpqkL9.png"></p>
<h2 id="第八题-封装一个函数，能够实现将新生成的标签插入原有标签的前面"><a href="#第八题-封装一个函数，能够实现将新生成的标签插入原有标签的前面" class="headerlink" title="第八题 封装一个函数，能够实现将新生成的标签插入原有标签的前面"></a>第八题 封装一个函数，能够实现将新生成的标签插入原有标签的前面</h2><p>   在原型链上编写</p>
<p>   HTML代码：</p>
<pre><code>   &lt;div&gt;
        &lt;span&gt;&lt;/span&gt;
        &lt;strong&gt;&lt;/strong&gt;
        &lt;i&gt;&lt;/i&gt;
        &lt;address&gt;&lt;/address&gt;
    &lt;/div&gt;
</code></pre>
<p>   JS代码：</p>
<pre><code>Element.prototype.inserAfter = function (targetNode,afterNode)&#123;

        var beforeNode=afterNode.nextElementSibling;
        if(beforeNode==null)&#123;
            this.appendChild(targetNode)
        &#125;else&#123;
        
            this.inserBefore(targetNode,beforeNode);

        &#125;
        
    &#125;
    var div = document.getElementsByTagName(&quot;div&quot;)[0];
    var strong = document.getElementsByTagName(&quot;strong&quot;)[0];

    var span = document.getElementsByTagName(&quot;span&quot;)[0];
      
    var p = document.createElement(&#39;p&#39;);
</code></pre>
<h2 id="第九题"><a href="#第九题" class="headerlink" title="第九题"></a>第九题</h2><p>  下列说法错误的是（）</p>
<pre><code>A. call 和 apply 在参数中有区别，后者采用数组方式传参

B. call函数执行会返回一个函数。

C. 被bind后的函数this指向就确定了。

D. call函数在执行的时候改变执行函数中的this指向。
</code></pre>
<p>   这个题目中引用的知识点</p>
<p>   我们一开始需要先知道call，aplly,bind 是干嘛用的</p>
<p>   call,aplly。在函数执行的时候，改变this指向</p>
<p>   call 的参数形式arg1,arg2,arg3</p>
<p>   apply 参数形式 数组 （不定参数）</p>
<p>   call 基于apply函数进行封装的。</p>
<p>   a.call(this,a,b,c) =&gt;a.apply(this,[a,b,c])</p>
<p>   a.apply(this,[1,2,3]) ==&gt;a.call(this, ….[1,2,3])</p>
<h2 id="第十题"><a href="#第十题" class="headerlink" title="第十题"></a>第十题</h2><pre><code> function addToList(item,list)&#123;
        return list.push(item);
   &#125;

 var result = addToList(&quot;apple&quot;,[&quot;banana&quot;]);
  console.log(result);
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/09/Web/%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98/" data-id="ckxvocqyq0027couq6pno69x9" data-title="JS经典例题总结" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HEML-CSS-JS/" rel="tag">HEML+CSS+JS</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-driver_code" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/03/driver_code/" class="article-date">
  <time class="dt-published" datetime="2020-05-03T00:39:00.000Z" itemprop="datePublished">2020-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/STM32/">STM32</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/03/driver_code/">STM32 HAL驱动库函数总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、驱动文件说明"><a href="#一、驱动文件说明" class="headerlink" title="一、驱动文件说明"></a>一、驱动文件说明</h2><p>humidity and temperature (HTS221) 温湿度传感器</p>
<p>3D accelerometer and 3D magnetometer (lsm303agr) 3D加速度计和3D磁力仪</p>
<p>3D accelerometer and 3D gyroscope (LSM6DSL) 加速度，陀螺</p>
<p>260-1260 hPa absolute digital output barometer (LPS22HB) 气压计</p>
<h2 id="二、驱动代码下载"><a href="#二、驱动代码下载" class="headerlink" title="二、驱动代码下载"></a>二、驱动代码下载</h2><p><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1WGmaVVaBxiWr2m8vsVtqZg">驱动代码自取地址</a></p>
<p>提取码：wpdn </p>
<h2 id="三、HTS221驱动函数理解"><a href="#三、HTS221驱动函数理解" class="headerlink" title="三、HTS221驱动函数理解"></a>三、HTS221驱动函数理解</h2><h3 id="整个HTS221温湿度获取设置函数"><a href="#整个HTS221温湿度获取设置函数" class="headerlink" title="整个HTS221温湿度获取设置函数"></a>整个HTS221温湿度获取设置函数</h3><p>注册总线IO口的传输协议函数</p>
<p>   <code>int32_t HTS221_RegisterBusIO(HTS221_Object_t *pObj, HTS221_IO_t *pIO)</code></p>
<p>传感器初始化函数</p>
<p>   <code>int32_t HTS221_Init(HTS221_Object_t *pObj)</code></p>
<p>取消传感器初始化函数</p>
<p>   <code>int32_t HTS221_DeInit(HTS221_Object_t *pObj)</code></p>
<p>读取设备的地址</p>
<p>   <code>int32_t HTS221_ReadID(HTS221_Object_t *pObj, uint8_t *Id)</code></p>
<p>获得HTS221传感器功能（指向HTS221传感器功能的指针）</p>
<p>   <code>int32_t HTS221_GetCapabilities(HTS221_Object_t *pObj, HTS221_Capabilities_t *Capabilities)</code></p>
<p>获取HTS221初始化状态（0代表初始化状态成功，1表示初始化状态不成功）</p>
<p>   <code>int32_t HTS221_Get_Init_Status(HTS221_Object_t *pObj, uint8_t *Status)</code></p>
<h3 id="获取湿度一系列函数"><a href="#获取湿度一系列函数" class="headerlink" title="获取湿度一系列函数"></a>获取湿度一系列函数</h3><p>启用HTS221湿度传感器 （0代表启动成功，1表示启动不成功）</p>
<p>   <code>int32_t HTS221_HUM_Enable(HTS221_Object_t *pObj)</code></p>
<p>关闭HTS221湿度传感器</p>
<p>   <code>int32_t HTS221_HUM_Disable(HTS221_Object_t *pObj)</code></p>
<p>获取HTS221湿度传感器输出数据率</p>
<p>   <code>int32_t HTS221_HUM_GetOutputDataRate(HTS221_Object_t *pObj, float *Odr)</code></p>
<p>设置HTS221湿度传感器输出数据速率</p>
<p>   <code>int32_t HTS221_HUM_SetOutputDataRate(HTS221_Object_t *pObj, float Odr)</code></p>
<p>获取HTS221湿度值</p>
<p>   <code>int32_t HTS221_HUM_GetHumidity(HTS221_Object_t *pObj, float *Value)</code></p>
<p>获取HTS221湿度数据就绪位值</p>
<p>   <code>int32_t HTS221_HUM_Get_DRDY_Status(HTS221_Object_t *pObj, uint8_t *Status)</code></p>
<h3 id="获取温度一系列函数"><a href="#获取温度一系列函数" class="headerlink" title="获取温度一系列函数"></a>获取温度一系列函数</h3><p>启用HTS221温度传感器获取温度 （0代表启动成功，1表示启动不成功）</p>
<p>   <code>int32_t HTS221_TEMP_Enable(HTS221_Object_t *pObj)</code></p>
<p>停止HTS221温度传感器获取温度</p>
<p>   <code>int32_t HTS221_TEMP_Disable(HTS221_Object_t *pObj)</code></p>
<p>获取HTS221温度传感器输出数据率</p>
<p>   <code>int32_t HTS221_TEMP_GetOutputDataRate(HTS221_Object_t *pObj, float *Odr)</code></p>
<p>设置HTS221温度传感器输出数据速率</p>
<p>   <code>int32_t HTS221_TEMP_SetOutputDataRate(HTS221_Object_t *pObj, float Odr)</code></p>
<p>获取HTS221温度值</p>
<p>   <code>int32_t HTS221_TEMP_GetTemperature(HTS221_Object_t *pObj, float *Value)</code></p>
<p>获取HTS221温度数据就绪位值</p>
<p>   <code>int32_t HTS221_TEMP_Get_DRDY_Status(HTS221_Object_t *pObj, uint8_t *Status)</code></p>
<p>获得HTS221一次性状态</p>
<p>   <code>int32_t HTS221_Get_One_Shot_Status(HTS221_Object_t *pObj, uint8_t *Status)</code></p>
<p>获取HTS221寄存器的值</p>
<p>   <code>int32_t HTS221_Read_Reg(HTS221_Object_t *pObj, uint8_t Reg, uint8_t *Data)</code></p>
<p>写入HTS221寄存器的值</p>
<p>   <code>int32_t HTS221_Write_Reg(HTS221_Object_t *pObj, uint8_t Reg, uint8_t Data)</code></p>
<p>获取输出数据速率</p>
<p>   <code>static int32_t HTS221_GetOutputDataRate(HTS221_Object_t *pObj, float *Odr)</code></p>
<p>设置输出数据速率</p>
<p>   <code>static int32_t HTS221_SetOutputDataRate(HTS221_Object_t *pObj, float Odr)</code></p>
<p>启用HTS221 DRDY中断模式</p>
<p>   <code>int32_t HTS221_Enable_DRDY_Interrupt(HTS221_Object_t *pObj)</code></p>
<p>用于应用系数的函数</p>
<p>   <code>static float Linear_Interpolation(lin_t *Lin, float Coeff)</code></p>
<p>将读寄存器组件函数包装成总线IO函数</p>
<p>   <code>static int32_t ReadRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)</code></p>
<p>写寄存器组件功能到总线IO功能</p>
<p>   <code>static int32_t WriteRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)</code></p>
<h2 id="四、LPS22HB驱动函数理解"><a href="#四、LPS22HB驱动函数理解" class="headerlink" title="四、LPS22HB驱动函数理解"></a>四、LPS22HB驱动函数理解</h2><p>   LPS22HB:测量大气压强的传感器</p>
<p>   LPS22HB基于HAL库的程序构成由外设芯片型号加上具体实现的气压（PRESS）和16位温度传感器（TEMP）操作构成，压力传感器和之前说明的HTS221的函数功能基本一样，这里不做具体讲解，可参考HTS221函数说明</p>
<p>   注意一点传感器和单片机是否通信正常，主要是通过读取WHO_AM_I确定读写是否正常的，所以在调试单片机程序时应当最先将这部分调试完成。</p>
<h2 id="五、LSM6DS驱动函数理解"><a href="#五、LSM6DS驱动函数理解" class="headerlink" title="五、LSM6DS驱动函数理解"></a>五、LSM6DS驱动函数理解</h2><p>   加速度计陀螺仪组合芯片LSM6DS</p>
<p>   加速度计陀螺仪测量芯片LSM6DS基于HALE库的程序设计功能的模型都是和HTS221温湿度的测量基本差不多的，这里需要特别注意测量加速度时会有以ACC（加速度）和 GYRO （陀螺仪）表明的函数名称需要加以识别</p>
<h2 id="六、lsm303agr驱动函数理解"><a href="#六、lsm303agr驱动函数理解" class="headerlink" title="六、lsm303agr驱动函数理解"></a>六、lsm303agr驱动函数理解</h2><p>  加速度和地磁芯片lsm303agr</p>
<p>  加速度和地磁芯片的基于HAL库的驱动函数构成名字及功能和之前所讲解的HTS221芯片基于HAL库的驱动程序基本差不多，这边可以参考HTS221的代码流程，这边主要注意一下ACC（加速度）和MAG（磁力计）两个数据的获取代码。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/03/driver_code/" data-id="ckxvocqy3000fcouqbjncafpb" data-title="STM32 HAL驱动库函数总结" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/STM32-HAL%E9%A9%B1%E5%8A%A8%E5%BA%93%E5%87%BD%E6%95%B0/" rel="tag">STM32 HAL驱动库函数</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Fritzing" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/02/Fritzing/" class="article-date">
  <time class="dt-published" datetime="2020-05-02T01:39:00.000Z" itemprop="datePublished">2020-05-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/STM32/">STM32</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/02/Fritzing/">电路开发软件 Fritzing 的使用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、问题提出"><a href="#一、问题提出" class="headerlink" title="一、问题提出"></a>一、问题提出</h2><p>我们在开发硬件模块时经常需要画出实际电路板才能测试电路是否可行，这在开发时不仅消耗的具体成本和时间上都很大，那么有没有一款软件能够以实际电路为导向将物理模型预先测试好呢？找了许久才找到这么一款电路开发软件Fritzing软件。</p>
<h2 id="二、软件准备"><a href="#二、软件准备" class="headerlink" title="二、软件准备"></a>二、软件准备</h2><p>我把软件放到百度网盘上了，直接下载解压，运行打开Fritzing.exe就可以使用了</p>
<p><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/18629tJJowlElGbGH2UitOg">软件地址</a></p>
<p>  提取码：zepo</p>
<p><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1FNmqcxKL8uNGGeZ8_HJMfQ">测试文件下载地址</a></p>
<p>  提取码：qyv2</p>
<h2 id="三、软件介绍"><a href="#三、软件介绍" class="headerlink" title="三、软件介绍"></a>三、软件介绍</h2><p><img src="https://s1.ax1x.com/2020/05/04/YP1Ce1.png"></p>
<p>1、菜单栏：一些软件基本功能查找设置的地方</p>
<p>2、快捷操作栏：可以任意切换到面包板，原理图和PCB的操作</p>
<p>3、主工作区：用于面包板、原理图和PCB的设计的地方</p>
<p>4、元件栏：用于我们常用元件放置的地方，我们需要用到的元件一般都可以在这地方找到，如果找不到还能外接添加库</p>
<p>5、提示栏：用于提示选择元件属性参数，类型的地方，也可用于选择的元件设置参数</p>
<h2 id="四、展示效果"><a href="#四、展示效果" class="headerlink" title="四、展示效果"></a>四、展示效果</h2><p><img src="https://s1.ax1x.com/2020/05/05/YkVlOx.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/02/Fritzing/" data-id="ckxvocqxw0001couq9lukepak" data-title="电路开发软件 Fritzing 的使用" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Fritzing%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/" rel="tag">Fritzing软件使用</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Web/html+CSS总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/01/Web/html+CSS%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2020-05-01T04:03:00.000Z" itemprop="datePublished">2020-05-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/HTML-CSS/">HTML+CSS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/01/Web/html+CSS%E6%80%BB%E7%BB%93/">html和CSS易混淆知识点总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>这些元素的行级块级都是通过CSS控制的，也都是可以通过CSS去改变</strong></p>
<p><strong>凡是带有inline的元素，都有文字特性</strong></p>
<h1 id="1、行级元素-inline"><a href="#1、行级元素-inline" class="headerlink" title="1、行级元素 # inline"></a>1、行级元素 # inline</h1><p>   feature : 内容决定元素所占位置</p>
<p>   不可以通过CSS改变宽高</p>
<p>  例如：span strong em a del</p>
<h1 id="2、块级元素-block"><a href="#2、块级元素-block" class="headerlink" title="2、块级元素 # block"></a>2、块级元素 # block</h1><p>   feature : 独占一行</p>
<p>   可以通过CSS改变宽高</p>
<p>  例如： div p ul ol form address</p>
<h1 id="3、行级块元素-inline-block"><a href="#3、行级块元素-inline-block" class="headerlink" title="3、行级块元素 # inline-block"></a>3、行级块元素 # inline-block</h1><p>   feature : 内容决定大小</p>
<p>   可以改变宽高</p>
<h1 id="多个图片无空格占一行显示解决办法"><a href="#多个图片无空格占一行显示解决办法" class="headerlink" title="多个图片无空格占一行显示解决办法"></a>多个图片无空格占一行显示解决办法</h1><p>   添加一条CSS语句<br>          margin-left:-6px;<br>   用margin-left 去解决 </p>
<h1 id="display-inline-block，block，inline的区别与用法"><a href="#display-inline-block，block，inline的区别与用法" class="headerlink" title="display:inline-block，block，inline的区别与用法"></a>display:inline-block，block，inline的区别与用法</h1><p>  首先要了解一下什么是块级元素与什么是行级元素</p>
<h3 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h3><p>   <strong>会占领页面一行</strong>，其后多个block元素自动换行、<strong>可以设置width,height,设置了width后同样也占领一行</strong>、同样也可以设置margin与padding属性。</p>
<p>   <strong>常见的块级元素：div,img,ul,form,p</strong></p>
<h3 id="行级元素"><a href="#行级元素" class="headerlink" title="行级元素"></a>行级元素</h3><p>   <strong>与其他元素在同一行上</strong>，<strong>高度，行高以及底边距不可以改变</strong>，高度就是内容文字或者图片的宽度，不可以改变。</p>
<p>   <strong>常见的行级元素：em,strong,br,input</strong></p>
<h3 id="display-inline-block，block，inline的区别"><a href="#display-inline-block，block，inline的区别" class="headerlink" title="display:inline-block，block，inline的区别"></a>display:inline-block，block，inline的区别</h3><p>  1、display:block将元素显示为块级元素，<strong>从而可以更好地操控元素的的宽高，以及内外边距，每一个块级元素都是从新的一行开始的</strong>。</p>
<p>  2、display:inline将元素显示为<strong>行内元素，高度，行高及底边距不可改变</strong>，高度就是内容文字或者图片的宽度，不可以改变。多个相邻的行内元素排在同一行里，<strong>知道页面一行排列不下。才会换新的一行。</strong></p>
<p>  3、display:inline-block 看上去值名inline-block是一个混合产物，实际上确是如此，将元素显示为行内块状元素，设置该属性后，<strong>其他的行内块元素会排列在同一行</strong>。比如我们” li “元素是一个inline-block,使其既有block的宽度高度特性，又有inline的同行特性，在同一行内有不同高度内容元素时，通常要设置对齐方式如 **vertical-align:top; **来是元素顶部对齐。
  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/01/Web/html+CSS%E6%80%BB%E7%BB%93/" data-id="ckxvocqyn001wcouq91jae6yi" data-title="html和CSS易混淆知识点总结" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/">51单片机</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/FreeRTOS/">FreeRTOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTML/">HTML</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTML-CSS/">HTML+CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/">Javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/STM32/">STM32</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/imageClass/">imageClass</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BA%94%E7%94%A8/">js正则表达式应用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodejs/">nodejs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/">树莓派</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%80%BB%E8%BE%91%E5%99%A8%E4%BB%B6/">逻辑器件</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS%E5%B1%9E%E6%80%A7%E5%86%85%E5%AE%B9/" rel="tag">CSS属性内容</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fritzing%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/" rel="tag">Fritzing软件使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HEML-CSS-JS/" rel="tag">HEML+CSS+JS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hal%E5%BA%93%E4%B8%B2%E5%8F%A3%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/" rel="tag">Hal库串口中断服务函数的使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hal%E5%BA%93%E5%BA%94%E7%94%A8/" rel="tag">Hal库应用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" rel="tag">JS学习记录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS%E7%AC%94%E8%AE%B0/" rel="tag">JS笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPI-GPIO/" rel="tag">RPI.GPIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STM32-HAL%E9%A9%B1%E5%8A%A8%E5%BA%93%E5%87%BD%E6%95%B0/" rel="tag">STM32 HAL驱动库函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Serial-Chart%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/" rel="tag">Serial Chart软件使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VLC%E8%A7%86%E9%A2%91%E6%B5%81%E4%BD%BF%E7%94%A8/" rel="tag">VLC视频流使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB/" rel="tag">WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" rel="tag">js学习记录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/raspberry4B/" rel="tag">raspberry4B</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/" rel="tag">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95/" rel="tag">串口调试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%91%84%E5%83%8F%E5%A4%B4%E4%BD%BF%E7%94%A8/" rel="tag">摄像头使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B/" rel="tag">新建工程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%83%A7%E5%BD%95Raspbian%E7%B3%BB%E7%BB%9F/" rel="tag">烧录Raspbian系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%A8C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/" rel="tag">用C语言编程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS%E5%B1%9E%E6%80%A7%E5%86%85%E5%AE%B9/" style="font-size: 10px;">CSS属性内容</a> <a href="/tags/Fritzing%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">Fritzing软件使用</a> <a href="/tags/HEML-CSS-JS/" style="font-size: 10px;">HEML+CSS+JS</a> <a href="/tags/Hal%E5%BA%93%E4%B8%B2%E5%8F%A3%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/" style="font-size: 20px;">Hal库串口中断服务函数的使用</a> <a href="/tags/Hal%E5%BA%93%E5%BA%94%E7%94%A8/" style="font-size: 20px;">Hal库应用</a> <a href="/tags/JS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" style="font-size: 10px;">JS学习记录</a> <a href="/tags/JS%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">JS笔记</a> <a href="/tags/RPI-GPIO/" style="font-size: 10px;">RPI.GPIO</a> <a href="/tags/STM32-HAL%E9%A9%B1%E5%8A%A8%E5%BA%93%E5%87%BD%E6%95%B0/" style="font-size: 10px;">STM32 HAL驱动库函数</a> <a href="/tags/Serial-Chart%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">Serial Chart软件使用</a> <a href="/tags/VLC%E8%A7%86%E9%A2%91%E6%B5%81%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">VLC视频流使用</a> <a href="/tags/WEB/" style="font-size: 10px;">WEB</a> <a href="/tags/js%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" style="font-size: 10px;">js学习记录</a> <a href="/tags/node-js/" style="font-size: 20px;">node.js</a> <a href="/tags/raspberry4B/" style="font-size: 10px;">raspberry4B</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95/" style="font-size: 10px;">串口调试</a> <a href="/tags/%E6%91%84%E5%83%8F%E5%A4%B4%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">摄像头使用</a> <a href="/tags/%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">新建工程</a> <a href="/tags/%E7%83%A7%E5%BD%95Raspbian%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">烧录Raspbian系统</a> <a href="/tags/%E7%94%A8C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">用C语言编程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/03/linearClassifier/">线性分类器设计</a>
          </li>
        
          <li>
            <a href="/2021/05/03/imageClass/">图像分类任务及线性分类</a>
          </li>
        
          <li>
            <a href="/2020/12/31/raspberry/raspberryprog6/">在树莓派上安装python、openCV库遇到的问题</a>
          </li>
        
          <li>
            <a href="/2020/12/31/freeRTOS/freertos1/">认识FreeRTOS（1）</a>
          </li>
        
          <li>
            <a href="/2020/12/28/raspberry/raspberryprog5/">在树莓派上安装RPI.GPIO库(5)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>