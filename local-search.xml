<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>线性分类器设计</title>
    <link href="/2021/05/03/linearClassifier/"/>
    <url>/2021/05/03/linearClassifier/</url>
    
    <content type="html"><![CDATA[<h2 id="线性分类器"><a href="#线性分类器" class="headerlink" title="线性分类器"></a>线性分类器</h2><h3 id="数据集介绍"><a href="#数据集介绍" class="headerlink" title="数据集介绍"></a>数据集介绍</h3><p>1）CIFAR10数据集 ：包含50000张的训练样本，10000张测试样本，图像为彩色图像，大小为32*32</p><p>2）设计一个分类器，下图是一个主要的流程图</p><p><img src="https://gitee.com/liloong/blogimage/raw/master/myimg/20210503175729.png"></p><h3 id="基于像素的图像表示"><a href="#基于像素的图像表示" class="headerlink" title="基于像素的图像表示"></a>基于像素的图像表示</h3><p>图像的类型主要有三种：黑白图像（Binary）、灰度图像（Gray Scale）、彩色图像（Color）</p><p>黑白图像（Binary）：0和1表示每一个像素点</p><p>灰度图像（Gray Scale）: 每一个像素点由一个字节表示0~255</p><p>彩色图像（Color）： 每一个像素点由三个字节表示，一个字节表示R，一个字节表示G，一个字节表示B</p><h3 id="分类模型"><a href="#分类模型" class="headerlink" title="分类模型"></a>分类模型</h3><p>使用线性分类器理由：通过层次结构（神经网络）或者高维映射（支撑向量）可以形成功能强大的非线性模型。</p><p>什么是线性分类器：线性分类器是一种线性映射，将输入的图像特征映射为类别分数</p><p>线性分类器的定义：X代表输入的 d 维图像向量（3072维），c为类别个数（我们要分类的类别个数）</p><p><img src="https://gitee.com/liloong/blogimage/raw/master/myimg/20210503214612.png"></p><h3 id="线性分类器示例"><a href="#线性分类器示例" class="headerlink" title="线性分类器示例"></a>线性分类器示例</h3><p><img src="https://gitee.com/liloong/blogimage/raw/master/myimg/20210503215154.png"></p><h3 id="线性分类器的矩阵表示"><a href="#线性分类器的矩阵表示" class="headerlink" title="线性分类器的矩阵表示"></a>线性分类器的矩阵表示</h3><p><img src="https://gitee.com/liloong/blogimage/raw/master/myimg/20210503215303.png"></p><p><img src="https://gitee.com/liloong/blogimage/raw/master/myimg/20210503215433.png"></p><h3 id="线性分类器的决策边界"><a href="#线性分类器的决策边界" class="headerlink" title="线性分类器的决策边界"></a>线性分类器的决策边界</h3><p> 箭头方向代表分类器的正方向，沿着箭头方向距离决策面越远分数就越高</p><p><img src="https://gitee.com/liloong/blogimage/raw/master/myimg/20210503225111.png"></p><h2 id="损失函数的设计"><a href="#损失函数的设计" class="headerlink" title="损失函数的设计"></a>损失函数的设计</h2><p>1)损失函数的定义</p><p>2）多类支撑向量机损失</p><p>3）正则项与超参数</p><h3 id="损失函数的定义"><a href="#损失函数的定义" class="headerlink" title="损失函数的定义"></a>损失函数的定义</h3><p><img src="https://gitee.com/liloong/blogimage/raw/master/myimg/20210503230048.png"></p><h3 id="多类支撑向量机损失"><a href="#多类支撑向量机损失" class="headerlink" title="多类支撑向量机损失"></a>多类支撑向量机损失</h3>]]></content>
    
    
    <categories>
      
      <category>imageClass</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图像分类任务及线性分类</title>
    <link href="/2021/05/03/imageClass/"/>
    <url>/2021/05/03/imageClass/</url>
    
    <content type="html"><![CDATA[<h2 id="图像分类"><a href="#图像分类" class="headerlink" title="图像分类"></a>图像分类</h2><p>1.什么是图像分类任务，它有哪些应用场合</p><p>​    跨越”语义鸿沟“建立像素到语义的映射</p><p>2.图像分类任务有哪些难点？</p><p>   把所以问题进行一个拆解，然后逐个找到对应的解决办法</p><p>3.基于规则的方法是否可行</p><p>   不可行</p><p>4.什么是数据驱动的分类范式</p><p>​       1）数据集构建</p><p>​       2）分类器设计学习</p><p>​      从数据中去归纳出规律，那么就需要找到一个数学模型，  我要从数据中将数学模型中未知的参数             填上，这个过程就是学习。</p><p>​       3）分类器决策</p><p>​       对未知的事情做一个决策</p><p>5.常用的分类任务评价指标</p><h3 id="分类器的核心是设计与学习"><a href="#分类器的核心是设计与学习" class="headerlink" title="分类器的核心是设计与学习"></a>分类器的核心是设计与学习</h3><p><img src="https://gitee.com/liloong/blogimage/raw/master/myimg/20210503164002.png"></p><h3 id="将学习用于决策"><a href="#将学习用于决策" class="headerlink" title="将学习用于决策"></a>将学习用于决策</h3><p>  机器学习主要是将图像表示，分类模型，预测值</p><p><img src="https://gitee.com/liloong/blogimage/raw/master/myimg/20210503164747.png"></p><h3 id="图像表示"><a href="#图像表示" class="headerlink" title="图像表示"></a>图像表示</h3><p><img src="https://gitee.com/liloong/blogimage/raw/master/myimg/20210503165704.png"></p><p>分类器很多，每一个分类器都有各自的特点和特性，我们它的时候，主要是学习它的长项和弱项。学习机器学习的时候就需要懂得每个分类器对应不同任务时是否称手，这时就需要去理解它的原理，每个工具能够干什么，知道它的优势和劣势，以及能够对他进行改造，用于我们的任务。</p><p><img src="https://gitee.com/liloong/blogimage/raw/master/myimg/20210503171340.png"></p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>损失函数：就是度量真实值和预测值之间的不一定程度，然后输出损失值，让我们能够对分类模型有一定的认知。这个分类模型干得好不好。</p><p><img src="https://gitee.com/liloong/blogimage/raw/master/myimg/20210503172140.png"></p><h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><p>采用的时迭代法，下一次比上一次做得好</p><p><img src="https://gitee.com/liloong/blogimage/raw/master/myimg/20210503172355.png"></p><h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><p><img src="https://gitee.com/liloong/blogimage/raw/master/myimg/20210503173021.png"></p><h2 id="图像分类的评价指标"><a href="#图像分类的评价指标" class="headerlink" title="图像分类的评价指标"></a>图像分类的评价指标</h2><p>正确率 = 分对的样本书 / 全部样本数</p><p>错误率 = 1-正确率</p><h3 id="Top指标与Top5指标"><a href="#Top指标与Top5指标" class="headerlink" title="Top指标与Top5指标"></a>Top指标与Top5指标</h3><p>Top1 : 意思是此分类器在预测五个结果中，只看第一个结果，第一个结果对了，那么就说明此分类器对这张图片的预测是对的</p><p>Top5 : 意思是此分类器在预测的五个结果中，有一个结果是对的，那么就认为此分类器对这张图片的预测是对的</p><p><img src="https://gitee.com/liloong/blogimage/raw/master/myimg/20210503174731.png"></p>]]></content>
    
    
    <categories>
      
      <category>imageClass</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>在树莓派上安装python、openCV库遇到的问题</title>
    <link href="/2020/12/31/raspberry/raspberryprog6/"/>
    <url>/2020/12/31/raspberry/raspberryprog6/</url>
    
    <content type="html"><![CDATA[<h2 id="1-python环境安装"><a href="#1-python环境安装" class="headerlink" title="1.python环境安装"></a>1.python环境安装</h2><h3 id="1-1树莓派镜像版本"><a href="#1-1树莓派镜像版本" class="headerlink" title="1.1树莓派镜像版本"></a>1.1树莓派镜像版本</h3><p>更换镜像源时，一定要注意查看自己的系统镜像是哪一个的！而不是网上搜一下树莓派的源就直接复制粘贴一顿猛操作！即使是树莓派的镜像源Debian系统也分好几种，wheezy、jessie、stretch、buster，它们分别对应：</p><p><img src="https://liloong.gitee.io/my_image/img/22.png"></p><h3 id="1-2查看树莓派是哪个镜像"><a href="#1-2查看树莓派是哪个镜像" class="headerlink" title="1.2查看树莓派是哪个镜像"></a>1.2查看树莓派是哪个镜像</h3><p>首先我使用命令： lsb_release -a ，查看当前树莓派系统版本，具体信息如下，此版本的代号为 “buster”</p><p><img src="https://liloong.gitee.io/my_image/img/23.png"></p><h3 id="1-3根据不同的镜像版本更新不同的镜像源"><a href="#1-3根据不同的镜像版本更新不同的镜像源" class="headerlink" title="1.3根据不同的镜像版本更新不同的镜像源"></a>1.3根据不同的镜像版本更新不同的镜像源</h3><h4 id="1-3-1使用管理员权限（经由sudo），编辑-etc-apt-sources-list文件。参考命令行为："><a href="#1-3-1使用管理员权限（经由sudo），编辑-etc-apt-sources-list文件。参考命令行为：" class="headerlink" title="1.3.1使用管理员权限（经由sudo），编辑/etc/apt/sources.list文件。参考命令行为："></a>1.3.1使用管理员权限（经由sudo），编辑/etc/apt/sources.list文件。参考命令行为：</h4><pre><code>sudo nano /etc/apt/sources.list</code></pre><h4 id="1-3-2用-注释掉原文件内容，用以下内容取代："><a href="#1-3-2用-注释掉原文件内容，用以下内容取代：" class="headerlink" title="1.3.2用#注释掉原文件内容，用以下内容取代："></a>1.3.2用#注释掉原文件内容，用以下内容取代：</h4><pre><code>deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpideb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi</code></pre><p>替换完成后的效果图</p><p><img src="https://liloong.gitee.io/my_image/img/20.png"></p><h4 id="1-3-3使用管理员权限（经由sudo），编辑-etc-apt-sources-list-d-raspi-list文件。参考命令行为："><a href="#1-3-3使用管理员权限（经由sudo），编辑-etc-apt-sources-list-d-raspi-list文件。参考命令行为：" class="headerlink" title="1.3.3使用管理员权限（经由sudo），编辑/etc/apt/sources.list.d/raspi.list文件。参考命令行为："></a>1.3.3使用管理员权限（经由sudo），编辑/etc/apt/sources.list.d/raspi.list文件。参考命令行为：</h4><pre><code>sudo nano /etc/apt/sources.list.d/raspi.list</code></pre><h4 id="1-3-4用-注释掉原文件内容，用以下内容取代："><a href="#1-3-4用-注释掉原文件内容，用以下内容取代：" class="headerlink" title="1.3.4用#注释掉原文件内容，用以下内容取代："></a>1.3.4用#注释掉原文件内容，用以下内容取代：</h4><pre><code>deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main uideb-src http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui</code></pre><p>替换完成后的效果图</p><p><img src="https://liloong.gitee.io/my_image/img/24.png"></p><h3 id="1-4镜像替换总结"><a href="#1-4镜像替换总结" class="headerlink" title="1.4镜像替换总结"></a>1.4镜像替换总结</h3><p>根据自己的镜像系统版本将图中位置的地方替换成自己系统版本名，这部分镜像替换就大功告成，下面就可以进行python的安装</p><p><img src="https://liloong.gitee.io/my_image/img/25.png"></p><p> 修改完毕后，记得执行如下命令，更新软件源列表！</p><pre><code>sudo apt-get updatesudo apt-get upgrade</code></pre><h2 id="2-树莓派关于Python软件环境安装"><a href="#2-树莓派关于Python软件环境安装" class="headerlink" title="2.树莓派关于Python软件环境安装"></a>2.树莓派关于Python软件环境安装</h2><h3 id="2-1安装python依赖的环境"><a href="#2-1安装python依赖的环境" class="headerlink" title="2.1安装python依赖的环境"></a>2.1安装python依赖的环境</h3><pre><code>sudo apt-get install build-essential libsqlite3-dev sqlite3 bzip2 libbz2-dev</code></pre><h3 id="2-2下载python3-6版本源码并解压和编译"><a href="#2-2下载python3-6版本源码并解压和编译" class="headerlink" title="2.2下载python3.6版本源码并解压和编译"></a>2.2下载python3.6版本源码并解压和编译</h3><p>注：可根据自己项目要求使用不同python版本，将3.9.1替换成需要的版本好，其他步骤一样</p><pre><code>wget https://www.python.org/ftp/python/3.9.1/Python-3.9.1.tgz解压 tar zxvf Python-3.9.1.tgz切换到解压目录 cd Python-3.9.1开始编译 $ sudo ./configure $ sudo make $ sudo make install升级pip sudo python3.9 -m pip install --upgrade pip</code></pre><h3 id="2-3卸载树莓派系统自带2-7版本"><a href="#2-3卸载树莓派系统自带2-7版本" class="headerlink" title="2.3卸载树莓派系统自带2.7版本"></a>2.3卸载树莓派系统自带2.7版本</h3><pre><code>sudo apt-get autoremove python2.7</code></pre><h3 id="2-4卸载完后，我们还是需要新建一个链接来使得python可以出来python3-x"><a href="#2-4卸载完后，我们还是需要新建一个链接来使得python可以出来python3-x" class="headerlink" title="2.4卸载完后，我们还是需要新建一个链接来使得python可以出来python3.x"></a>2.4卸载完后，我们还是需要新建一个链接来使得python可以出来python3.x</h3><pre><code>sudo ln -s /usr/bin/python3.9 /usr/bin/python</code></pre><h2 id="3-建立软连接"><a href="#3-建立软连接" class="headerlink" title="3.建立软连接"></a>3.建立软连接</h2><h3 id="3-1这一步主要是将原有的python2-x版本和python之间的链接删除（不像上面直接卸载python2-x）并添加python3-x的链接"><a href="#3-1这一步主要是将原有的python2-x版本和python之间的链接删除（不像上面直接卸载python2-x）并添加python3-x的链接" class="headerlink" title="3.1这一步主要是将原有的python2.x版本和python之间的链接删除（不像上面直接卸载python2.x）并添加python3.x的链接"></a>3.1这一步主要是将原有的python2.x版本和python之间的链接删除（不像上面直接卸载python2.x）并添加python3.x的链接</h3><p>首先我们查看python和python3的详细版本：</p><p>安装python3.9后我们可以看一下python的版本</p><pre><code>$ python --versionPython 2.7.1$ python3 --versionPython 3.9.1</code></pre><h3 id="3-2接下来查看python和python3的编译器位置"><a href="#3-2接下来查看python和python3的编译器位置" class="headerlink" title="3.2接下来查看python和python3的编译器位置"></a>3.2接下来查看python和python3的编译器位置</h3><pre><code>$ which python/usr/bin/python$ which python3/usr/bin/python3.9</code></pre><h3 id="3-3然后建立软连接"><a href="#3-3然后建立软连接" class="headerlink" title="3.3然后建立软连接"></a>3.3然后建立软连接</h3><pre><code> sudo mv /usr/bin/python /usr/bin/python2.7.1 sudo ln -s /usr/bin/python3.9 /usr/bin/python</code></pre><h3 id="3-4测试"><a href="#3-4测试" class="headerlink" title="3.4测试"></a>3.4测试</h3><pre><code>$ python --versionPython 3.9.1</code></pre><h2 id="4-openCV环境安装"><a href="#4-openCV环境安装" class="headerlink" title="4.openCV环境安装"></a>4.openCV环境安装</h2><h3 id="4-1安装openCV依赖的环境"><a href="#4-1安装openCV依赖的环境" class="headerlink" title="4.1安装openCV依赖的环境"></a>4.1安装openCV依赖的环境</h3><p>注：建议逐个安装</p><pre><code>sudo apt-get updatesudo apt-get upgradesudo apt-get install libhdf5-dev libhdf5-serial-devsudo apt-get install libqtgui4 libqtwebkit4 libqt4-test python3-pyqt5sudo apt-get install libatlas-base-devsudo apt-get install libjasper-dev</code></pre><h3 id="4-2利用python自带的软件包工具pip进行安装"><a href="#4-2利用python自带的软件包工具pip进行安装" class="headerlink" title="4.2利用python自带的软件包工具pip进行安装"></a>4.2利用python自带的软件包工具pip进行安装</h3><p>先安装科学计算numpy，再安装,opencv-python</p><pre><code> sudo pip install numpy sudo pip install opencv-python</code></pre><h3 id="4-3测试"><a href="#4-3测试" class="headerlink" title="4.3测试"></a>4.3测试</h3><p>运行python</p><pre><code>&gt;&gt;&gt; import cv2&gt;&gt;&gt; print(cv2.__version__)</code></pre><p><img src="https://liloong.gitee.io/my_image/img/26.png"></p><h2 id="在利用pip工具安装openCV时遇到的报错"><a href="#在利用pip工具安装openCV时遇到的报错" class="headerlink" title="在利用pip工具安装openCV时遇到的报错"></a>在利用pip工具安装openCV时遇到的报错</h2><p>打算在树莓派上做一个智能识别，需要用到OPenCV，运行”sudo pip install opencv-python”，出现了如下报错。</p><p><img src="https://liloong.gitee.io/my_image/img/19.png"></p><h3 id="我的系统问题解决方法"><a href="#我的系统问题解决方法" class="headerlink" title="我的系统问题解决方法"></a>我的系统问题解决方法</h3><p>卸载高版本和 pip</p><pre><code>sudo apt-get autoremove python3-pipsudo apt-get autoremove python3.9sudo reboot # 重启 再次安装pipsudo apt-get install python3-pip 再次更新python3.9 -m pip --upgrade pip</code></pre><h2 id="5-参考文献"><a href="#5-参考文献" class="headerlink" title="5.参考文献"></a>5.参考文献</h2><h3 id="5-1镜像替换参考资料"><a href="#5-1镜像替换参考资料" class="headerlink" title="5.1镜像替换参考资料"></a>5.1镜像替换参考资料</h3><p><a href="https://blog.csdn.net/la9998372/article/details/77886806" title="为树莓派更换国内镜像源">https://blog.csdn.net/la9998372/article/details/77886806</a></p><p><a href="https://blog.csdn.net/fightingboom/article/details/106879019" title="树莓派想使用 aptitude 解决依赖包问题，但是使用 apt-get 安装 aptitude 时出现依赖包错误怎么办？">https://blog.csdn.net/fightingboom/article/details/106879019</a></p><h3 id="5-2pip安装其他包报错参考资料"><a href="#5-2pip安装其他包报错参考资料" class="headerlink" title="5.2pip安装其他包报错参考资料"></a>5.2pip安装其他包报错参考资料</h3><p><a href="https://learnku.com/python/t/43724" title="在树莓派同时拥有 python3.6 和 3.7 时 pip 异常">https://learnku.com/python/t/43724</a></p>]]></content>
    
    
    <categories>
      
      <category>树莓派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>raspberry4B</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认识FreeRTOS（1）</title>
    <link href="/2020/12/31/freeRTOS/freertos1/"/>
    <url>/2020/12/31/freeRTOS/freertos1/</url>
    
    <content type="html"><![CDATA[<h2 id="FreeRTOS任务特性"><a href="#FreeRTOS任务特性" class="headerlink" title="FreeRTOS任务特性"></a>FreeRTOS任务特性</h2><p>简单</p><p>没有使用限制</p><p>支持抢占</p><p>支持优先级</p><p>每个任务都拥有堆栈导致了RAM 使用量增大</p><h2 id="FreeRTOS任务状态"><a href="#FreeRTOS任务状态" class="headerlink" title="FreeRTOS任务状态"></a>FreeRTOS任务状态</h2><ul><li><p>运行态 : 指的是当前任务占用CPU的使用权</p></li><li><p>就绪态 ：等待CPU调度</p></li><li><p>阻塞态 ：阻塞态就是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进去就绪状态，才有机会转到运行状态（一个任务当前正在等待某个外部事件）</p></li><li><p>挂起态 ：进入挂起态以后不能被调度器调用。</p></li></ul><p><img src="https://liloong.gitee.io/my_image/FreeRTOSimg/1.png"></p><p>一种是包含单挂起态的模型，一种是包含两个挂起态的模型。</p><p><img src="https://liloong.gitee.io/my_image/FreeRTOSimg/2.png"></p><p>包含两个挂起态的模型如图：</p><p><img src="https://liloong.gitee.io/my_image/FreeRTOSimg/3.png"></p>]]></content>
    
    
    <categories>
      
      <category>FreeRTOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>在树莓派上安装RPI.GPIO库(5)</title>
    <link href="/2020/12/28/raspberry/raspberryprog5/"/>
    <url>/2020/12/28/raspberry/raspberryprog5/</url>
    
    <content type="html"><![CDATA[<h2 id="一、RPI-GPIO安装"><a href="#一、RPI-GPIO安装" class="headerlink" title="一、RPI.GPIO安装"></a>一、RPI.GPIO安装</h2><pre><code>$ wget wget https://pypi.python.org/packages/source/R/RPi.GPIO/RPi.GPIO-0.7.0.tar.gz$ wget wget https://pypi.python.org/packages/source/R/RPi.GPIO/RPi.GPIO-0.4.1a.tar.gz$ tar zxf RPi.GPIO-0.7.0.tar.gz$ cd RPi.GPIO-0.7.0$ sudo python setup.py install</code></pre><h2 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h2><h3 id="安装编译环境"><a href="#安装编译环境" class="headerlink" title="安装编译环境"></a>安装编译环境</h3><pre><code>sudo apt -get install gcc</code></pre><h3 id="安装编译包"><a href="#安装编译包" class="headerlink" title="安装编译包"></a>安装编译包</h3><pre><code> sudo apt-get install build-essential</code></pre><h2 id="三、编写编译程序"><a href="#三、编写编译程序" class="headerlink" title="三、编写编译程序"></a>三、编写编译程序</h2><h2 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h2><p><a href="https://www.cnblogs.com/piaodoo/p/13942372.html">https://www.cnblogs.com/piaodoo/p/13942372.html</a></p>]]></content>
    
    
    <categories>
      
      <category>树莓派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RPI.GPIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在树莓派上编写C语言(4)</title>
    <link href="/2020/12/23/raspberry/raspberryprog4/"/>
    <url>/2020/12/23/raspberry/raspberryprog4/</url>
    
    <content type="html"><![CDATA[<h2 id="一、vim编辑器的安装及使用"><a href="#一、vim编辑器的安装及使用" class="headerlink" title="一、vim编辑器的安装及使用"></a>一、vim编辑器的安装及使用</h2><h2 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h2><h3 id="安装编译环境"><a href="#安装编译环境" class="headerlink" title="安装编译环境"></a>安装编译环境</h3><pre><code>sudo apt -get install gcc</code></pre><h3 id="安装编译包"><a href="#安装编译包" class="headerlink" title="安装编译包"></a>安装编译包</h3><pre><code> sudo apt-get install build-essential</code></pre><h2 id="三、编写编译程序"><a href="#三、编写编译程序" class="headerlink" title="三、编写编译程序"></a>三、编写编译程序</h2>]]></content>
    
    
    <categories>
      
      <category>树莓派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>用C语言编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于motion软件实现树莓派视频流(3)</title>
    <link href="/2020/12/22/raspberry/raspberryMotion3/"/>
    <url>/2020/12/22/raspberry/raspberryMotion3/</url>
    
    <content type="html"><![CDATA[<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>  使用树莓派自带的摄像头，将摄像头获取到的视频通过motion软件输出，达到客户端只需通过浏览器访问“树莓派网址：端口号”，就能看到视频图像。</p><h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><ul><li><p>树莓派4B及电源线（5V、3A）</p></li><li><p>树莓派系统 Raspbian</p></li><li><p>路由器</p></li><li><p>本实验使用的摄像头 </p><p><img src="https://liloong.gitee.io/my_image/img/1.png"></p></li><li><p>树莓派摄像头接法</p><p><img src="https://liloong.gitee.io/my_image/img/3.png"></p></li></ul><h2 id="树莓派系统配置"><a href="#树莓派系统配置" class="headerlink" title="树莓派系统配置"></a>树莓派系统配置</h2><h3 id="1-修改Raspberry的启动配置使能项"><a href="#1-修改Raspberry的启动配置使能项" class="headerlink" title="1)修改Raspberry的启动配置使能项"></a>1)修改Raspberry的启动配置使能项</h3><p>1.输入”ls /dev/“指令可查看当前树莓派系统是否加载对应的video device设备</p><pre><code>ls /dev/</code></pre><p><img src="https://liloong.gitee.io/my_image/img/4.png"></p><p>如果第一步没有看到对应的video device设备，则往下配置，否则跳过。</p><p>2.输入”sudo raspi-config”看到如下配置界面选择第五项 Interfacing Options</p><pre><code>sudo raspi-config</code></pre><p><img src="https://liloong.gitee.io/my_image/img/5.png"></p><p>3.选择PI Camera，进入下一个界面</p><p><img src="https://liloong.gitee.io/my_image/img/6.png"></p><p>4.系统会问你是否同意使能PI Camera，选择是就行。之后重启就行了。(重启指令 sudo reboot)</p><p><img src="https://liloong.gitee.io/my_image/img/7.png"></p><h3 id="3重启之后，查看摄像设备是否存在问题"><a href="#3重启之后，查看摄像设备是否存在问题" class="headerlink" title="3重启之后，查看摄像设备是否存在问题"></a>3重启之后，查看摄像设备是否存在问题</h3><p>输入检查设备指令：</p><pre><code>ls -al /dev/ | grep video</code></pre><p>如果摄像头没有问题的话可以看到如下信息 好得，找到了我们想要的看到的设备：video0 device</p><p><img src="https://liloong.gitee.io/my_image/img/8.png"></p><p><strong>注：可能提示这样的问题（如果在以上工作都完成的情况下，摄像头还是不能正常的使用或者驱动，请先检查硬件的连接的问题，可能是排线没有很好的插稳，或者是摄像头本身的问题。）：</strong></p><p>如果出现了如下问题，可以参考：<a href="http://blog.sina.com.cn/s/blog_e4008c660101hkd9.html">http://blog.sina.com.cn/s/blog_e4008c660101hkd9.html</a></p><p>mmal mmal_vc_component_create failed to create component ‘vc ril camera’ (1:ENOMEM)<br>mmal mmal_component_create_core could not create component ‘vc ril camera’ (1) mmal Failed to create camera component<br>mmal main Failed to create camera component<br>mmal Camera is not detected. Please check carefully the camera module is installed correctly</p><h3 id="4、截取摄像头图片"><a href="#4、截取摄像头图片" class="headerlink" title="4、截取摄像头图片"></a>4、截取摄像头图片</h3><p>1.我们使用rapistill指令来截图(当你在运行此指令的时候，树莓派上的指示灯会亮)：</p><pre><code>raspistill -o image.jpg</code></pre><p>2.输入如下指令可以之定义截取多大的图片</p><pre><code>raspistill -o image%d.jpg -rot 180 -w 1024 -h 768 -t 20000 -tl 5000 -v</code></pre><p>3。如果图片截取成功，则证明我们树莓派端摄像头成功启用</p><h2 id="使用motion来实现http的视频流传输"><a href="#使用motion来实现http的视频流传输" class="headerlink" title="使用motion来实现http的视频流传输"></a>使用motion来实现http的视频流传输</h2><p>注：此方法可直接在浏览器中查看到视频</p><h3 id="1）在树莓派系统上下载motion软件"><a href="#1）在树莓派系统上下载motion软件" class="headerlink" title="1）在树莓派系统上下载motion软件"></a>1）在树莓派系统上下载motion软件</h3><pre><code>sudo apt-get install motion</code></pre><h3 id="2）修改配置文件"><a href="#2）修改配置文件" class="headerlink" title="2）修改配置文件"></a>2）修改配置文件</h3><p>这里我用的nano编辑器，使用ctrl+o保存，然后按Enter确定，最后按ctrl+X退出就修改好了</p><pre><code>sudo nano /etc/motion/motion.conf</code></pre><p>注：每次修改配置文件时都要重启树莓派（重启命令：sudo reboot）</p><p>   将 #deamon off 改成 on</p><p>   将 stream_localhost on 改为stream_localhost off 关闭浏览器限制</p><p>   width 640                                # 图像的宽</p><p>   height 480                               # 图像的高</p><p>   target_dir ~/workspace/motion            # 图片保存的路径</p><p>   stream_localhost off                     # 允许通过网页查看摄像头</p><p>   stream_auth_method 2                     # 开启密码认证</p><p>   stream_authentication pi:raspberry       #网页查看摄像头的用户名和密码</p><p>   webcontrol_localhost off                 # 允许非本机访问控制页面</p><p>   locate_motion_mode on 把off改on          #定位并在移动物体周围画一个方框。</p><p>   framerate 100                            #最大帧数每秒捕捉</p><p>   stream_maxrate 200                       #最大帧率流</p><p>   webcontrol_port 8081</p><p>   stream_port 8080</p><p>   注意 webcontrol_port 和 stream_port不能是同一个端口</p><h3 id="3）可能出现的问题"><a href="#3）可能出现的问题" class="headerlink" title="3）可能出现的问题"></a>3）可能出现的问题</h3><p><img src="https://liloong.gitee.io/my_image/img/10.png"></p><p>这个问题就是将webcontrol_port 和 stream_port使用了同一端口 导致端口冲突，改成不一样的端口就解决了这个问题了。</p><h2 id="任务实现效果图"><a href="#任务实现效果图" class="headerlink" title="任务实现效果图"></a>任务实现效果图</h2><p>在任意浏览器中输入<strong>树莓派IP地址：8081</strong>，如果能查看到视频，说明你成功完成了本实验，如果未发现视频，则在我之前错误中看是否和你遇到同样的问题加以解决。</p><p><img src="https://liloong.gitee.io/my_image/img/11.png"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/uestc-mm/p/7587783.html" title="树莓派3 B+ 的摄像头简单使用（video-streamer）">https://www.cnblogs.com/uestc-mm/p/7587783.html</a></p><p><a href="https://blog.csdn.net/cqbamboo/article/details/100865747" title="树莓派上使用摄像头和motion实现远程监控">https://blog.csdn.net/cqbamboo/article/details/100865747</a></p>]]></content>
    
    
    <categories>
      
      <category>树莓派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>摄像头使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派视频流VLC软件(2)</title>
    <link href="/2020/12/20/raspberry/raspberryVlc2/"/>
    <url>/2020/12/20/raspberry/raspberryVlc2/</url>
    
    <content type="html"><![CDATA[<h2 id="一、买入树莓派摄像头"><a href="#一、买入树莓派摄像头" class="headerlink" title="一、买入树莓派摄像头"></a>一、买入树莓派摄像头</h2><p>我购买的是树莓派标配的摄像头（CSI接口摄像头）：</p><p><img src="https://liloong.gitee.io/my_image/img/1.png"> </p><p>关于CSI接口的描述参考：<a href="http://www.cnblogs.com/lifan3a/articles/5010633.html%EF%BC%89">http://www.cnblogs.com/lifan3a/articles/5010633.html）</a></p><p>树莓派摄像头接法</p><p><img src="https://liloong.gitee.io/my_image/img/3.png"></p><h2 id="二、树莓派系统设置"><a href="#二、树莓派系统设置" class="headerlink" title="二、树莓派系统设置"></a>二、树莓派系统设置</h2><h3 id="1、查看树莓派系统是否加载对应的vido-device设备"><a href="#1、查看树莓派系统是否加载对应的vido-device设备" class="headerlink" title="1、查看树莓派系统是否加载对应的vido device设备"></a>1、查看树莓派系统是否加载对应的vido device设备</h3><pre><code>ls /dev/</code></pre><p><img src="https://liloong.gitee.io/my_image/img/4.png"></p><h3 id="2、修改Raspberry的启动配置使能项"><a href="#2、修改Raspberry的启动配置使能项" class="headerlink" title="2、修改Raspberry的启动配置使能项"></a>2、修改Raspberry的启动配置使能项</h3><p>①、看到如下配置界面选择第五项 Interfacing Options</p><pre><code>sudo raspi-config</code></pre><p><img src="https://liloong.gitee.io/my_image/img/5.png"></p><p>②、选择PI Camera，进入下一个界面</p><p><img src="https://liloong.gitee.io/my_image/img/6.png"></p><p>③、系统会问你是否同意使能PI Camera，选择是就行。之后重启就行了。</p><p><img src="https://liloong.gitee.io/my_image/img/7.png"></p><h3 id="3、重启之后，查看摄像设备是否存在问题"><a href="#3、重启之后，查看摄像设备是否存在问题" class="headerlink" title="3、重启之后，查看摄像设备是否存在问题"></a>3、重启之后，查看摄像设备是否存在问题</h3><p>输入检查设备指令：</p><pre><code>ls -al /dev/ | grep video</code></pre><p>如果摄像头没有问题的话可以看到如下信息 好得，找到了我们想要的看到的设备：video0 device</p><p><img src="https://liloong.gitee.io/my_image/img/8.png"></p><p><strong>注：可能提示这样的问题（如果在以上工作都完成的情况下，摄像头还是不能正常的使用或者驱动，请先检查硬件的连接的问题，可能是排线没有很好的插稳，或者是摄像头本身的问题。）：</strong></p><p>如果出现了如下问题，可以参考：<a href="http://blog.sina.com.cn/s/blog_e4008c660101hkd9.html">http://blog.sina.com.cn/s/blog_e4008c660101hkd9.html</a></p><p>mmal mmal_vc_component_create failed to create component ‘vc ril camera’ (1:ENOMEM)<br>mmal mmal_component_create_core could not create component ‘vc ril camera’ (1) mmal Failed to create camera component<br>mmal main Failed to create camera component<br>mmal Camera is not detected. Please check carefully the camera module is installed correctly</p><h3 id="4、截取摄像头图片"><a href="#4、截取摄像头图片" class="headerlink" title="4、截取摄像头图片"></a>4、截取摄像头图片</h3><p>①、我们使用rapistill指令来截图(当你在运行此指令的时候，树莓派上的指示灯会亮)：</p><pre><code>raspistill -o image.jpg</code></pre><p>②、输入如下指令可以之定义截取多大的图片</p><pre><code>raspistill -o image%d.jpg -rot 180 -w 1024 -h 768 -t 20000 -tl 5000 -v</code></pre><p>③、如果图片截取成功，则证明我们树莓派端摄像头成功启用</p><h2 id="三、使用VLC等来实现http的视频流传输"><a href="#三、使用VLC等来实现http的视频流传输" class="headerlink" title="三、使用VLC等来实现http的视频流传输"></a>三、使用VLC等来实现http的视频流传输</h2><h3 id="1、首先需要在你的树莓派上面安装VLC的软件"><a href="#1、首先需要在你的树莓派上面安装VLC的软件" class="headerlink" title="1、首先需要在你的树莓派上面安装VLC的软件"></a>1、首先需要在你的树莓派上面安装VLC的软件</h3><p>依次如何一下三条指令，用以安装VLC软件</p><pre><code>sudo apt-get updatesudo apt-get install vlc --fix-missingsudo apt-get install vlc</code></pre><h3 id="2、启动树莓派摄像头"><a href="#2、启动树莓派摄像头" class="headerlink" title="2、启动树莓派摄像头"></a>2、启动树莓派摄像头</h3><p>dst=:8080 设置的是网络端口，可随意更改</p><pre><code>sudo raspivid -o - -rot 180 -t 0 -fps 30|cvlc -vvv stream:///dev/stdin --sout &#39;#standard&#123;access=http,mux=ts,dst=:8080&#125;&#39; :demux=h264  </code></pre><h3 id="3、在你的电脑上或者手机上安装VLC软件"><a href="#3、在你的电脑上或者手机上安装VLC软件" class="headerlink" title="3、在你的电脑上或者手机上安装VLC软件"></a>3、在你的电脑上或者手机上安装VLC软件</h3><p>打开你PC机电脑上的VLC软件，选择打开网络串流（Ctrl+N），输入上面指令的端口号以及对应的树莓派的IP地址（如下图所示我的树莓派的IP地址是192.168.1.105）</p><pre><code>http://192.168.1.105:8080</code></pre><p><img src="https://liloong.gitee.io/my_image/img/9.png"></p><h2 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a>四、参考文章</h2><p><a href="https://www.cnblogs.com/uestc-mm/p/7587783.html" title="树莓派3 B+ 的摄像头简单使用（video-streamer）">https://www.cnblogs.com/uestc-mm/p/7587783.html</a></p>]]></content>
    
    
    <categories>
      
      <category>树莓派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VLC视频流使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新入手一款树莓派4B之环境搭建（1）</title>
    <link href="/2020/12/19/raspberry/raspberry1/"/>
    <url>/2020/12/19/raspberry/raspberry1/</url>
    
    <content type="html"><![CDATA[<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>  在树莓派4B开发板上安装Raspbian系统</p><h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><ul><li><p>树莓派4B及电源线（5V、3A）</p></li><li><p>下载的树莓派系统 Raspbian</p></li><li><p>下载的官方安装软件包</p></li><li><p>micro SD卡一张（大于8G）</p></li><li><p>一个可用于SD电脑识别的器件</p></li><li><p>笔记本一台</p></li><li><p>显示器</p></li><li><p>显示器转接头（HDMI转小VGA转接头）</p></li></ul><h2 id="安装Raspbian系统"><a href="#安装Raspbian系统" class="headerlink" title="安装Raspbian系统"></a>安装Raspbian系统</h2><p>&emsp;官方推荐的是Raspbian，这是一款基于Debian Linux的树莓派专用系统，适用于树莓派所有的型号。</p><p>除此之外，树莓派还支持许多操作系统：</p><p>&emsp;Ubuntu，Ubuntu是基于Debian Linux 的桌面操作系统，树莓派分别支持Ubuntu META和Snappy Ubuntu Core两个版本，前者是桌面版，后者是面向开发者的桌面版。</p><p>OSMC，即开源媒体中心，是基于Linux内核的专门用于单板机的开源媒体播放器操作系统。</p><p>Windows 10 IoT Core，微软专为物联网开发打造的系统，Windows用户把玩树莓派的福音。</p><p>LibreELEC，轻量级Linux发行版，为嵌入式设备构建多媒体服务平台而设计。</p><p>本文选用官方推荐的Raspbian。</p><p>&emsp;树莓派的操作系统有两种安装方式：一种先把树莓派的安装引导程序NOOBS写入SD卡，然后启动树莓派进入NOOBS来安装操作系统。另一种是将操作系统镜像写入SD卡，树莓派启动后直接进入操作系统。</p><p>初学者建议使用NOOBS方式来安装，大家也可以根据自己的偏好来选择，下面对这两种方式都进行介绍。</p><h3 id="第一种方法：将NOOBS写入SD卡"><a href="#第一种方法：将NOOBS写入SD卡" class="headerlink" title="第一种方法：将NOOBS写入SD卡"></a>第一种方法：将NOOBS写入SD卡</h3><p>NOOBS的界面非常友好，你只要看一眼就立刻知道怎么使用它。除了安装Raspbian外，还可以安装LibreELEC等其他树莓派所支持的系统。</p><p><img src="https://liloong.gitee.io/my_image/img/13.png"></p><ul><li>首先，下载NOOBS，树莓派的官方网站<a href="https://www.raspberrypi.org/">https://www.raspberrypi.org</a>提供NOOBS下载，在官网首页顶部点击Downloads，打开下载栏目：</li></ul><p><img src="https://liloong.gitee.io/my_image/img/14.png"></p><ul><li>点击左边的NOOBS进入NOOBS的下载页面：</li></ul><p><img src="https://liloong.gitee.io/my_image/img/15.png"></p><ul><li><p>下载完成后你将得到一个类似NOOBS_vx_x_x.zip的文件，其中x_x_x为版本号。</p></li><li><p>格式化mini SD卡为FAT格式</p></li></ul><p>我是用的是格式话SD软件是 D Association’s Formatting Tool。下载地址：<a href="https://www.sdcard.org/downloads/formatter/">https://www.sdcard.org/downloads/formatter/</a></p><p><img src="https://liloong.gitee.io/my_image/img/16.png"></p><ul><li>最后一步，把NOOBS拷贝到SD卡</li><li>解压缩NOOBS_vx_x_x.zip文件，打开解压缩后的文件夹，你会看到所有NOOBS的文件，然后全部选中，直接拷贝到SD卡的根目录中。</li></ul><p>注意：解压缩后你首先会得到一个NOOBS的文件夹，要把这个文件夹里面的内容直接拷贝到SD卡，而不是将这个文件夹拷贝过去。</p><h3 id="第二种方法：官网安装"><a href="#第二种方法：官网安装" class="headerlink" title="第二种方法：官网安装"></a>第二种方法：官网安装</h3><ul><li>因为树莓派的服务器在国外，因此采用官方镜像烧录的化会非常慢，建议使用第一种或第三种方法。</li></ul><p><a href="https://www.raspberrypi.org/software/](https://www.raspberrypi.org/software/](https://www.raspberrypi.org/software/" title="树莓派官网">https://www.raspberrypi.org/software/</a></p><ul><li>将网页往下翻，找到图中所示地方，根据当前使用系统类型下载不同官方安装软件</li></ul><p><img src="https://liloong.gitee.io/my_image/img/12.png"></p><ul><li>软件安装好之后，按照下面截图步骤，就可以开始烧录系统了。</li></ul><p><img src="https://liloong.gitee.io/my_image/img/17.png"></p><h3 id="第二种方法：本地镜像安装"><a href="#第二种方法：本地镜像安装" class="headerlink" title="第二种方法：本地镜像安装"></a>第二种方法：本地镜像安装</h3><ul><li><p>下载官方本地镜像，你也可以找清华镜像源，稍微快点。<br><a href="https://www.raspberrypi.org/software/operating-systems/">https://www.raspberrypi.org/software/operating-systems/</a></p></li><li><p>下载balenaEtcher软件，软件安装地址：<a href="https://www.balena.io/etcher/">https://www.balena.io/etcher/</a></p></li><li><p>首先格式化mini SD卡为FAT格式（同第一种方法）</p></li><li><p>然后按照图片步骤烧录即可</p></li></ul><p><img src="https://liloong.gitee.io/my_image/img/18.png"></p><h2 id="实验成功与否"><a href="#实验成功与否" class="headerlink" title="实验成功与否"></a>实验成功与否</h2><p>如果插入显示器，过了一会会显示树莓派桌面，则说明树莓派烧录系统实验成功了，如果没有可检查线连接是否接触不良，或者是显示器烧毁了，或者是系统中途烧录时断电了，导致系统无法成功启动，没有的话，建议浏览器一波。</p>]]></content>
    
    
    <categories>
      
      <category>树莓派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>烧录Raspbian系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HackerNews 案例实战总结</title>
    <link href="/2020/08/31/Web/HackerNews%20%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98/"/>
    <url>/2020/08/31/Web/HackerNews%20%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h3 id="HackerNews首先考虑的问题"><a href="#HackerNews首先考虑的问题" class="headerlink" title="HackerNews首先考虑的问题"></a>HackerNews首先考虑的问题</h3><p>第一点 设计路由 包含两个方面</p><p>  1、请求的方法</p><p>  2、请求的路径</p><h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><p>  在运行过程中发现每次提交一个新闻都会将前面一条新闻给覆盖掉</p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p> 我们可以考虑先将.json里面的数据读取出来放到list数组上，然后再将用户提交的数据也push到list数组中，之后一并提交到 .json 文件中，这样就可以解决这个问题</p><p>  get方式提交数据</p><p>代码展示：</p><pre><code>    //在运行过程中发现每次提交一个新闻都会将前面一条新闻给覆盖掉，为了解决这个问题，我们可以考虑先将.json里面的数据读取出来放到list    //数组上，然后再将用户提交的数据也push到list数组中，之后一并提交到 .json 文件中，这样就可以解决这个问题    //1.1 读取 data.json 文件中的数据，并将读取到的数据转换为一个数组           //此处，读取文件的时候可以直接写一个utf8 编码，这样的话，回调函数的data就是一个字符串了        fs.readFile(path.join(__dirname,&#39;data&#39;,&#39;data.json&#39;),&#39;utf8&#39;,function(err,data)&#123;            //因为第一次访问网站的，data.json本身就不存在，所以肯定是有错误的            //但这种错误我们并不认为是网站出错，所以不需要抛出异常            if(err &amp;&amp; err.code != ENOENT)&#123;                throw err;            &#125;            //如果读取到了数据，就将读取到的数据 data 转黄为list数组            //如果没有读取到数组，就把 &#39;[]&#39;转换为数组            var list = JSON.parse(data || &#39;[]&#39;);            list.push(urlObj.query);            fs.writeFile(path.join(__dirname,&#39;data&#39;,&#39;data.json&#39;),JSON.stringify(list),function(err)&#123;                if(err)&#123;                  throw err;                &#125;else&#123;                                //3、跳转到新闻列表页 (记住：服务器端想让浏览器做什么，就是向浏览器发送对应的响应报文头，浏览器就知道该做些什么了)                  // 步骤：设置响应报文头，通过响应把文头，执行一次页面跳转操作                      //一般俗称重定向                     res.statusCode = 302;                     res.statusMessage = &#39;Found&#39;;                     res.setHeader(&#39;Location&#39;,&#39;/&#39;);                         //每一次的请求都要结束响应                     res.end();                &#125;            &#125;)        &#125;);</code></pre><h3 id="post方式提交数据"><a href="#post方式提交数据" class="headerlink" title="post方式提交数据"></a>post方式提交数据</h3><p>步骤：<br>  1、因为第一次访问网站的，data.json本身就不存在，所以肯定是有错误的，但这种错误我们并不认为是网站出错，所以不需要抛出异常</p><p>  2、监听用户提交的请求里面的数据，如果数据大就分多次放到一个新建的数组中去（采用on在node.js 中是监听请求事件的一个方法）</p><p>  3、监听 request 对象的 end 事件，当 end 事件被触发的时候，表示用户通过浏览器需要提交到服务器的数据都已经提交完毕</p><p>  4、将array中的数据汇总起来（方法：通过 Buffer 对象中的一个 concat 方法就可以将array中的数据汇总起来）</p><p>  5、将查询字符串转换成JSON对象（方法：调用外部模块querystring 可以比较方便的将数据转换为 JSON 对象）</p><p>  6、获取到JSON对象后同get方式一样放入list数组中去</p><p>  7、跳转到新闻列表页 (记住：服务器端想让浏览器做什么，就是向浏览器发送对应的响应报文头，浏览器就知道该做些什么了)</p><p>代码步骤展示：</p><pre><code> else if (req.url.startsWith(&#39;/add&#39;) &amp;&amp; req.method === &#39;post&#39;) &#123;       // post 方法提交数据能够将一个很大的数据分块提交，这在一般网站上用的比较多      fs.readFile(path.join(__dirname,&#39;data&#39;,&#39;data.json&#39;),&#39;utf8&#39;,function(err,data)&#123;        //1、因为第一次访问网站的，data.json本身就不存在，所以肯定是有错误的        //但这种错误我们并不认为是网站出错，所以不需要抛出异常        if(err &amp;&amp; err.code != ENOENT)&#123;            throw err;        &#125;        var list = JSON.parse(data || &#39;[]&#39;);        //新建一个数组用于存放post提交的一块一块的数据        var array = [];             //2、监听用户提交的请求里面的数据，如果数据大就分多次放到一个新建的数组中去        // on 在 node.js 中是监听请求事件的一个方法        req.on(&#39;data&#39;,function(chunk)&#123;             //此处的 chunk 参数，就是浏览器本次提交过来的一部分数据，              //chunk的数据类型为buffer(chunk就是一个Buffer对象)            array.push(chunk);        &#125;);        //3、监听 request 对象的 end 事件，当 end 事件被触发的时候，表示用户通过浏览器需要提交到服务器的数据都已经提交完毕                //当用户提交完全部数据时，然后我们只需将一个一个模块的数据结合起来就好了        req.on(&#39;end&#39;,function()&#123;                      //4、将array中的数据汇总起来            //方法：通过 Buffer 对象中的一个 concat 方法就可以将array中的数据汇总起来            var postBody = Buffer.concat(array);            // postBody 获取到的数据还是一个一个16进制，我们还需将其转换为字符串            postBody = postBody.toString(&#39;utf8&#39;); //这个方法转换出来的是查询字符串                        //5、将查询字符串转换成JSON对象            postBody = querystring.parse(postBody);                        //6、获取到JSON对象后同get方式一样放入list数组中去            list.push(postBody);            fs.writeFile(path.join(__dirname,&#39;data&#39;,&#39;data.json&#39;),JSON.stringify(list),function(err)&#123;                if(err)&#123;                  throw err;                &#125;else&#123;                                //7、跳转到新闻列表页 (记住：服务器端想让浏览器做什么，就是向浏览器发送对应的响应报文头，浏览器就知道该做些什么了)                  // 步骤：设置响应报文头，通过响应把文头，执行一次页面跳转操作                      //一般俗称重定向                     res.statusCode = 302;                     res.statusMessage = &#39;Found&#39;;                     res.setHeader(&#39;Location&#39;,&#39;/&#39;);                         //每一次的请求都要结束响应                     res.end();                &#125;            &#125;)        &#125;);    &#125;);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nodejs基础性知识点总结</title>
    <link href="/2020/08/11/Web/Node%E7%9F%A5%E8%AF%86%E7%90%86%E8%A7%A3/"/>
    <url>/2020/08/11/Web/Node%E7%9F%A5%E8%AF%86%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="Node-js是什么"><a href="#Node-js是什么" class="headerlink" title="Node.js是什么"></a>Node.js是什么</h3><p>1、node.js 平台是基于 Chrom V8 javsaScript 引擎构建的。</p><p>2、基于 node.js 可以开发控制台程序（命令行程序、CLI程序）、桌面应用程序（GUI）（需要借助 node - webkit、electron等框架实现）、web应用程序（网站）</p><h3 id="node-js有哪些特点"><a href="#node-js有哪些特点" class="headerlink" title="node.js有哪些特点"></a>node.js有哪些特点</h3><p>1、事件驱动（当事件被触发时，执行传递过去的回调函数）</p><p>2、非阻塞I/O模型（当执行I/O操作时，不会阻塞线程）</p><p>3、单线程（javascript也是单线程语言）</p><p>4、拥有世界最大的开源生态系统 – npm （一个非常丰富的开源生态库）</p><h3 id="node-js网站"><a href="#node-js网站" class="headerlink" title="node.js网站"></a>node.js网站</h3><p>1、官方网站<a href="https://nodejs.org/">https://nodejs.org/</a></p><p>2、中文网<a href="http://nodejs.cn/">http://nodejs.cn/</a></p><p>3、中文社区<a href="https://cnodejs.org/">https://cnodejs.org/</a></p><h3 id="Node-js安装与配置"><a href="#Node-js安装与配置" class="headerlink" title="Node.js安装与配置"></a>Node.js安装与配置</h3><p>1、安装完毕后通过在CMD输入node -v检查是否安装成功，如果输入命令出现版本号的话就说明安装成功了。如果没有出现版本号，就说明安装不成功，那么需要配置环境变量（参考网上环境配置方法），配置完成后重新输入那个命令，直到出现版本号，那么这样的话就算时安装成功了。</p><p>2、通过 nvm - windows 管理一台计算机上的多个 node 版本</p><h3 id="Node-js多个版本管理器"><a href="#Node-js多个版本管理器" class="headerlink" title="Node.js多个版本管理器"></a>Node.js多个版本管理器</h3><p>nvm -window(window上安装)</p><p> 1、<a href="https://github.com/coreybutler/nvm-windows">https://github.com/coreybutler/nvm-windows</a></p><p>   常用命令：</p><pre><code> nvm version 意思是当前版本 nvm install latest 安装最新版本 nvm install 版本号 意思是指定版本号安装 nvm uninstall 版本号 ，意思是卸载哪个版本的 nvm list 列出所有node.js版本 nvm use 版本号， 意思是: 切换版本</code></pre><h3 id="Node-js开发web应用程序和PHP、Java、ASP-Net等传统模式开发Web应用程序的区别"><a href="#Node-js开发web应用程序和PHP、Java、ASP-Net等传统模式开发Web应用程序的区别" class="headerlink" title="Node.js开发web应用程序和PHP、Java、ASP.Net等传统模式开发Web应用程序的区别"></a>Node.js开发web应用程序和PHP、Java、ASP.Net等传统模式开发Web应用程序的区别</h3><p>1、传统模式</p><p>   有Web容器</p><p>   必需有Web容器开发模型</p><p>2、node.js开发web应用程序 （可以自己创建一个服务器，或者说本     身就是一个服务器）</p><p>   没有 web 容器</p><p>   node.js没有Web容器开发模型</p><h3 id="node-js程序编写注意事项"><a href="#node-js程序编写注意事项" class="headerlink" title="node.js程序编写注意事项"></a>node.js程序编写注意事项</h3><p>1、不要用中文</p><p>2、不要包含空格</p><p>3、不要出现node关键字</p><p>4、建议以’-‘分割单词</p><h3 id="JS知识补充"><a href="#JS知识补充" class="headerlink" title="JS知识补充"></a>JS知识补充</h3><p>js为什么是单线程的和异步非阻塞的呢？</p><p>解释： 同步就是阻塞的意思。</p><h3 id="文件读写（可以同查阅官方文档去掌握）"><a href="#文件读写（可以同查阅官方文档去掌握）" class="headerlink" title="文件读写（可以同查阅官方文档去掌握）"></a>文件读写（可以同查阅官方文档去掌握）</h3><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>  使用到的模块 var fs = require(‘fs’);</p><p>1、写文件：’fs.writeFile(file,data[,options],callback);’</p><p>   参数1：要写入文件的路径，<strong>必填</strong></p><p>   参数2：要写入的数据，<strong>必填</strong></p><p>   参数3：写入文件时的选项，比如文件编码，<strong>选填</strong>、</p><p>   参数4：文件写入完毕后的回调函数，<strong>必填</strong></p><p>   写文件注意：</p><pre><code>*该操作采用异步执行*如果文件已经存在则替换掉*默认写入文件编码为utf8*回调函数有一个参数：err,表示再写入文件的操作过程中是否出错。-如果出错了 &#39;err  != null &#39; ,否则 &#39;err === null&#39;</code></pre><p> 注意：<br>   process 在使用的时候无需通过 require()函数来加载该模块，可以直接使用</p><p>   fs模块，在使用的时候，必须通过require()函数来加载该模块，方可使用 var fs = require(‘fs’)</p><p> 原因：process模块是全局的模块，而fs不是全局模块，全局模块可以直接使用，而非全局模块需要先通过require()加载该模块</p><p> 写入文件代码示例：</p><pre><code> var fs = require(&#39;fs&#39;);var msg = &#39;hello word ，世界&#39;;fs.writeFile(&#39;./hello.txt&#39;,msg,&#39;utf8&#39;,function(err)&#123;    /**     * 如果 err === null ,表示写入文件成功，没有错误     * 如果 err !=nll,表示写入文件失败，     */    if(err)&#123;       console.log(&#39;写入的文件错误&#39;+err);    &#125;else&#123;        console.log(&#39;写入文件成功&#39;);    &#125;&#125;)</code></pre><p> <img src="https://s1.ax1x.com/2020/08/27/dhCNQ0.png"></p><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>2、读文件：’fs.readFile(file[,options],callback)’</p><p>   参数1：要读取文件的路径，<strong>必填</strong></p><p>   参数2：读取文件时的选项，比如文件编码，<strong>选填</strong>、</p><p>   参数3、文件读取完毕后的回调函数，<strong>必填</strong></p><p>   写文件注意：</p><pre><code>*该操作采用异步执行*回调函数有两个参数，分别是err和data</code></pre><p> 实现步骤： </p><pre><code>1、加载 fs 模块2、调用 fs.readFlile() 方法来读取文件   fs.readFile(file[,options],callback)读取的是 buffer 类型字节数组3、将buffer对象转换为字符串，调用toString方法 (不传参数的话默认是utf8编码，建议写上)</code></pre><p> 代码写法：<br>   一、不传递utf8编码</p><pre><code>// 1、加载fs模块var fs = require(&#39;fs&#39;);//2、调用 fs.readFile() 方法来读取文件fs.readFile(&#39;./hello.txt&#39;, function (err, data) &#123;    if (err) &#123;        throw err;    &#125;    //data 参数的数据类型是一个Buffer对象，里面保存的是一个一个字节（可以理解为字节数组）    console.log(data);    //3、将buffer对象转换为字符串，调用toString方法 (不传参数的话默认是utf8编码，建议写上)            console.log(data.toString(&#39;utf8&#39;));&#125;)</code></pre><p>   <img src="https://s1.ax1x.com/2020/08/30/dbiWyF.png"></p><p>   一、传递utf8编码</p><pre><code>   // 1、加载fs模块var fs = require(&#39;fs&#39;);//2、调用 fs.readFile() 方法来读取文件//在读取文件的时候，如果传递了编码,那么回调函数中的 data 会默认转换为字符串fs.readFile(&#39;./hello.txt&#39;, &#39;utf8&#39;, function (err, data) &#123;    if (err) &#123;        throw err;    &#125;    //data 参数的数据类型是一个Buffer对象，里面保存的是一个一个字节（可以理解为字节数组）    console.log(data);    //3、将buffer对象转换为字符串，调用toString方法 (不传参数的话默认是utf8编码，建议写上)&#125;)</code></pre><p>  <img src="https://s1.ax1x.com/2020/08/30/dbiNz8.png"></p><p> 读取文件中的注意事项：</p><p>   “./“这是一个相对路径，相对的是执行命令的路径，而不是相对于正在执行的这个JS文件来查找 hello.txt.</p><p>   解决上述问题方法：__dirname 、 __filename （这两个并不是全局的）</p><pre><code> __dirname:表示，当前真在执行的js文件所在的目录 __filename:表示，当前正在执行的js文件的完整路径</code></pre><p>   代码示例：</p><pre><code> // 1、加载fs模块var fs = require(&#39;fs&#39;);var dirname = __dirname + &#39;\\&#39; + &#39;hello.txt&#39;;//2、调用 fs.readFile() 方法来读取文件//在读取文件的时候，如果传递了编码,那么回调函数中的 data 会默认转换为字符串fs.readFile(dirname, &#39;utf8&#39;, function (err, data) &#123;    if (err) &#123;        throw err;    &#125;    //data 参数的数据类型是一个Buffer对象，里面保存的是一个一个字节（可以理解为字节数组）    console.log(data);    //3、将buffer对象转换为字符串，调用toString方法 (不传参数的话默认是utf8编码，建议写上)&#125;)</code></pre><h3 id="通过path进行路径拼接"><a href="#通过path进行路径拼接" class="headerlink" title="通过path进行路径拼接"></a>通过path进行路径拼接</h3><p> 一、需要用到的语句<br>    var path = require(‘path’);</p><pre><code>var dirname = path.join(__dirname,&#39;hello.txt&#39;);</code></pre><p> 二、代码示例：</p><pre><code>// 1、加载fs模块var fs = require(&#39;fs&#39;);//加载path模块var path = require(&#39;path&#39;);// var dirname = __dirname + &#39;\\&#39; + &#39;hello.txt&#39;;var dirname = path.join(__dirname,&#39;hello.txt&#39;);//2、调用 fs.readFile() 方法来读取文件//在读取文件的时候，如果传递了编码,那么回调函数中的 data 会默认转换为字符串fs.readFile(dirname, &#39;utf8&#39;, function (err, data) &#123;    if (err) &#123;        throw err;    &#125;    //data 参数的数据类型是一个Buffer对象，里面保存的是一个一个字节（可以理解为字节数组）    console.log(data);    //3、将buffer对象转换为字符串，调用toString方法 (不传参数的话默认是utf8编码，建议写上)&#125;)</code></pre><h3 id="如何创建文件夹"><a href="#如何创建文件夹" class="headerlink" title="如何创建文件夹"></a>如何创建文件夹</h3><pre><code>var fs = require(&#39;fs&#39;);fs.mkdir(&#39;./test-mkdir/test&#39; , function(err)&#123;    if(err)&#123;        console.log(err);    &#125;else&#123;        console.log(&#39;创建成功&#39;);    &#125;&#125;)</code></pre><h3 id="之前知识点总结及注意事项"><a href="#之前知识点总结及注意事项" class="headerlink" title="之前知识点总结及注意事项"></a>之前知识点总结及注意事项</h3><p> 1、异步操作无法通过 try - catch 来捕获异常，要通过判断error 来判断是否出错</p><p> 2、同步操作可以通过 try - catch 来捕获异常</p><p> 3、不要使用 fs.exists(path,callback) 来判断文件是否存在，直接判断error即可</p><p> 4、文件操作时的路径问题</p><p>   在读写文件的时候 ‘./‘ 表示的是当前执行 node 命令的哪个路径，不是被执行的js文件的路径</p><p>   __dirname 表示永远是“当前被执行的js目录”</p><p>   __firename 表示的是“被执行的js文件名（含路径”</p><p> 5、error - first 介绍（错误优先）</p><h2 id="通过-node-js-编写-http-服务程序-极简版本"><a href="#通过-node-js-编写-http-服务程序-极简版本" class="headerlink" title="通过 node.js 编写 http 服务程序 - 极简版本"></a>通过 node.js 编写 http 服务程序 - 极简版本</h2><p> 步骤：</p><p>  1、加载http模块</p><p>  2、创建http服务</p><p>  3、为http服务添加 request 事件处理程序</p><p>  4、启动http服务监听，准备接收客户端请求</p><p> 代码示例：</p><pre><code>//1、加载http模块 var http = require(&#39;http&#39;); //2、创建一个tttp服务对象 var server = http.createServer(); //3、监听用户的请求事件（request 事件） // request 包含了用户请求报文中的所有内容，通过request 对象可以获得所有用户提交过来的所有数据 // reponse 对象用来向用户响应一些数据，当服务器要向客户端响应数据的时候必须使用response对象  //有了request 对象和 response 对象，就可以获取用户提交的数据，也可以向用户响应数据 server.on(&#39;request&#39; , function(req,res)&#123;     res.write(&quot;hello word&quot;);   //对于每一个请求，服务器必须结束响应，否则客户端（浏览器）会一直等待服务器响应结束     res.end(); &#125;) server.listen(8080,function()&#123;   console.log(&#39;服务器启动成功，请访问:http://localhost:8080&#39;); &#125;);</code></pre><p> 通过设置http响应报文头来解决浏览器显示html的问题（能够以html的形式展示）</p><p>  加一条语句： res.setHeader(‘Content-Type’,’text/html; charset=utf-8’);</p><p>  <strong>代码示例</strong>：</p><pre><code> //1、加载http模块 var http = require(&#39;http&#39;); //2、创建一个tttp服务对象 var server = http.createServer(); //3、监听用户的请求事件（request 事件） // request 包含了用户请求报文中的所有内容，通过request 对象可以获得所有用户提交过来的所有数据 // reponse 对象用来向用户响应一些数据，当服务器要向客户端响应数据的时候必须使用response对象  //有了request 对象和 response 对象，就可以获取用户提交的数据，也可以向用户响应数据 server.on(&#39;request&#39; , function(req,res)&#123;    //只要和响应有关的就用response    //解决乱码的思路：服务器通过设置http响应报文头，告诉浏览器使用相应的编码来解析网页           res.setHeader(&#39;Content-Type&#39;,&#39;text/html; charset=utf-8&#39;);     res.write(&quot;hello word &lt;h1&gt; 你好 世界 &lt;\h1&gt;&quot;);   //对于每一个请求，服务器必须结束响应，否则客户端（浏览器）会一直等待服务器响应结束     res.end(); &#125;) server.listen(8080,function()&#123;   console.log(&#39;服务器启动成功，请访问:http://localhost:8080&#39;); &#125;);      </code></pre><p> 注意：</p><p>  1、<strong>浏览器显示的可能是乱码</strong>，所以可以通过 res.setHeader(‘Content - Type’,’text/plain;charset = utf-8’); 设置浏览器显示时所使用的编码。</p><pre><code>**解决乱码的思路：服务器通过设置http响应报文头，告诉浏览器使用相应的编码来解析网页**</code></pre><p>  2、Chrome 浏览器默认无法手动设置编码，需要安装”Set character Encoding”扩展</p><p>  3、Content - Type = text/html 和 Content - Type = text/plain 的区别。</p><h3 id="根据用户的不同请求，服务器做出不同响应"><a href="#根据用户的不同请求，服务器做出不同响应" class="headerlink" title="根据用户的不同请求，服务器做出不同响应"></a>根据用户的不同请求，服务器做出不同响应</h3><p>  代码思路：  </p><pre><code>//1、加载http模块var http = require(&#39;http&#39;);//2、创建HTTP服务http.createServer(function (req, res) &#123;    //  console.log(req.url);    //  //结束响应    //  res.end();    res.setHeader(&#39;Content-Type&#39;, &#39;text/plain;charset=utf-8&#39;);    //通过req.ulr获取用户请求的路径，根据不同的请求路径服务器做出不同的响应    if(req.url === &#39;/&#39; || req.url === &#39;/index&#39;)&#123;        res.end(&#39;hello index&#39;);    &#125;else if(req.url === &#39;/login&#39;)&#123;        res.end(&#39;hello login&#39;);    &#125;else if(req.url === &#39;/list&#39;)&#123;        res.end(&#39;hello list&#39;);    &#125;else if(req.url === &#39;/register&#39;)&#123;        res.end(&#39;hello register&#39;);    &#125;else&#123;        res.end(&#39;404,not Found.客户端错误&#39;)    &#125;&#125;).listen(8080, function () &#123;    console.log(&#39;服务器启动成功，请访问:http://localhost:8080&#39;);&#125;)</code></pre><h3 id="根据用户不同请求，加载不同的文件"><a href="#根据用户不同请求，加载不同的文件" class="headerlink" title="根据用户不同请求，加载不同的文件"></a>根据用户不同请求，加载不同的文件</h3><pre><code>var http = require(&#39;http&#39;);var fs = require(&#39;fs&#39;);var path = require(&#39;path&#39;);http.createServer(function (req, res) &#123;        var urling;    //通过req.ulr获取用户请求的路径，根据不同的请求路径服务器做出不同的响应    if(req.url === &#39;/&#39; || req.url === &#39;/index&#39;)&#123;        //读取 index.html文件    //    fs.readFile(path.join(__dirname,&#39;htmls&#39;,&#39;index.html&#39;),function(err,data)&#123;    //        if(err)&#123;    //            throw err;    //        &#125;else&#123;    //          res.end(data);      //        &#125;    //    &#125;)      urling = &#39;index.html&#39;;    &#125;else if(req.url === &#39;/login&#39;)&#123;        // fs.readFile(path.join(__dirname,&#39;htmls&#39;,&#39;login.html&#39;),function(err,data)&#123;        //   if(err)&#123;        //       throw err;        //   &#125;else&#123;        //       res.end(data);        //   &#125;        // &#125;)        urling = &#39;login.html&#39;;    &#125;else if(req.url === &#39;/list&#39;)&#123;        urling = &#39;list.html&#39;;    &#125;else if(req.url === &#39;/reglist&#39;)&#123;        urling = &#39;reglist.html&#39;;    &#125;else&#123;        urling = &#39;404.html&#39;;    &#125;    fs.readFile(path.join(__dirname,&#39;htmls&#39;, urling),function(err,data)&#123;        if(err)&#123;            throw err;        &#125;else&#123;            res.end(data);        &#125;     &#125;)&#125;).listen(8080, function () &#123;    console.log(&#39;http://localhost:8080&#39;);&#125;)</code></pre><p>  <strong>文件操作时，无需判断文件是否存在，直接操作即可，如果文件不存在会反应在 error 中</strong></p><h3 id="try-cath的使用"><a href="#try-cath的使用" class="headerlink" title="try-cath的使用"></a>try-cath的使用</h3><p>作用：捕获异常</p><p>结论：只能捕获同步操作异常，不能捕获异步操作异常</p><p>  对于异步操作，只能通过判断错误号（err.code）来进行出错处理</p><h3 id="模拟Apache服务器"><a href="#模拟Apache服务器" class="headerlink" title="模拟Apache服务器"></a>模拟Apache服务器</h3><p>  模拟Apache服务器的 5 个步骤：</p><p>   1、获取用户请求路径</p><p>   2、获取 public 目录的完整路径</p><p>   3、根据public的路径和用户请求的路径，最终计算出用户请求的静态资源的完整路径</p><p>   4、根据文件的完整路径去读取该文件，则把文件返回给用户，如果找不到，则返回404</p><p>   5、通过第三方模块 mime = require(‘mime’) ;，来判断不同资源 Content-Type 的类型</p><p> 具体示例代码如下：</p><pre><code>//加载服务器模块var http = require(&#39;http&#39;);//加载文件路径模块var path = require(&#39;path&#39;);//加载文件模块var fs = require(&#39;fs&#39;);//加载外部模块mime 来判读读取文件的后缀名是什么的var mime = require(&#39;mime&#39;);//创建服务器http.createServer(function (req, res) &#123;    //1、获取用户请求路径    //req.url    // /css/index.css    // /images/index.png    //2、获取 public 目录的完整路径    var publicdir = path.join(__dirname, &#39;public&#39;);        //3、根据public的路径和用户请求的路径，最终计算出用户请求的静态资源的完整路径    var filename = path.join(publicdir, req.url);    // console.log(filename);       //4、根据文件的完整路径去读取该文件，则把文件返回给用户，如果找不到，则返回404    fs.readFile(filename, function (err, data) &#123;        if (err) &#123;            res.end(&#39;不存在此页面&#39;);        &#125; else &#123;            //通过第三方模块，来判断不同资源 Content-Type 的类型            res.setHeader(&#39;Content-Type&#39;,mime.getType(filename));                        //如果找到了要读取的文件则直接将文件返回给用户            res.end(data);        &#125;    &#125;)&#125;).listen(8080, function () &#123;    console.log(&#39;http://localhost:8080&#39;);&#125;)</code></pre><p>   <strong>在请求服务器的时候，请求的 url 就是一个标识，找到标识主要的是服务器返回的是什么文件</strong></p><h2 id="request（文档对应的位置-http-IncomingMessage-）-和-response-（文档中对应的位置-http-ServerResponse）对象介绍"><a href="#request（文档对应的位置-http-IncomingMessage-）-和-response-（文档中对应的位置-http-ServerResponse）对象介绍" class="headerlink" title="request（文档对应的位置 http.IncomingMessage ） 和 response （文档中对应的位置 http.ServerResponse）对象介绍"></a>request（文档对应的位置 http.IncomingMessage ） 和 response （文档中对应的位置 http.ServerResponse）对象介绍</h2><p>  request ：服务器解析用户提交的 http 请求报文 ，将结果解析到 request 对象中，凡是获取和用户请求相关的数据都可以通过 request 对象来进行。</p><p>  response：在服务器端用来向用户做出向应的对象。凡是需要向用户（客户端）响应的操作，都需要通过 response 对象来进行</p><h3 id="resquest对象"><a href="#resquest对象" class="headerlink" title="resquest对象"></a>resquest对象</h3><p> resquest 对象类型 &lt;http.IncomingMessage&gt; ,继承自 stream.Readable</p><p> resquest对象 常用成员</p><p>   1、resquest.headers (请求报文头)</p><pre><code> resquest.headers 返回的是一个对象，这个对象中包含了所有的请求报文头</code></pre><p>   2、resquest.rawHeaders (原生的请求报文头)</p><pre><code> resquest.rawHeaders 返回的是一个数组，数组中保存的都是请求报文的字符串</code></pre><p>   3、resquest.httpVersion （获取客户端请求的http版本号）</p><pre><code> resquest.httpVersion 获取请求客户端所使用的http版本号</code></pre><p>   4、resquest.method （获取的是请求方法）</p><pre><code> resquest.method 获取客户端请求使用的方法（POST、GET、、、）</code></pre><p>   5、resquest.url （获取的是请求的文件路径）</p><pre><code> resquest.url 获取本次请求的路径</code></pre><h3 id="response对象介绍"><a href="#response对象介绍" class="headerlink" title="response对象介绍"></a>response对象介绍</h3><p>重点说明 response.writeHead() 的使用</p><p>1、一般在设置响应报文头都是用res.setHeader()去设置，当我们设置了响应报文头时，一定要在res.write() 和 res.end() 前设置，因为我们不设置响应报文头，系统也会有默认的响应报文头，并且默认发送给浏览器，当已经发送给浏览器响应报文头时就不能再给浏览器发送响应报文头了，所以得提前发送，才不会报错。</p><p>2、和res.setHeader() 配合一起使用的还有 ，res.statusCode() //设置 http 响应状态码 ，res.statusMessage() //设置http响应状态码对应的信息</p><p>3、这时我们就需要设置三条语句，node.js也为我们提供了一个 res.writeHead（）可同时将三条语句的内容同时设置</p><p>比如：res.writeHead(200,’ok’,{</p><p>   ‘Content-Type’:’text/plain;charset=utf-8’    </p><p>})</p><p>注意：当我们采用三条语句设置响应报文头时，服务器内部也会去调用res.writeHead() 这个方法将三条语句填写进去，相当于我你们手动写的简单一条语句完成的动作，但系统会自动转换。</p><p>解析：第一个参数是状态码，第二个参数是状态码对应的状态信息，第三个参数是对象设置报文头类型</p><p><img src="https://s1.ax1x.com/2020/08/31/dOstk6.png"></p><p><img src="https://s1.ax1x.com/2020/08/31/dOskOs.png"></p><h2 id="npm介绍"><a href="#npm介绍" class="headerlink" title="npm介绍"></a>npm介绍</h2><h3 id="npm-node包管理器介绍"><a href="#npm-node包管理器介绍" class="headerlink" title="npm node包管理器介绍"></a>npm node包管理器介绍</h3><p> npm node.js代码的包管理器</p><p> npm install mime -g </p><p>-g 是全局安装的意思，我们的理解是安装好后可以在命令行中直接使用</p><p> 当我们需要用命令行使用时才需要全局安装，不然没必要使用全局安装</p><p> 当使用npm时一定要执行一次本地安装</p><h5 id="npm常用命令介绍："><a href="#npm常用命令介绍：" class="headerlink" title="npm常用命令介绍："></a>npm常用命令介绍：</h5><p> <img src="https://s1.ax1x.com/2020/08/31/dO51wF.png"></p><h4 id="模块和包的区别"><a href="#模块和包的区别" class="headerlink" title="模块和包的区别"></a>模块和包的区别</h4><p> <img src="https://s1.ax1x.com/2020/08/31/dOIruV.png"></p><h4 id="node-js-错误调试步骤"><a href="#node-js-错误调试步骤" class="headerlink" title="node.js 错误调试步骤"></a>node.js 错误调试步骤</h4><p> <img src="https://s1.ax1x.com/2020/08/31/dOoWdS.png"></p><h3 id="package-json-文件介绍"><a href="#package-json-文件介绍" class="headerlink" title="package.json 文件介绍"></a>package.json 文件介绍</h3><p> <strong>描述自身的信息就是 “元数据”</strong></p><p> package.json 就是描述包自身的数据信息的文件，也能叫元数据</p><p> 一、package.json 文件的作用</p><p>   1、package.json 文件是一个包说明文件（项目描述文件），用来管理组织一个包（一个项目）</p><p>   2、package.json 文件是一个json格式的文件</p><p>   3、位于当前项目的根目录下</p><p>   元数据</p><p> 二、package.json 文件中常见的项有哪些</p><p>  1、 name 包的名字 （必须要有）</p><p>  2、 version 包的版本（必须要有）</p><p>  3、 description 包描述</p><p>  4、author 作者</p><p> 三、如何创建一个 package.json 文件</p><p>  1、通过 npm init 命令或者npm init -y 或 -npm init -yes 命令</p><p> 注意：</p><p>  1、通过 npm init -y 或 -npm init -yes 创建 package.json 文件时，执行命令所在的目录接名称中不能包含大写字母</p><p>  2、package.json 文件中，项目名称本身不能包含大写字母</p><p>  3、npm更新新版本后，项目所在的文件夹如果包含中文等特殊字符，创建的时候不会提示一步一步的输入，直接报错</p><h3 id="package-lock-json-文件介绍"><a href="#package-lock-json-文件介绍" class="headerlink" title="package-lock.json 文件介绍"></a>package-lock.json 文件介绍</h3><p>  npm 5.0版本以上的版本才能出现这个文件</p><p>  引进这个文件目的：让包文件安装速度加快</p><p>  package-lock.json 下载快的原因：</p><p>  package.json 里面是保存了包名，当我们项目需要下载其他包时就需要从包名中逐级查找搜索，这样搜索下来肯定很慢</p><p>  package-lock.json 里面保存你当前项目依赖的所有的包的地址和版本号都保存到了这个文件中，当项目需要其他包的时候，只需要找到对应的包的地址和版本就可以找到下载了，这样速度就快不少（保存了被依赖包的详细信息）</p>]]></content>
    
    
    <categories>
      
      <category>nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式初步理解</title>
    <link href="/2020/07/03/Web/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2020/07/03/Web/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="正则表达式前期知识补充"><a href="#正则表达式前期知识补充" class="headerlink" title="正则表达式前期知识补充"></a>正则表达式前期知识补充</h2><p> 转义字符”&quot; 会把反斜杠后面的字符取消掉原来的意思，加个反斜杠之后就会将反斜杠后面的字符以文本的形式输出。转义符号不会显示出来，如果转义符号想显示出来的话反斜杠前面再加反斜杠就能将反斜杠显示出来。</p><p> \r：行结束符</p><p> \n:换行</p><p> \t:制表符</p><p> 多行字符串</p><p> 字符串换行符\n</p><h2 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h2><p> 正则表达式的作用：匹配特殊字符或有特殊搭配原则的字符的最佳选择。</p><p> 用于判读字符串里面有没有特殊的字符</p><p> 两种创建方式</p><p>   直接量 /添加字符/</p><p>   var reg = /abcd/pattern; //pattern这个地方可以放三个参数,分别式”i”,”g”,”m”。分别指定区分大小写、全局匹配、多行匹配</p><p>   mew RefExp(“ “ ，” “);//前面的值可以是正则表达式或则是字符串，后面的值式属性包括i、g、m/。</p><h2 id="正则表达式的应用"><a href="#正则表达式的应用" class="headerlink" title="正则表达式的应用"></a>正则表达式的应用</h2><p> 一、正则表达式的应用主要提供了两个方法</p><p>   reg.test(); //正则表达式上面的方法，用法只能判断字符串上面有没有符合要求的片段，返回值只有” true “或” flase “。</p><p>   str.match(); //是可以将匹配到的字符串返回回来。</p><p>   reg.exec(); //也是一个匹配的方法，会返回一个类数组</p><p>   var reg = /ab/g;<br>   var str = “abababab”;</p><p>   lastIndex 就是显示游标的位置。可以手动改变游标而改变显示的位置。</p><p> 二、表达式的书写规则</p><p> 1、[abc]表达式用于查找方括号之间的任何字符。方括号可以是任何字符或字符串。</p><p>   ^放到[]表达式里面[^abcdef]意思是查找给定集合外的任何字符</p><p>   示例：查找一串字符串包含的连续数字有哪些</p><pre><code>var reg = /[1234567890][1234567890][1234567890]/g;var str = &quot;123dhsjkadhas883uhjdks888&quot;str.match(reg);</code></pre><p> 2、（abc|bdf|nyh）表达式查找指定的选项</p><p> 3、正则表达式有种贪婪匹配原则</p><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><p>  解释：代表数量的词</p><p>  var reg = /\w+/g;意思是能出现多次，从1开始</p><p>  var str = “” </p><h2 id="支持正则表达式的String-对象的方法"><a href="#支持正则表达式的String-对象的方法" class="headerlink" title="支持正则表达式的String 对象的方法"></a>支持正则表达式的String 对象的方法</h2><p>  search 检索与正则表达式相匹配的值 （返回的是匹配到的这个值的位置，匹配不到的话就是返回-1）</p><p>  match 找到一个或多个正则表达式的匹配值（里面添加的是正则表达式）</p><p>  split 把字符串分割为字符串数组，按双向重复的拆开，将重复的分割开来</p><p>  replace 替换与正则表达式相匹配的子串（最常用）</p><p>  示例：var str = “aa”;</p><p>  str.replace(“a”,”b”); //这种情况只能匹配一个</p><p>  var = /a/g; //这种情况下的才能全部匹配， </p><p>  var str = “100000000000”;</p><p>  var reg = /(?=(\B)(\d{3})+$)/g;</p><p>  console.log(str.replace(reg,”.”));</p>]]></content>
    
    
    <categories>
      
      <category>js正则表达式应用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>json 异步加载 时间线</title>
    <link href="/2020/07/02/Web/json%EF%BC%8C%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%EF%BC%8C%E6%97%B6%E9%97%B4%E7%BA%BF/"/>
    <url>/2020/07/02/Web/json%EF%BC%8C%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%EF%BC%8C%E6%97%B6%E9%97%B4%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>  JSON是一种传输数据的格式（以对象为样板，本质上就是对象，但用途有区别，对象就是本地用的，json是用来传输的）</p><p>  JSON.parse(); string —&gt; json</p><p>  JSON.stringify();json —&gt; string</p><h2 id="js异步加载"><a href="#js异步加载" class="headerlink" title="js异步加载"></a>js异步加载</h2><p>  javascript异步加载的三种方案</p><p>   1、defer异步加载，但要等到dom文档全部解析完才会被执行。只有IE能用，也可以将代码写到内部</p><p>   2、async异步加载，加载完就执行，async只能加载外部脚本，不能把JS写到script标签里面</p><p>   1.2执行时也不阻塞页面</p><p>   3、创建script，插入到DOM中，加载完毕后callBack(按需加载，常用这种方法)</p><p>   scroll load（不能将主程序放到这个里面，可以将广告之类的最后执行的事件放里面,意思是其他程序执行完之后执行load事件)</p><p>  <img src="https://s1.ax1x.com/2020/07/02/Nbq2Fg.png"></p><p>   函数封装后的结果</p><p>  <img src="https://s1.ax1x.com/2020/07/02/NbOxZ6.png"></p><p>  IE里面用的是onreadytatechange</p><p>   callback 回调函数</p><h2 id="JS加载时间线"><a href="#JS加载时间线" class="headerlink" title="JS加载时间线"></a>JS加载时间线</h2><p>   主要用处：用于优化代码使用的，用于提升代码执行效率而作用的</p><p> 1、创建Document对象，开始解析WEB界面。解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中，阶段document.readyState = ‘loading’.</p><p> 2、遇到link外部CSS，创建线程加载，并继续解析文档</p><p> 3、遇到script外部JS，并且没有设置async、defer，浏览器加载，并阻塞，等待JS加载完成并执行该脚本，然后继续解析文档</p><p> 4、遇到script外部JS,并且设置async、defer,浏览器创建线程加载，并解析文档。对于async属性的脚本，脚本加载完成后立即执行。（异步禁止使用document.write())</p><p> 5、遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。</p><p> 6、当文档解析文成，document.readyState = “interactive”。</p><p> 7、文档解析完成后，所有设置有defer的脚本会按照顺序执行。（注意于anysc的不同，但同样禁止使用document.write()）</p><p> 8、document对象触发DOMContentLoaded事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。</p><p> 9、当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState = ‘complete’,window对象触发事件。</p><p> 10、从此，以异步响应方式处理用户输入，网络事件等。</p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript DOM操作方法</title>
    <link href="/2020/06/06/Web/JS%E7%AC%94%E8%AE%B0(3)DOM%E6%96%B9%E6%B3%95/"/>
    <url>/2020/06/06/Web/JS%E7%AC%94%E8%AE%B0(3)DOM%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>  什么是Dom</p><p>  1.DOM —&gt;Document Object Model</p><p>  2.DOM定义了表示修改文档所需的方法。DOM对象即为宿主对象，有浏览器厂商定义，用来操作html和Xml功能的一类对象的集合。也有人称DOM是对HTML以及XML的标准编程接口。</p><p>  3、DOM开始一切系统给我们生成成组的方式基本上时类数组</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>   构造函数是干嘛的是生成对象的</p><h2 id="DOM基本操作"><a href="#DOM基本操作" class="headerlink" title="DOM基本操作"></a>DOM基本操作</h2><p>  一、对节点的增、删、改、改、查</p><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><pre><code>      查看元素节点（以下都是查看元素的方法）      document代表整个文档（是一个对象，里面有对象和方法）      document.getElementById() //元素id在Ie8以下的浏览器，不区分id大小写，而且也返回匹配name属性的元素      .getElementsByTagName(); //标签名,在所有浏览器中都可以说适用      .getElementByName(); //需注意，只有部分标签name可生效（表单，表单元素，img,iframe）      .getElementsByClassName() //类名 -&gt; ie8和ie8以下的ie版本中没有这个方法，可以多个class一起      .querySelector() //CSS选择器 在ie7和ie7以下的版本中没有，可以当CSS选择器一样选择，选择出来的不是一组      .querySelectorAll() //CSS选择器 在ie7和ie7以下的的版本中没有，选择出来的是一组 </code></pre><p>   only = document.getElementById(“only”) //这语法不能选择出一组id</p><p>   div = document.getElementsByTagName(“div”)[0]; //这个语法选中出来的是标签名，是成组的方式呈现的</p><p>   2、遍历节点数</p><pre><code> parentNode -&gt; 父节点（最顶端的parentNode为#document)； childNodes -&gt; 子节点们 firstChild -&gt; 第一个子节点 lastChild -&gt; 最后一个子节点 nextSibling -&gt; 后一个兄弟节点  previousSilbling -&gt; 前一个兄弟节点</code></pre><p>  3、基于元素节点树的遍历 （用的较多，重点记忆）</p><pre><code> prentElement -&gt; 返回当前元素的父元素的节点（IE不兼容） children -&gt; 只返回当前元素的元素子节点（用的频率较高） node.childElementCount === node.children.length当前元素节点的子节点  firstElementChild -&gt; 返回的是第一个元素节点（IE不兼容） lastElementChild -&gt;返回的是最后一个元素节点（IE不兼容） nextElementSibling / previousElementSibling -&gt;返回后一个/前一个兄弟元素</code></pre><p>   4、每一个节点都有四个属性</p><pre><code>  nodeName     元素的标签名以大写形式表示，只读  nodeValue     Text节点或Comment（注释）节点的文本内容，可读写  nodeType（最重要重点，判断元素是什么类型的）     该节点的类型，只读(能够显示元素是什么类型的)  attributes     Element 节点的属性集合</code></pre><p>   5、节点的一个方法 Node.hasChildNodes()；   </p><p>   6、节点类型</p><pre><code>  元素节点 ----1    属性节点 ----2  文本节点 ----3  注释节点 ----4  document ----9  DocumentFragment -----11</code></pre><p>  7、获取节点类型 nodeType   </p><p>  8、DOM结构树</p><p>   <strong>DOM结构树就是代表的一系列的继承关系</strong></p><p>   document —-&gt;(继承) HTMLDocument.prototype —-&gt;Document.portotype</p><p>   <img src="https://s1.ax1x.com/2020/06/12/tXNdSg.th.png"></p><p>   9、DOM原型链上的基本操作</p><pre><code>  1、getElementById 方法定义在Doument.prototype上，即Element节点上不能使用。  2、getElementsByName方法定义在HTMLDocument.prototype上，即非html中的documen以外不能使用(xml documen,element)  3、getElementsByTagName方法定义在Document.prototype和Elemen.prototype上  4、HTMLDocument.prototype定义了一些常用属性，body,head,分别指代HTML文档中的&lt;body&gt;&lt;head&gt;标签   5、Document.prototype上定义了documentElement属性，指代文档的更元素，在HTML文档中，他总是指代&lt;html&gt;元素  6、getElementsByClassName\querySelectorAll、querySelector在Document,Element类中均有定义      ![](https://s1.ax1x.com/2020/06/13/tvE6J0.png)</code></pre><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><p>  示例：var div = document.createElement(“div”); //可以创建一个标签，但还没有给到HTML;</p><p>  1、document.createElement(); //创建元素节点（<strong>常用</strong>）</p><p>  2、document.createTextNode(); //创建文本节点</p><p>  3、document.createComment(); //创建注释节点（不常用）</p><p>  4、document.createDocumentFragment(); //创建文档碎片节点</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>   1、PARENTNODE.appendChild(); //任何一个元素节点都会有这个属性</p><p>   2、PARENTNODE.inserBefore(a,b); // 读法inser”a” , Before”b”  ，把”a”插入到”b”之前。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>   1、parent.removeChild(); //将标签元素剪切出来 （<strong>常用</strong>）</p><p>   2、child.remove(); //这是真的销毁掉选择的标签元素（<strong>常用</strong>）</p><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p>   1、parent.replaceChild(new,origin); //那”new”的元素去替换”origin”元素 ，理解：用新的元素去替换老的元素</p><h3 id="下面是常用方法（重点）"><a href="#下面是常用方法（重点）" class="headerlink" title="下面是常用方法（重点）"></a>下面是常用方法（重点）</h3><p>  二、Element节点的一些属性</p><p>  innerHTML</p><pre><code>  innerHtml改变一个元素的HTML内容  innerHtml写啥就能识别啥，还能够写入CSS属性也是能够识别并且引用的</code></pre><p>  innerText(老版本火狐不兼容，现在的基本都兼容)/textContent(老版本IE不好使)</p><pre><code>   innerText 可以取元素里面的内容，会把结构覆盖掉</code></pre><p>  三、Eelement节点的一些方法</p><pre><code> ele.setAttribute(&quot;class&quot;,&quot;demo&quot;); //给标签设置一个行间属性 ，前面是属性名，后面是属性值 ele.getAttribute(&quot;class&quot;); //能够获取属性名上的属性值,括号里面填写属性名 ，取行间属性值</code></pre><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>   一、setInterval（） //每隔一段时间就会去执行里面的内容</p><p>   语法：</p><pre><code>   setInterval(function()&#123;&#125;,1000)</code></pre><p>   不能改变time的值来让这个改变时间执行<br>    var time =1000;</p><pre><code>setInterval(function()&#123;&#125;,time)time = 2000;</code></pre><p>   每一个setInterval都会返回一个标识符</p><p>   二、setTimeout() //只执行一次</p><p>   三、clearInterval() //清除定时器</p><p>   四、clearTimeout()</p><p>  重点注意：全局对象window上的方法，内部函数this指向window</p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript基础理解-2</title>
    <link href="/2020/05/19/Web/JS%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/"/>
    <url>/2020/05/19/Web/JS%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="继承的发展史"><a href="#继承的发展史" class="headerlink" title="继承的发展史"></a>继承的发展史</h2><p>   1、传统形式 —–&gt;原型链</p><p>   弊端：过多的继承了没有用的属性</p><p>   2、借用构造函数 call/apply</p><p>   弊端：（1）不能继承借用构造函数的原型</p><p>   （2）每次构造函数都要多走一个函数</p><p>   3、共享原型(公有原型)</p><p>   弊端：不能随便改变自己的原型，改变了自己的原型也会把继承的那个的原型也一同改变</p><p>   4、圣杯模式</p><h3 id="共享原型"><a href="#共享原型" class="headerlink" title="共享原型"></a>共享原型</h3><p>   代码格式</p><pre><code>   Father.prototype.lastName = &quot;Deng&quot;;   function Father()&#123;     &#125;   function Son()&#123;     &#125;   Son.prototype = Father.prototype</code></pre><p>   添加下面两条语句就可以继承公有原型</p><pre><code>   var son = new Son(); //创建对象   var father = new Father();</code></pre><p>   抽象出一个功能封装成函数，函数就代表功能，函数代表功能的复用，哪块能复用，哪块能定义化就是通过参数来实现的。 </p><p>   构造一个函数封装继承</p><pre><code>    Father.prototype = lastName = &quot;Deng&quot;;        function Father()&#123;        &#125;        function Son()&#123;        &#125;        function inherit(Target,Origin)&#123;            Target.prototype = Origin.prototype;        &#125;        inherit(Son,Father); //将继承关系封装在这个函数里面        var son = new Son();        var father = new Father();  </code></pre><p>   总结：这种继承方式的弊端是，当我改变son里面的属性的时候Father里面的属性也会改变，我就不能单独给son添加一个自己的的原型。这样也不怎好。后面引申出圣杯模式</p><h2 id="圣杯模式"><a href="#圣杯模式" class="headerlink" title="圣杯模式"></a>圣杯模式</h2><p>  方法：还是公有原型，通过添加一个中间的构造函数</p><pre><code>  ather.prototype.lastName = &quot;Deng&quot;;function Father()&#123;&#125;function Son()&#123;&#125;function inherit(Target,Origin)&#123;    function F()&#123;&#125;;    F.prototype = Origin.prototype;    Target.prototype = new F();&#125;inherit(Son,Father);var son = new Son();var father = new Father();</code></pre><p>   这种继承方式就不会改变继承的属性方法了。可以访问继承过来的属性</p><p>   每一个原型上都有一个系统给我们自带的一个属性叫做constuctor,constuctor默认的值是指向自己的构造函数，那么上面的代码的问题来了，son.constuctor理应指向    function Son(){</p><p>}这个函数的</p><p>  但这里当我们访问son.constuctor时会指向function Father(){</p><p>}这个函数</p><p>  为解决这种constuctor指向混乱错误时，我们要让son.constuctor指向的还是    function Son(){</p><p>}这个函数的</p><p>   我们需要添加下面两条代码</p><pre><code> Target.prototype.constuctor = Target; Target.prototype.uber = Origin.prototype;//信息的储存</code></pre><p>  代码改正</p><pre><code>Father.prototype.lastName = &quot;Deng&quot;;function Father()&#123;&#125;function Son()&#123;&#125;function inherit(Target,Origin)&#123;    function F()&#123;&#125;;    //一定要先继承才能new    F.prototype = Origin.prototype;    Target.prototype = new F();    Target.prototype.constuctor = Target;    Target.prototype.uber = Origin.prototype;&#125;inherit(Son,Father);var son = new Son();var father = new Father(); </code></pre><p>   还有一种写法</p><pre><code>   Father.prototype.lastName = &quot;Deng&quot;;    function Father()&#123;        &#125;        function Son()&#123;        &#125;     var inherit = (function()&#123;     var F = function()&#123;&#125;;     return function (Target,Origin)&#123;        F.prototype = Origin.prototype;       Target.prototype = new F();       Target.prototype.constuctor = Target;       Target.prototype.uber = Origin.prototype;     &#125;  &#125;());  var son = new Son();  var father = new Father();</code></pre><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>   管理变量，防止污染全局，适用于模块化开发</p><p>   1、通过闭包来使变量私有化</p><p>   代码格式</p><p>   <img src="https://s1.ax1x.com/2020/05/19/Y5m8XR.png"></p><h2 id="对象的枚举"><a href="#对象的枚举" class="headerlink" title="对象的枚举"></a>对象的枚举</h2><p>   枚举也叫遍历</p><p>   for in 循环写法：</p><pre><code>    //就是将属性名放到prop里面        for(var prop in obj)&#123;                   console.log(prop);                 &#125;</code></pre><p>   在枚举里面也可以写成  console.log(obj[prop]);这一块只能写成方括号</p><p>   for in 循环可以把对象里面的属性提取出来   </p><p>   for in 循环作用：就是给对象遍历的，就是给对象设立一个遍历的。</p><p>   1.hasOwnProperty（方法）</p><p>   2.in （只能访问对象里面的是否有这个属性，包括原型）</p><p>   3.instanceof </p><h3 id="利用for-in循环遍历不打印原型属性的方法"><a href="#利用for-in循环遍历不打印原型属性的方法" class="headerlink" title="利用for in循环遍历不打印原型属性的方法"></a>利用for in循环遍历不打印原型属性的方法</h3><p>  ** 引入一个方法 hasOwnProperty()**</p><p>   hasOwnProperty()这个方法可以找到自己本省的属性，然后利用判断的方法查找是否是本身方法</p><p>   系统自带的原型是不会打印出来的</p><p>   Object.prototype.abc = “567”; </p><p>   这种也是系统自带的，需要特别注意</p><p>   代码模式如下</p><pre><code>    var obj = &#123;       name:&quot;nwe&quot;,       age:123,       Height:180,           __proto__ :&#123;          lastName:&quot;deng&quot;       &#125;        &#125;        for(var prop in obj)&#123;           if(obj.hasOwnProperty(prop))&#123;               console.log(obj[prop]);       &#125;         &#125;![](https://s1.ax1x.com/2020/05/20/YoU25D.png)</code></pre><h3 id="instanceof-的使用"><a href="#instanceof-的使用" class="headerlink" title="instanceof 的使用"></a>instanceof 的使用</h3><p>  A instanceof B</p><p>  官方解释：A对象 是不是 B构造函数构造出来的 （不全）</p><p>  数组也是对象</p><p>  A instanceof B</p><p>  总结说明：看A对象的原型链上  有没有  B的原型</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>  1、函数预编译过程this —-&gt;window</p><p>  2、全局作用域里this —-&gt;window</p><p>  3、call/apply 可以改变函数运行时的 this 指向</p><p>  4、obj.func();（func里面的 this 指向obj）</p><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>   1、arguments.calle （指向函数自生引用，在哪个函数里面就指向哪个函数）</p><p>   举例：<br>        采用立即执行函数的方式求阶乘，arguments.calle 调用自身函数执行多次。</p><pre><code>    var num = (function (n)&#123;              if(n==1)&#123;            return 1;        &#125;            return n*arguments.callee(n-1);         &#125;(10))        </code></pre><p>   2、func.caller （在哪调用就是指向的调用哪个函数）</p><h2 id="数组运用"><a href="#数组运用" class="headerlink" title="数组运用"></a>数组运用</h2><p>  数组的定义,有两种方式</p><pre><code>   new Array(length/content);   字面量 var arr=new Array();</code></pre><p>  这两种方式的唯一区别</p><pre><code>   var arr = new Array(10); //这种方式只会是创建了10位，位数   var arr1 = [10]; //这种方式会给数组的第一位为10，会赋值给数组的第一位</code></pre><p>  数组的读和写</p><pre><code>   arr[num] //不可以溢出读，结果是undefine    arr[num] = xxx; //可以溢出读</code></pre><h3 id="数组的方法运用"><a href="#数组的方法运用" class="headerlink" title="数组的方法运用"></a>数组的方法运用</h3><p>  改变原数组</p><pre><code> push, pop, shift, unshift, sort, reverse,splice</code></pre><p>  不改变原数组</p><pre><code>  concat,join ---&gt;split,toString,slice</code></pre><p>  重写系统push方法<br>   把最后一位去增加</p><pre><code>  var arr = [1,2,3];  Array.prototype.push = function()&#123;     for(var i;i&lt;arguments.length ; i++)&#123;        this[this.length] = arguments[i];      &#125;   return this.length; &#125;</code></pre><p>  pop 方法</p><p>   把数组的最后一位剪切出来 </p><p>  shift方法</p><p>   在前面面增加</p><p>  unshift方法</p><p>   在前面减少</p><p>  reverse方法</p><p>   逆转顺序</p><p>  <strong>splice方法（可以传好些个参数）</strong></p><p>  <strong>运用：</strong></p><pre><code>var arr = [1,1,2,3,5,6,7];arr.splice(从第几位开始，截取多少个长度，在截取处添加新的数据)第几位可以用负数，意思就是从数组的后面倒数几位</code></pre><p> ** 这个方法需要重点掌握，可以在任意位置添加数据**</p><p>   sort方法是在原数组上给数组排序的（是按A排序的）</p><pre><code>sort留了一个接口，可以让数组安照任意方式进行排序  var arr = [1,1,2,3,5,6,7];         arr.sort(function(a,b)&#123; //这个方法就是没有方法名，相当于函数引用        //1、必须写俩返回值    //2、看返回值           1）当返回值为负数时， 那么前面的数放在前面          2）为正数， 那么后面的数在前          3）为0， 不动    //这里面可以添加任意的排序代码，让数组按照我们想要的方式进行排序     &#125;);</code></pre><p>   <strong>改变</strong></p><p>   concat 的方法的使用 （将两个数组连接成一个数组）</p><p>   toString 把数组变成字符形式的数组</p><p>   slice(从该位开始截取，截取到该位)</p><p>   slice 使用举例：</p><pre><code>  arr = [1,2,3,4,5,6,7];  var newArr = arr.slice(1,3);//两个参数的情况  var newArr = arr.slice(从第几位开始截取，截取到最后); //这是一个参数的情况</code></pre><p>  join —&gt;split (split和数组的方法是可逆的)</p><p>  传的是什么就用什么来连接数组之间的值</p><pre><code>join（&quot;?&quot;）执行后的形式 1?2?3</code></pre><p>  split 可以让数组按什么形式连接的就可以将什么形式的连接符给去除</p><h2 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h2><p>   长的像数组的属性</p><p>   <strong>类数组能够当数组使用也能当对象使用，要使用数组时加上数组方法，要使用对象时加上对象的方法。</strong></p><p>   1、arguments类数组</p><pre><code>  function test()&#123;    console.log(arguments);    arguments.push(7); &#125;</code></pre><p>   2、有着对象一样的类数组</p><pre><code>var obj =&#123;  &quot;0&quot; : &#39;1&#39;,  &quot;1&quot; : &#39;2&#39;,  &quot;2&quot; : &#39;3&#39;,  &quot;length&quot; :3,  &quot;push&quot; : Array.prototype.push    &#125;  </code></pre><p>  注意点：属性要为索引（数字）属性，必须要有length属性，最好加上push</p><p>  加上”splice” :Array.prototype.splice这个属性后就更像数组形式了，可以去验证。</p><h2 id="this指向的问题在理解"><a href="#this指向的问题在理解" class="headerlink" title="this指向的问题在理解"></a>this指向的问题在理解</h2><pre><code>1、预编译 this ---&gt; window (this指向window)  2、谁调用的this指向谁3、call apply4、全局this---&gt;window</code></pre><p>  当我们每写一个函数的时候，系统就会预编译环节建立一个AO，AO里面不仅会包含你自己写的属性，也会增加系统隐式给的两个属性，分别是 arguments : {} 这个类数组 ，还有一个 this :window 此时这个this指向的是 window</p><p>   函数和函数.call执行是一样的</p><p>   函数会有一个隐式的this,</p><pre><code>    var this = Object.areate(Student.prototype);Student是函数名</code></pre><p>   <img src="https://s1.ax1x.com/2020/05/25/tClJde.png"></p><h2 id="try-catch-e-用法"><a href="#try-catch-e-用法" class="headerlink" title="try{  }catch(e){  }用法"></a>try{  }catch(e){  }用法</h2><p>  e是形参可以自行定义。</p><p>   在try里面的代码发生错误是不会再执行try里面报错的后续代码的，然后在try里面的那行错误代码的错误信息可以在catch里面打印出来。只会让try错误后面的代码终止。</p><p>   查找错误的错误信息。</p><p>   Error.name的六种值对应的信息</p><p>   1、EvalError : eval()的使用与定义不一致</p><p>   2、RangeError : 数值越界</p><p>   3、ReferenceError : 非法或不能识别的引用数值</p><p>   4、SyntaError : 发生语法解析错误</p><p>   5、TypeError : 操作数据类型错误</p><p>   6、URIError ：URI处理函数使用不当</p><h2 id="es5标准模式"><a href="#es5标准模式" class="headerlink" title="es5标准模式"></a>es5标准模式</h2><pre><code>“use strict”不再兼容es3的一些不规则语法。使用全新的es5规范。两种用法：   全局严格模式   局部函数内严格模式（推荐）就是一行字符串，不会对不兼容严格模式的浏览器产生影响。不支持with,arguments.callee,func.caller,变量赋值前必须声明，局部this必须被赋值(Person.call(null/undefined) 赋值什么就是什么),拒绝重复属性和参数</code></pre><p>   浏览器是基于 es3.0 和 es5.0 新增方法 去执行的</p><p>   es3.0 和es5.0产生冲突的部分</p><p>   es5.0严格模式 那么es3.0和es5.0 产生冲突的部分就是用es5.0否则会用es3.0</p><p>   es5.0严格模式的启动 “use strict”; (写在页面代码的最顶端就可以启动es5.0严格模式的方法，也可以写在函数里面的最顶端，但这个时候就是启动的这个函数是遵循es5.0严格模式，但其他函数是不受影响的)</p><p>   用字符串来表示的用意是为了兼容老浏览器，如果没有更新的话也能安照老版本去执行而字符串表达式也不会报错，如果更新了也能识别到，这个时候就能执行es5.0版本的严格模式了</p><h2 id="执行期上下文with的用法"><a href="#执行期上下文with的用法" class="headerlink" title="执行期上下文with的用法"></a>执行期上下文with的用法</h2><pre><code>var obj = &#123;  name : &quot;123&quot;,&#125;function test()&#123;  name =&quot;235&quot;;  with(obj)&#123; //with（可以直接访问）   console.log(name);  &#125;&#125;test();</code></pre><p>   es5的严格模式不能用这个with</p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript基础理解-1</title>
    <link href="/2020/05/11/Web/JS%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
    <url>/2020/05/11/Web/JS%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="函数的定义和函数的执行是分隔开来的，一般是先定义函数的，然后再执行函数"><a href="#函数的定义和函数的执行是分隔开来的，一般是先定义函数的，然后再执行函数" class="headerlink" title="函数的定义和函数的执行是分隔开来的，一般是先定义函数的，然后再执行函数"></a>函数的定义和函数的执行是分隔开来的，一般是先定义函数的，然后再执行函数</h1><p>   <strong>函数的定义和函数的执行是分隔开来的，重点注意函数的执行顺序，什么时候定义的，然后又是什么时候去执行的</strong></p><p>   <strong>形参：形式参数，比如字符代替的参数</strong><br>   <strong>实参：实际参数，比如完整的数字，给的完全的数据</strong></p><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>   AO{</p><p>   最开始每个变量都是 undefined 然后查找变量是否为函数 最后查找函数是有变为实参被定义。按这种方法来查找函数的执行顺序</p><p>  }</p><p>   GO{</p><p>  }全局变量</p><p>  <img src="https://s1.ax1x.com/2020/05/13/YaQtET.png"></p><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>函数声明和函数表达式是不一样的</p><pre><code>function test()&#123;&#125; //函数声明</code></pre><p>  只有表达式才能被执行符号执行</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>  当内部函数被保存到外部时，将会生成闭包。闭包会导致所有作用域链不释放，造成内存泄漏</p><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><p>  过多的使用会导致内存的泄露</p><p>  累加器就是用这个闭包实现的</p><p>  <strong>闭包的四个应用</strong></p><pre><code>   1、实现公有变量         比如：函数累加器   2、可以做缓存（存储结构）        比如：eater   3、可以实现封装，属性私有化        比如：Person   4、模块化开发防止污染全局</code></pre><p>  <img src="https://s1.ax1x.com/2020/05/11/YJLWz8.png"></p><p>  闭包可以做缓存应用的代码示例</p><pre><code> //代码思路：最先new一个方法，方法里面写一个对象，对象包含两个方法，也可以是对象里面有属性function eater()&#123; //新建一个方法     var food=&quot;&quot;;    var obj=&#123; //创建一个对象        //编写属于对象的两个属性        eat :function()&#123;             console.log(&quot;i am &quot;+food);            food=&quot;&quot;;            &#125;,         //注意两个属性之间要用逗号隔开        push :function(myfood)&#123;             food = myfood;        &#125;    &#125;    return obj;&#125;    var eater1 = eater(); //将返回的对象值赋值给一个值        eater1.push(&quot;apple&quot;);//要先写这个，给对象的属性一个值，才能执行到下一句    eater1.eat();//要先给push属性一个值，下面那个方法才能打印出之前给的值</code></pre><p>  <img src="https://s1.ax1x.com/2020/05/11/YJxI5d.png"></p><h2 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h2><p>   针对初始化功能的函数，执行完函数，就会将函数立即释放，执行完函数就是被销毁。</p><p>   编程的形式代码</p><pre><code>     (function abc()&#123;        var a=123;        var b=567;            console.log(a+b);    &#125;())</code></pre><p>   <img src="https://s1.ax1x.com/2020/05/11/YYP5a8.png"></p><p>   立即执行函数返回值的接收方法</p><pre><code>  var num  = (function abc(a,b)&#123;       var d= a+b;       return d;           &#125;(1,2))</code></pre><h1 id="数组应用方法"><a href="#数组应用方法" class="headerlink" title="数组应用方法"></a>数组应用方法</h1><pre><code>function test()&#123;    var arr = [];    for(var i=0; i&lt;10; i++)&#123;                    arr[i]=function()&#123;            console.log(i+&quot; &quot;);        &#125;           &#125;    return arr;&#125;var myArr = test();for(var j=0; j&lt;10;j++)&#123;    myArr[j](); //对前面执行的函数形成了一个闭包，在这里打印的10个数据都是10。这里就促发了闭包。&#125;</code></pre><h2 id="闭包理解"><a href="#闭包理解" class="headerlink" title="闭包理解"></a>闭包理解</h2><p>  <strong>循环最容易触发闭包，需要特别注意循环是否触发闭包</strong></p><p>  闭包的效果是让函数的执行顺序改变。</p><pre><code>function a()&#123;        function b()&#123;        var bbb=234;        document.write(aaa);    &#125;        var aaa=123;     return b;//就是将内部函数导入到外部去执行&#125;var demo = a();demo();    </code></pre><p>   不用return 的第二种实现方式<br>   <img src="https://s1.ax1x.com/2020/05/12/YtK79I.png"></p><h2 id="闭包的原理"><a href="#闭包的原理" class="headerlink" title="闭包的原理"></a>闭包的原理</h2><p>  如果想让for循环里面的函数立即执行，而不是等到外部访问了之后才去执行，那么我们就可以利用立即执行函数，将每一次的循环都执行到那个函数，然后当我们去访问这个函数的时候就可以得到每一次都执行的结果，而不是等到外部访问的时候执行的结果是总的结果。</p><pre><code>   function test()&#123;        var arr = [];        for(var i=0; i&lt;10; i++)&#123;                            arr[i]=function()&#123;                console.log(i+&quot; &quot;);            &#125;                   &#125;            return arr;        &#125;        var myArr = test();    for(var j=0; j&lt;10;j++)    &#123;        myArr[j]();        &#125;</code></pre><p>   <strong>解决办法在触发闭包后的解决办法</strong></p><h3 id="触发闭包后的解决办法"><a href="#触发闭包后的解决办法" class="headerlink" title="触发闭包后的解决办法"></a>触发闭包后的解决办法</h3><p>  多个函数嵌套时，容易触发闭包，把里面的这个函数保存到外部函数的外部，保存到了全局，这种情况必然会生成闭包。然后里面的函数在外部执行时，就一定能够调用得了原来他在的那个环境里面的变量。</p><p>  <strong>利用闭包解决闭包</strong></p><pre><code>function test()&#123;    var arr = [];    for(var i=0; i&lt;10; i++)&#123;                (function (j)&#123;               arr[j]= function()&#123;                document.write(j+&quot; &quot;);               &#125;        &#125;(i))            //用闭包的方式解决问题    &#125;    return arr;&#125;var myArr = test();for(var j=0; j&lt;10;j++)&#123;      myArr[j]();&#125;</code></pre><h2 id="内存泄漏意思理解"><a href="#内存泄漏意思理解" class="headerlink" title="内存泄漏意思理解"></a>内存泄漏意思理解</h2><p>   意思是过多的占用内存资源。剩的资源空间就会少了</p><h1 id="闭包作用示例"><a href="#闭包作用示例" class="headerlink" title="闭包作用示例"></a>闭包作用示例</h1><h2 id="累加器"><a href="#累加器" class="headerlink" title="累加器"></a>累加器</h2><p>   <strong>不依赖于外部变量并且能够反复执行的函数累加器</strong></p><p>  <img src="https://s1.ax1x.com/2020/05/12/YtTJm9.png"> </p><h2 id="闭包的第三点应用"><a href="#闭包的第三点应用" class="headerlink" title="闭包的第三点应用"></a>闭包的第三点应用</h2><p>   私有化变量</p><p>   访问的时是函数内部自己的变量</p><p>   <img src="https://s1.ax1x.com/2020/05/19/Y44v4A.png"></p><h2 id="只有表达式才能被执行"><a href="#只有表达式才能被执行" class="headerlink" title="只有表达式才能被执行"></a>只有表达式才能被执行</h2><p>   函数声明</p><pre><code>    function test()&#123;    &#125;</code></pre><p>  函数表达式</p><pre><code>    var demo = function()&#123;        console.log(&#39;a&#39;);    &#125;</code></pre><p>  这下面这种执行也是表达式。<br>   test(); //创建的方法去执行</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>  生活中任何一个事物都可以抽象成一个对象</p><p>  基础的变量类型</p><p>  可以有属性，有方法</p><h3 id="属性的-增、删、改、查"><a href="#属性的-增、删、改、查" class="headerlink" title="属性的 增、删、改、查"></a>属性的 增、删、改、查</h3><p>  探索任何东西都要符合一个原则，怎么操作的，怎么构成的</p><p>  计算机通用操作就是增、删、改、查</p><p>  删除属性要用到 delete</p><pre><code>     delete mrDERAN.name</code></pre><h3 id="对象的创建方法"><a href="#对象的创建方法" class="headerlink" title="对象的创建方法"></a>对象的创建方法</h3><p>   1、var obj = {}  plainObject 对象字面量/对象直接量</p><p>   2、构造函数</p><p>   1）系统自带的构造函数  new Object() Object<br>   2)自定义</p><pre><code> var obj = new Object(); obj.name = &#39;abc&#39;; // 添加属性 obj.sex = &#39;male&#39;; //添加属性 obj.say = function()&#123;&#125; //这里面也可以添加方法,但这里面的方法需要用等号连接</code></pre><p>   3、通过添加new创建一个对象</p><pre><code>     function person()&#123; &#125; //创建一个方法或者说是构造函数    var person1 = new person();  //给创建的方法添加上一个new就可以创建一个对象了，和前面几种创建对象的方法基本上没有什么去别</code></pre><p>   大驼峰式命名规则 TheHeName (命名规则)</p><p>   4、”new”一个对象之后函数里面会添加一个this</p><pre><code>var this = Object.create(函数名.prototype)//隐式的</code></pre><p>   <img src="https://s1.ax1x.com/2020/05/22/YXr0Xt.png"></p><h3 id="构造函数的内部原理"><a href="#构造函数的内部原理" class="headerlink" title="构造函数的内部原理"></a>构造函数的内部原理</h3><p>   有new之后内部自动将构造的函数转换成 var this = {}</p><p>   返回                         return this  这个样式之后就能形成以一个对象</p><p>   <img src="https://s1.ax1x.com/2020/05/14/YDJMX8.png"></p><p>   注意最后会返回一个this</p><p>   <img src="https://s1.ax1x.com/2020/05/14/YD3MXF.png"></p><p>   构造函数如何实现的三段论</p><pre><code>   现在函数体最前面隐式的加上 var this = &#123;&#125;   先隐式的来个 this   隐式的返回 return this</code></pre><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>   原始值不单单指的是数字，其他定义的原始变量都可以指原始值</p><p>   只有原始值数字才是原始值</p><p>   原始值不可能有属性和方法，只有转换成对象才能够有属性和方法</p><p>   隐式的环节就是经过包装类之后的结果</p><pre><code> 常见包装类：       new String();       new Boolean();       new Number();</code></pre><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>   1、定义：原型是function的对象的一个属性，他定义了构造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。</p><p>   2、利用原型特点和概念，可提取共用属性（可以将共有的属性提取出来，下面是使用示例）</p><p>   使用示例</p><p>   <img src="https://s1.ax1x.com/2020/05/15/Yrec24.png"></p><p>   原型也是有增、删、改、查</p><p>   修改的话是要在原型的对象上进行。<br>   Person.prototype.lastname</p><p>   <img src="https://s1.ax1x.com/2020/05/15/YrmfSg.png"></p><p>   3、对象如何查看原型 -&gt;隐式属性 <strong>proto</strong></p><p>   4、对象如何查看对象的构造函数 -&gt;constructor</p><p>   Prototype原型空对象，可以将固有的公共的属性写在这个原型空对象上面，就可以最大限度的使用内存空间</p><p>  常用方式</p><pre><code> var obj = &#123;&#125; 这种方式构建对象常用 var obj1 = new Object(); 这种构建对象方式不常用并且比较麻烦</code></pre><h2 id="绝大多数对象的最终都会继承自Object-prototype"><a href="#绝大多数对象的最终都会继承自Object-prototype" class="headerlink" title="绝大多数对象的最终都会继承自Object.prototype"></a>绝大多数对象的最终都会继承自Object.prototype</h2><h2 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h2><p>   系统也会有自带的属性的方法，但我们用系统自带的属性的名字重新写一个也叫做方法的重写</p><p>   我在原型链的中间截断写一个自己需要的方法就是说方法的重写，写一个自己需要用到了方法</p><p>   <img src="https://s1.ax1x.com/2020/05/18/YhfPsg.png"></p><p>   在页面中能够打印出字符的底层原理</p><p>   <img src="https://s1.ax1x.com/2020/05/18/Yh45in.png"></p><pre><code>    Object.prototype.toString    Number.prototype.toString    Array.prototype.toString    Boolean.prototype.toString    String.prototype.toString</code></pre><h2 id="call-apply的作用"><a href="#call-apply的作用" class="headerlink" title="call/apply的作用"></a>call/apply的作用</h2><p>   <strong>call/apply的作用：改变this指向，利用别人的方法实现自己的功能</strong></p><p>   call/apply的区别：</p><p>   call需要把实参按照形参的个数传进去</p><p>   apply 需要传一个arguments,按照数组形式传入</p><p>   总结：后面传的参数的形式不同（传参列表不同）</p><p>   自行理解：当两个对象需要用到同一个属性的时候就可以用这种方法去实现。可以将第一个对象的属性写齐，然后第二个对象就可以利用call去共同使用第一个对象的属性</p><pre><code>    function Person(name,age)&#123;          相当于this = obj        this.name = name;        this.age = age;    &#125;        var person = new Person(&quot;laodeng&quot;,100);        var obj = &#123;        &#125;        Person.call(obj,&#39;cheng&#39;,300); //添加上这条语句时就可以让this指向obj这个对象里面的属性,那么Person.call(obj,后面的值就可以添加的obj对象里面的那个属性里去了</code></pre><p>   实现的结果</p><p>   <img src="https://s1.ax1x.com/2020/05/18/YhL9qP.png"></p><p>   一般用到这个的地方形式</p><pre><code>        function Person(name,age)&#123;                    this.name = name;            this.age = age;        &#125;                function Student(name,age,sex,tel)&#123;                        Person.call(this,name,age); //重要语句                    this.sex = sex;            this.tel = tel;                &#125;                var student = new Student(&quot;laodeng&quot;,100,&#39;male&#39;,1237);</code></pre><p>   这样就能将Person里面的属性调用到Sudent这个对象里面去使用</p><p>   apply </p><h2 id="原型总结"><a href="#原型总结" class="headerlink" title="原型总结"></a>原型总结</h2><p>   <strong>先继承后引用</strong></p><p>   原型是一个prototype ，原型是一个function的一个属性。</p><p>   是函数就有这个属性，每个函数都有</p><p>   原型这个函数构造对象的共有祖先</p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS经典例题总结</title>
    <link href="/2020/05/09/Web/%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98/"/>
    <url>/2020/05/09/Web/%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="第一题、构造函数和对象的知识运用"><a href="#第一题、构造函数和对象的知识运用" class="headerlink" title="第一题、构造函数和对象的知识运用"></a>第一题、构造函数和对象的知识运用</h2><p>  这个题目也有考闭包的问题</p><pre><code>  function Person(name,age ,sex)&#123;    var a=0;    this.name = age;    this.age = age;    this.sex = sex;    function abc()&#123;        a++;        console.log(a);            &#125;    this.say = abc;&#125;//这个函数做的运算最后会将this的值返回出来给函数var person3 = new Person(); //将构造函数转换成对象  person3.say(); //得出的结果是1person3.say(); //得出的结果是2var person5 = new Person(); //又会将构造函数再一次的转换成对象，是一个全新的person5.say(); //由于上面又会将构造函数再一次的转换成一个全新的对象，所以这里打印的值依旧是 “ 1 ”。</code></pre><p>  <img src="https://s1.ax1x.com/2020/05/14/YDwos1.png"></p><h2 id="第二题、求字符串的长度"><a href="#第二题、求字符串的长度" class="headerlink" title="第二题、求字符串的长度"></a>第二题、求字符串的长度</h2><p>   第一种方法实现</p><pre><code>   function retbyteslen(target)&#123;    var count = target.length; //设定字符的长度    for(var i=0; i &lt;target.length;i++)&#123;        if(target.charCodeAt(i)&lt;=255)&#123;            count++; // 让字符的长度加一        &#125;else if(target.charCodeAt(i)&gt;255)&#123;            count+=2;  //如果是汉字的话加二        &#125;    &#125;    console.log(count);&#125;</code></pre><p>   <img src="https://s1.ax1x.com/2020/05/14/YD6vA1.png"></p><pre><code>function retbyteslen(target)&#123;    var count = target.length;    for(var i; i &lt;target.length;i++)&#123;        if(target.charCodeAt(i)&gt;255)&#123;            count++;        &#125;    &#125;    console.log(count);&#125;</code></pre><p>  <img src="https://s1.ax1x.com/2020/05/14/YD6TpT.png"></p><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>   以下表达式的结果为true(A C D)</p><pre><code>A、undefined == null; //这个两个类型，当undefined &lt; 0或者是undefined&gt;0或者是undefined=0，都是返回false ,然而当null&lt;0 或者是 null&gt;0 null=0 也都是返回false ,所以这时系统会认为这两个时相等的。B、undefined === null;//(三个等于号是绝对等于，就是完全一摸一样，像镜子找出来的一样)C、isNaN(&quot;100&quot;)D、parseInt(&quot;la&quot;)==1;</code></pre><h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2><p>   这是一题比较新颖的写法  </p><pre><code>function print()&#123;    bar.a = &#39;a&#39;;    Object.prototype.b = &#39;b&#39;;        return function inner()&#123;        console.log(bar.a);        console.log(bar.b);    &#125;&#125;prin()(); //第一个括号就是返回的一个函数，第二个括号是返回的那个函数执行   </code></pre><h2 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h2><p>  ** 浅度克隆**</p><pre><code>var test=&#123;    name : &quot;int&quot;,    sex: &quot;mlea&quot;,    age: 789&#125;var obj = &#123;&#125;function inherit(Origin,target)&#123;    var target = target||&#123;&#125;;    for(pro in test)    &#123;         target[pro]=Origin[pro] ;    &#125;    return target;&#125;inherit(test,obj);</code></pre><p> ** 深度克隆** </p><pre><code>遍历对象 for(var prop in obj)</code></pre><p>   步骤：<br>       1、判断是不是原始值 (方法：typeof() object)</p><pre><code>   2、判断是数组还是对象 （方法：instanceof toString constructor）一般不用instanceof和constructor会出现一些问题，但是有这三种方法去判断是数组还是对象   3、建立相应的数组或对象   4、递归   </code></pre><p>   代码：</p><pre><code>var test=&#123;    name : &quot;int&quot;,    sex: &quot;mlea&quot;,    age: 789,    card:[&#39;visa&#39;,&#39;unionpay&#39;]&#125;var obj = &#123;&#125;function deepclone(origin,target)&#123;  var  target = target||&#123;&#125;,       tostr = Object.prototype.toString,        arrstr =&quot;[object Arry]&quot;;        for(var prop in origin)        &#123;            if(origin.hasOwnProperty(prop))            &#123;               if(origin[prop] !=&quot;null&quot;&amp;&amp;typeof(origin[prop])==&#39;object&#39;)               &#123;                    if(tostr.call(origin[prop])==arrstr)                    &#123;                      target[prop]=[];                       &#125;else&#123;                      target[prop]=&#123;&#125;;                   &#125;                                         deepclone(origin[prop],target[prop]);//递归                                &#125;else                &#123;                  target[prop] = origin[prop];                &#125;               &#125;           &#125; return target;&#125;deepclone(test,obj);</code></pre><p>   <img src="https://s1.ax1x.com/2020/05/22/YX7Izt.png"></p><h2 id="第六题-区分typeof-里面的原始值和引用值"><a href="#第六题-区分typeof-里面的原始值和引用值" class="headerlink" title="第六题 区分typeof()里面的原始值和引用值"></a>第六题 区分typeof()里面的原始值和引用值</h2><pre><code>function typein(target)&#123;   var objtype = &#123;    &quot;[object Object]&quot; : &quot;object&quot;,    &quot;[object Array]&quot;  : &quot;array&quot;,    &quot;[object Number]&quot; : &quot;Number -object&quot;,    &quot;[object Boolean]&quot;: &quot;boolean - object&quot;,    &quot;[object String]&quot; : &quot;String - object&quot;  &#125;   if(target === null)&#123;    return &quot;null&quot;;  &#125;     if(typeof(target) == &quot;object&quot;)&#123;    var str = Object.prototype.toString.call (target); //取出对象里面的字符 ---&gt; 重点语句        return objtype[str];  &#125;else&#123;    return typeof(target);  &#125;&#125;</code></pre><p>  下面是简化代码</p><p>  <img src="https://s1.ax1x.com/2020/05/25/tp4Icn.png"></p><h2 id="第七题-数组去重，在原型链上写"><a href="#第七题-数组去重，在原型链上写" class="headerlink" title="第七题 数组去重，在原型链上写"></a>第七题 数组去重，在原型链上写</h2><pre><code>var arr= [1,1,2,2,5,5,6,6,8,8];Array.prototype.unique = function ()&#123;  var arr = [],obj = &#123;&#125;,len =this.length;  for(var i=0;i&lt;len;i++)&#123;    if(!obj[this[i]])&#123;      obj[this[i]] = &quot;abc&quot;;      arr.push(this[i]);    &#125;  &#125;  return arr;&#125;console.log(arr.unique());</code></pre><p>  <img src="https://s1.ax1x.com/2020/05/25/tpqkL9.png"></p><h2 id="第八题-封装一个函数，能够实现将新生成的标签插入原有标签的前面"><a href="#第八题-封装一个函数，能够实现将新生成的标签插入原有标签的前面" class="headerlink" title="第八题 封装一个函数，能够实现将新生成的标签插入原有标签的前面"></a>第八题 封装一个函数，能够实现将新生成的标签插入原有标签的前面</h2><p>   在原型链上编写</p><p>   HTML代码：</p><pre><code>   &lt;div&gt;        &lt;span&gt;&lt;/span&gt;        &lt;strong&gt;&lt;/strong&gt;        &lt;i&gt;&lt;/i&gt;        &lt;address&gt;&lt;/address&gt;    &lt;/div&gt;</code></pre><p>   JS代码：</p><pre><code>Element.prototype.inserAfter = function (targetNode,afterNode)&#123;        var beforeNode=afterNode.nextElementSibling;        if(beforeNode==null)&#123;            this.appendChild(targetNode)        &#125;else&#123;                    this.inserBefore(targetNode,beforeNode);        &#125;            &#125;    var div = document.getElementsByTagName(&quot;div&quot;)[0];    var strong = document.getElementsByTagName(&quot;strong&quot;)[0];    var span = document.getElementsByTagName(&quot;span&quot;)[0];          var p = document.createElement(&#39;p&#39;);</code></pre><h2 id="第九题"><a href="#第九题" class="headerlink" title="第九题"></a>第九题</h2><p>  下列说法错误的是（）</p><pre><code>A. call 和 apply 在参数中有区别，后者采用数组方式传参B. call函数执行会返回一个函数。C. 被bind后的函数this指向就确定了。D. call函数在执行的时候改变执行函数中的this指向。</code></pre><p>   这个题目中引用的知识点</p><p>   我们一开始需要先知道call，aplly,bind 是干嘛用的</p><p>   call,aplly。在函数执行的时候，改变this指向</p><p>   call 的参数形式arg1,arg2,arg3</p><p>   apply 参数形式 数组 （不定参数）</p><p>   call 基于apply函数进行封装的。</p><p>   a.call(this,a,b,c) =&gt;a.apply(this,[a,b,c])</p><p>   a.apply(this,[1,2,3]) ==&gt;a.call(this, ….[1,2,3])</p><h2 id="第十题"><a href="#第十题" class="headerlink" title="第十题"></a>第十题</h2><pre><code> function addToList(item,list)&#123;        return list.push(item);   &#125; var result = addToList(&quot;apple&quot;,[&quot;banana&quot;]);  console.log(result);</code></pre>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HEML+CSS+JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32 HAL驱动库函数总结</title>
    <link href="/2020/05/03/driver_code/"/>
    <url>/2020/05/03/driver_code/</url>
    
    <content type="html"><![CDATA[<h2 id="一、驱动文件说明"><a href="#一、驱动文件说明" class="headerlink" title="一、驱动文件说明"></a>一、驱动文件说明</h2><p>humidity and temperature (HTS221) 温湿度传感器</p><p>3D accelerometer and 3D magnetometer (lsm303agr) 3D加速度计和3D磁力仪</p><p>3D accelerometer and 3D gyroscope (LSM6DSL) 加速度，陀螺</p><p>260-1260 hPa absolute digital output barometer (LPS22HB) 气压计</p><h2 id="二、驱动代码下载"><a href="#二、驱动代码下载" class="headerlink" title="二、驱动代码下载"></a>二、驱动代码下载</h2><p><a href="https://pan.baidu.com/s/1WGmaVVaBxiWr2m8vsVtqZg">驱动代码自取地址</a></p><p>提取码：wpdn </p><h2 id="三、HTS221驱动函数理解"><a href="#三、HTS221驱动函数理解" class="headerlink" title="三、HTS221驱动函数理解"></a>三、HTS221驱动函数理解</h2><h3 id="整个HTS221温湿度获取设置函数"><a href="#整个HTS221温湿度获取设置函数" class="headerlink" title="整个HTS221温湿度获取设置函数"></a>整个HTS221温湿度获取设置函数</h3><p>注册总线IO口的传输协议函数</p><p>   <code>int32_t HTS221_RegisterBusIO(HTS221_Object_t *pObj, HTS221_IO_t *pIO)</code></p><p>传感器初始化函数</p><p>   <code>int32_t HTS221_Init(HTS221_Object_t *pObj)</code></p><p>取消传感器初始化函数</p><p>   <code>int32_t HTS221_DeInit(HTS221_Object_t *pObj)</code></p><p>读取设备的地址</p><p>   <code>int32_t HTS221_ReadID(HTS221_Object_t *pObj, uint8_t *Id)</code></p><p>获得HTS221传感器功能（指向HTS221传感器功能的指针）</p><p>   <code>int32_t HTS221_GetCapabilities(HTS221_Object_t *pObj, HTS221_Capabilities_t *Capabilities)</code></p><p>获取HTS221初始化状态（0代表初始化状态成功，1表示初始化状态不成功）</p><p>   <code>int32_t HTS221_Get_Init_Status(HTS221_Object_t *pObj, uint8_t *Status)</code></p><h3 id="获取湿度一系列函数"><a href="#获取湿度一系列函数" class="headerlink" title="获取湿度一系列函数"></a>获取湿度一系列函数</h3><p>启用HTS221湿度传感器 （0代表启动成功，1表示启动不成功）</p><p>   <code>int32_t HTS221_HUM_Enable(HTS221_Object_t *pObj)</code></p><p>关闭HTS221湿度传感器</p><p>   <code>int32_t HTS221_HUM_Disable(HTS221_Object_t *pObj)</code></p><p>获取HTS221湿度传感器输出数据率</p><p>   <code>int32_t HTS221_HUM_GetOutputDataRate(HTS221_Object_t *pObj, float *Odr)</code></p><p>设置HTS221湿度传感器输出数据速率</p><p>   <code>int32_t HTS221_HUM_SetOutputDataRate(HTS221_Object_t *pObj, float Odr)</code></p><p>获取HTS221湿度值</p><p>   <code>int32_t HTS221_HUM_GetHumidity(HTS221_Object_t *pObj, float *Value)</code></p><p>获取HTS221湿度数据就绪位值</p><p>   <code>int32_t HTS221_HUM_Get_DRDY_Status(HTS221_Object_t *pObj, uint8_t *Status)</code></p><h3 id="获取温度一系列函数"><a href="#获取温度一系列函数" class="headerlink" title="获取温度一系列函数"></a>获取温度一系列函数</h3><p>启用HTS221温度传感器获取温度 （0代表启动成功，1表示启动不成功）</p><p>   <code>int32_t HTS221_TEMP_Enable(HTS221_Object_t *pObj)</code></p><p>停止HTS221温度传感器获取温度</p><p>   <code>int32_t HTS221_TEMP_Disable(HTS221_Object_t *pObj)</code></p><p>获取HTS221温度传感器输出数据率</p><p>   <code>int32_t HTS221_TEMP_GetOutputDataRate(HTS221_Object_t *pObj, float *Odr)</code></p><p>设置HTS221温度传感器输出数据速率</p><p>   <code>int32_t HTS221_TEMP_SetOutputDataRate(HTS221_Object_t *pObj, float Odr)</code></p><p>获取HTS221温度值</p><p>   <code>int32_t HTS221_TEMP_GetTemperature(HTS221_Object_t *pObj, float *Value)</code></p><p>获取HTS221温度数据就绪位值</p><p>   <code>int32_t HTS221_TEMP_Get_DRDY_Status(HTS221_Object_t *pObj, uint8_t *Status)</code></p><p>获得HTS221一次性状态</p><p>   <code>int32_t HTS221_Get_One_Shot_Status(HTS221_Object_t *pObj, uint8_t *Status)</code></p><p>获取HTS221寄存器的值</p><p>   <code>int32_t HTS221_Read_Reg(HTS221_Object_t *pObj, uint8_t Reg, uint8_t *Data)</code></p><p>写入HTS221寄存器的值</p><p>   <code>int32_t HTS221_Write_Reg(HTS221_Object_t *pObj, uint8_t Reg, uint8_t Data)</code></p><p>获取输出数据速率</p><p>   <code>static int32_t HTS221_GetOutputDataRate(HTS221_Object_t *pObj, float *Odr)</code></p><p>设置输出数据速率</p><p>   <code>static int32_t HTS221_SetOutputDataRate(HTS221_Object_t *pObj, float Odr)</code></p><p>启用HTS221 DRDY中断模式</p><p>   <code>int32_t HTS221_Enable_DRDY_Interrupt(HTS221_Object_t *pObj)</code></p><p>用于应用系数的函数</p><p>   <code>static float Linear_Interpolation(lin_t *Lin, float Coeff)</code></p><p>将读寄存器组件函数包装成总线IO函数</p><p>   <code>static int32_t ReadRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)</code></p><p>写寄存器组件功能到总线IO功能</p><p>   <code>static int32_t WriteRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)</code></p><h2 id="四、LPS22HB驱动函数理解"><a href="#四、LPS22HB驱动函数理解" class="headerlink" title="四、LPS22HB驱动函数理解"></a>四、LPS22HB驱动函数理解</h2><p>   LPS22HB:测量大气压强的传感器</p><p>   LPS22HB基于HAL库的程序构成由外设芯片型号加上具体实现的气压（PRESS）和16位温度传感器（TEMP）操作构成，压力传感器和之前说明的HTS221的函数功能基本一样，这里不做具体讲解，可参考HTS221函数说明</p><p>   注意一点传感器和单片机是否通信正常，主要是通过读取WHO_AM_I确定读写是否正常的，所以在调试单片机程序时应当最先将这部分调试完成。</p><h2 id="五、LSM6DS驱动函数理解"><a href="#五、LSM6DS驱动函数理解" class="headerlink" title="五、LSM6DS驱动函数理解"></a>五、LSM6DS驱动函数理解</h2><p>   加速度计陀螺仪组合芯片LSM6DS</p><p>   加速度计陀螺仪测量芯片LSM6DS基于HALE库的程序设计功能的模型都是和HTS221温湿度的测量基本差不多的，这里需要特别注意测量加速度时会有以ACC（加速度）和 GYRO （陀螺仪）表明的函数名称需要加以识别</p><h2 id="六、lsm303agr驱动函数理解"><a href="#六、lsm303agr驱动函数理解" class="headerlink" title="六、lsm303agr驱动函数理解"></a>六、lsm303agr驱动函数理解</h2><p>  加速度和地磁芯片lsm303agr</p><p>  加速度和地磁芯片的基于HAL库的驱动函数构成名字及功能和之前所讲解的HTS221芯片基于HAL库的驱动程序基本差不多，这边可以参考HTS221的代码流程，这边主要注意一下ACC（加速度）和MAG（磁力计）两个数据的获取代码。</p>]]></content>
    
    
    <categories>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32 HAL驱动库函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电路开发软件 Fritzing 的使用</title>
    <link href="/2020/05/02/Fritzing/"/>
    <url>/2020/05/02/Fritzing/</url>
    
    <content type="html"><![CDATA[<h2 id="一、问题提出"><a href="#一、问题提出" class="headerlink" title="一、问题提出"></a>一、问题提出</h2><p>我们在开发硬件模块时经常需要画出实际电路板才能测试电路是否可行，这在开发时不仅消耗的具体成本和时间上都很大，那么有没有一款软件能够以实际电路为导向将物理模型预先测试好呢？找了许久才找到这么一款电路开发软件Fritzing软件。</p><h2 id="二、软件准备"><a href="#二、软件准备" class="headerlink" title="二、软件准备"></a>二、软件准备</h2><p>我把软件放到百度网盘上了，直接下载解压，运行打开Fritzing.exe就可以使用了</p><p><a href="https://pan.baidu.com/s/18629tJJowlElGbGH2UitOg">软件地址</a></p><p>  提取码：zepo</p><p><a href="https://pan.baidu.com/s/1FNmqcxKL8uNGGeZ8_HJMfQ">测试文件下载地址</a></p><p>  提取码：qyv2</p><h2 id="三、软件介绍"><a href="#三、软件介绍" class="headerlink" title="三、软件介绍"></a>三、软件介绍</h2><p><img src="https://s1.ax1x.com/2020/05/04/YP1Ce1.png"></p><p>1、菜单栏：一些软件基本功能查找设置的地方</p><p>2、快捷操作栏：可以任意切换到面包板，原理图和PCB的操作</p><p>3、主工作区：用于面包板、原理图和PCB的设计的地方</p><p>4、元件栏：用于我们常用元件放置的地方，我们需要用到的元件一般都可以在这地方找到，如果找不到还能外接添加库</p><p>5、提示栏：用于提示选择元件属性参数，类型的地方，也可用于选择的元件设置参数</p><h2 id="四、展示效果"><a href="#四、展示效果" class="headerlink" title="四、展示效果"></a>四、展示效果</h2><p><img src="https://s1.ax1x.com/2020/05/05/YkVlOx.png"></p>]]></content>
    
    
    <categories>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fritzing软件使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html和CSS易混淆知识点总结</title>
    <link href="/2020/05/01/Web/html+CSS%E6%80%BB%E7%BB%93/"/>
    <url>/2020/05/01/Web/html+CSS%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><strong>这些元素的行级块级都是通过CSS控制的，也都是可以通过CSS去改变</strong></p><p><strong>凡是带有inline的元素，都有文字特性</strong></p><h1 id="1、行级元素-inline"><a href="#1、行级元素-inline" class="headerlink" title="1、行级元素 # inline"></a>1、行级元素 # inline</h1><p>   feature : 内容决定元素所占位置</p><p>   不可以通过CSS改变宽高</p><p>  例如：span strong em a del</p><h1 id="2、块级元素-block"><a href="#2、块级元素-block" class="headerlink" title="2、块级元素 # block"></a>2、块级元素 # block</h1><p>   feature : 独占一行</p><p>   可以通过CSS改变宽高</p><p>  例如： div p ul ol form address</p><h1 id="3、行级块元素-inline-block"><a href="#3、行级块元素-inline-block" class="headerlink" title="3、行级块元素 # inline-block"></a>3、行级块元素 # inline-block</h1><p>   feature : 内容决定大小</p><p>   可以改变宽高</p><h1 id="多个图片无空格占一行显示解决办法"><a href="#多个图片无空格占一行显示解决办法" class="headerlink" title="多个图片无空格占一行显示解决办法"></a>多个图片无空格占一行显示解决办法</h1><p>   添加一条CSS语句<br>          margin-left:-6px;<br>   用margin-left 去解决 </p><h1 id="display-inline-block，block，inline的区别与用法"><a href="#display-inline-block，block，inline的区别与用法" class="headerlink" title="display:inline-block，block，inline的区别与用法"></a>display:inline-block，block，inline的区别与用法</h1><p>  首先要了解一下什么是块级元素与什么是行级元素</p><h3 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h3><p>   <strong>会占领页面一行</strong>，其后多个block元素自动换行、<strong>可以设置width,height,设置了width后同样也占领一行</strong>、同样也可以设置margin与padding属性。</p><p>   <strong>常见的块级元素：div,img,ul,form,p</strong></p><h3 id="行级元素"><a href="#行级元素" class="headerlink" title="行级元素"></a>行级元素</h3><p>   <strong>与其他元素在同一行上</strong>，<strong>高度，行高以及底边距不可以改变</strong>，高度就是内容文字或者图片的宽度，不可以改变。</p><p>   <strong>常见的行级元素：em,strong,br,input</strong></p><h3 id="display-inline-block，block，inline的区别"><a href="#display-inline-block，block，inline的区别" class="headerlink" title="display:inline-block，block，inline的区别"></a>display:inline-block，block，inline的区别</h3><p>  1、display:block将元素显示为块级元素，<strong>从而可以更好地操控元素的的宽高，以及内外边距，每一个块级元素都是从新的一行开始的</strong>。</p><p>  2、display:inline将元素显示为<strong>行内元素，高度，行高及底边距不可改变</strong>，高度就是内容文字或者图片的宽度，不可以改变。多个相邻的行内元素排在同一行里，<strong>知道页面一行排列不下。才会换新的一行。</strong></p><p>  3、display:inline-block 看上去值名inline-block是一个混合产物，实际上确是如此，将元素显示为行内块状元素，设置该属性后，<strong>其他的行内块元素会排列在同一行</strong>。比如我们” li “元素是一个inline-block,使其既有block的宽度高度特性，又有inline的同行特性，在同一行内有不同高度内容元素时，通常要设置对齐方式如 **vertical-align:top; **来是元素顶部对齐。  </p>]]></content>
    
    
    <categories>
      
      <category>HTML+CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS重点知识点笔记详情</title>
    <link href="/2020/05/01/Web/htmlcss%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    <url>/2020/05/01/Web/htmlcss%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="设置字体"><a href="#设置字体" class="headerlink" title="设置字体"></a>设置字体</h1><p>浏览器默认的字体大小是16px，我们一般使用的字体大小是12px和14px，一般很少使用16px</p><p>设置字体的大小，其实是设置的字体的高</p><p>常用字体是arial</p><p>对于中文字体，cursive 这个字体还是比较好看的</p><p>   <strong>字体代码如下</strong></p><pre><code>font-size: 81px;font-weight: 600;font-style: normal;font-family: arial;color: #fff000;border: 1px solid black /*复合属性 */</code></pre><p>border是给div加上外边框的，叫做盒子，第一个值是定义元素边框厚度，第二个值是定义元素边框样式，第三个值是颜色</p><h2 id="三种设置字体颜色方法"><a href="#三种设置字体颜色方法" class="headerlink" title="三种设置字体颜色方法"></a>三种设置字体颜色方法</h2><p>1、土鳖式 （纯英文单词）color:green; (一般很少使用这种方法)</p><p>2、颜色代码  color ：#ff5500 (一般使用这种方法，用的比较多)</p><p>3、颜色函数  color :rgb(255,255,255)</p><p>透明色 ：transparent</p><h2 id="设置三角形代码"><a href="#设置三角形代码" class="headerlink" title="设置三角形代码"></a>设置三角形代码</h2><pre><code>font-size: 0px;font-weight: 10;font-style: normal;font-family: cursive;color: #030;width: 0px;height: 0px;border: 100px solid red; border-left-color:#029; border-top-color: transparent; border-bottom-color: transparent; border-right-color: transparent;</code></pre><h1 id="文本居中方式"><a href="#文本居中方式" class="headerlink" title="文本居中方式"></a>文本居中方式</h1><p>   代码格式</p><pre><code>   text-align: center;</code></pre><h2 id="文字在盒子里如何垂直居中"><a href="#文字在盒子里如何垂直居中" class="headerlink" title="文字在盒子里如何垂直居中"></a>文字在盒子里如何垂直居中</h2><p>  文本高度j等于**  line-height  **</p><pre><code>border: 10px solid #069;text-align: center; /*对齐方式*/height: 20px;line-height: 20px;text-indent: 2em /*文本缩进*/text-decoration: underline;  /*文本装饰标识符、设置下划线*/</code></pre><p>em 和px都是相对单位 em相对于总的文本缩进的字符数</p><p>1em = 1 font-size; = 16px</p><p>1em = 16px;</p><h1 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h1><p><strong>鼠标放上去之后能够显示的效果，然后但鼠标移除时恢复原来的状态，就是伪类选择器</strong></p><pre><code>   a:hover&#123;           background-color: turquoise;        &#125;</code></pre><p>在标签选择器后面添加”:hover”，就可以变成伪类选择器</p><h1 id="盒模型、层模型、浮动模型"><a href="#盒模型、层模型、浮动模型" class="headerlink" title="盒模型、层模型、浮动模型"></a>盒模型、层模型、浮动模型</h1><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>   <strong>是针对html的每一个元素的，每一个元素都可以叫做盒子</strong></p><h3 id="盒子三大部分"><a href="#盒子三大部分" class="headerlink" title="盒子三大部分"></a>盒子三大部分</h3><p>  1、盒子壁 border</p><p>  2、内边距 padding</p><p>  3、盒子内容 width + height</p><p>  <img src="https://s1.ax1x.com/2020/05/02/JxE51e.png"></p><p>  <img src="https://s1.ax1x.com/2020/05/02/JxEx1g.png"></p><p>  四个值的话，分别代表上右下左</p><p>  外边距 margin</p><h3 id="盒子模型应用"><a href="#盒子模型应用" class="headerlink" title="盒子模型应用"></a>盒子模型应用</h3><p>  远视图画法</p><h2 id="定位技术"><a href="#定位技术" class="headerlink" title="定位技术"></a>定位技术</h2><p>  定位： position</p><p>  绝对定位: absolute</p><p>  <strong>在第几层用 z-index: 1;属性进行设置，1就是第一层</strong></p><p>  需要给定位距离距离上边和左边的大小的大小</p><p>  <img src="https://s1.ax1x.com/2020/05/02/JxuemQ.png"></p><p>  <strong>body这个标签有一个最开始外边距为8px，所以一般初始化时会把这个标签的外边距设置为零</strong></p><p>  absolute 绝对定位脱离原来的位置进行定位，每一个都是一个新的层</p><p>  <strong>绝对定位重要解释：相对于最近的有定位的父级进行定位，如果没有，那么相对于文档进行定位</strong></p><p>  relative 保留原来位置进行定位，在原来的基础上进行定位，相对自己原来的位置进行定位</p><p>  <strong>用relative进行参照物，不用relative进行定位，用absolute进行定位</strong></p><p>  <img src="https://s1.ax1x.com/2020/05/02/Jx1Cxx.png"></p><h3 id="固定定位也要配合left、top元素进行使用"><a href="#固定定位也要配合left、top元素进行使用" class="headerlink" title="固定定位也要配合left、top元素进行使用"></a>固定定位也要配合left、top元素进行使用</h3><pre><code> position:fixed; //在网页的一个地方静止不动</code></pre><p>  <img src="https://s1.ax1x.com/2020/05/02/Jx1yo4.png"></p><h3 id="一个元素不管网页如何变化都是居中的写法"><a href="#一个元素不管网页如何变化都是居中的写法" class="headerlink" title="一个元素不管网页如何变化都是居中的写法"></a>一个元素不管网页如何变化都是居中的写法</h3><pre><code> position:absolute; left:%50; top:%50; margin-left:-50px; margin-top:-50;</code></pre><p> <img src="https://s1.ax1x.com/2020/05/02/Jx8Sjx.png"></p><h3 id="如何画圆角"><a href="#如何画圆角" class="headerlink" title="如何画圆角"></a>如何画圆角</h3><pre><code> width: 100px; height: 100px; border: 10px solid red; border-radius: 50%;</code></pre><h2 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h2><p>  左一个右一个（让两个块级元素共一行显示）</p><p>  得是真正的两栏布局，而不能是一个块级元素压住另一个块级元素</p><p>  <img src="https://s1.ax1x.com/2020/05/03/YpZ5Ed.png"></p><h2 id="BUG解决"><a href="#BUG解决" class="headerlink" title="BUG解决"></a>BUG解决</h2><p>  问题：父子块级元素，当设置子元素相对于父元素顶部距离不能实现设置</p><p>  <img src="https://s1.ax1x.com/2020/05/03/Ypufzt.png"></p><p>  解决办法（bfc）</p><p>  如何触发一个盒子的BFC</p><p>  触发代码：</p><pre><code>   第一种方法： position:absolute;   第二种方法： display:inline-block;   第三种方法： float: left/right;   第四种方法： overflow: hidden;//溢出盒子的部分要隐藏展示    改变大盒子的渲染规则</code></pre><p>  <img src="https://s1.ax1x.com/2020/05/05/Yka7sx.png"></p><h2 id="浮动模型"><a href="#浮动模型" class="headerlink" title="浮动模型"></a>浮动模型</h2><p>  <strong>浮动元素产生了浮动流对后面的元素的影响不一</strong></p><p>  <strong>所有产生了浮动流的元素，块级元素看不到他们的存在，所以就产生了分层。</strong></p><p>  块级元素看不到浮动元素的测试代码<br>  <img src="https://s1.ax1x.com/2020/05/05/YkdLXq.png"></p><p>  看不到浮动元素的分层效果</p><p>  <img src="https://s1.ax1x.com/2020/05/05/YkwK9H.png"></p><p>  <strong>产生bfc的元素和文本类属性（inline）的元素以及文本都能看到浮动元素。</strong></p><p>  <strong>只有块级才看不到浮动元素</strong></p><p>   父级包含子级浮动流元素解决办法（俗称包裹元素）<br>     clear:both(both将两边的浮动流一块清除，只有一个作用清除浮动流)（加了一个结构，不好用）</p><p>  <img src="https://s1.ax1x.com/2020/05/05/Yk0Wo8.png"></p><p>  ** 伪元素天生就存在html标签语句上，我们需要用的话就可以通过CSS将其选中伪元素，就可以通过CSS属性将其里面的内容修改。**</p><p>  ** 伪元素天生就是行级元素，如果要做块级元素使用，就必须加上语句：（也是行级元素变成块级元素的方法）**   </p><pre><code>    display: inline-block;</code></pre><p>  <img src="https://s1.ax1x.com/2020/05/06/YEx3Us.png"></p><p>  <strong>用完浮动流，记得清除，变成原始的行内元素</strong></p><p>  清除浮动流三要素</p><pre><code>   content:&quot;&quot;;   display:block; //行内元素   clear:both;</code></pre><p>  <img src="https://s1.ax1x.com/2020/05/07/YZN9w6.png"></p><h2 id="伪元素用法"><a href="#伪元素用法" class="headerlink" title="伪元素用法"></a>伪元素用法</h2><h3 id="伪元素-before-和-after-这两个伪元素的用法"><a href="#伪元素-before-和-after-这两个伪元素的用法" class="headerlink" title="伪元素 ::before 和 ::after 这两个伪元素的用法"></a>伪元素 ::before 和 ::after 这两个伪元素的用法</h3><p> ** 为什么叫伪元素：他的元素结构是存在，但是他又没有写在html里面**</p><p>  <strong>::before没有html结构,但可以通过CSS来正常操作（可以当元素来正常操作）</strong></p><p>  伪元素在最开始设计时就存在，只是我们通过CSS来选中进行了操作</p><p>  content:””;可以修改伪元素里面的内容（只能用在伪元素中）</p><p>  <strong>伪元素就是行级元素，如果要设置宽高之类的就必须改成块级元素或者是行级块元素</strong></p><p>  <img src="https://s1.ax1x.com/2020/05/07/Ymf2hF.png"></p><h3 id="利用伪元素来清除浮动"><a href="#利用伪元素来清除浮动" class="headerlink" title="利用伪元素来清除浮动"></a>利用伪元素来清除浮动</h3><p>   利用伪元素来清除浮动只需修改CSS语句就行</p><p>  ** 能清除浮动的必须是块级元素，所以得将其设置为块元素，得添加display-block变成块级元素才能清除**</p><p>   <img src="https://s1.ax1x.com/2020/05/06/YEzuJ1.png"></p><p>   设置了position:abolute;  float:left/right;</p><p>   这两个属性会打内部把元素转换成inline-black 行级块元素</p><p> <strong>lsit-style:none;控制原点的，可以将自定义序列前面的原点去除</strong></p><h2 id="单行文本溢出打点方法"><a href="#单行文本溢出打点方法" class="headerlink" title="单行文本溢出打点方法"></a>单行文本溢出打点方法</h2><p>  ** 先让文本失去换行的功能 **</p><pre><code>   white-space: nowrap;</code></pre><p>  ** 溢出部分隐藏**</p><pre><code>   overflow: hidden;</code></pre><p>  ** 溢出部分用点点点显示**</p><pre><code>   text-overflow:ellipsis;</code></pre><h2 id="特殊点"><a href="#特殊点" class="headerlink" title="特殊点"></a>特殊点</h2><p>   行级元素只能嵌套行级元素<br>   块级元素可以嵌套任何元素</p><pre><code>   例如：div里面可以套任何东西   span里面只能套行级元素</code></pre><p> ** 特殊 “p”(这是块级元素)标签里面不能套块级元素，套完就会被截断**</p><p>  ** a标签里面不能套a标签** 写了都不知到跳转哪一个</p><h1 id="内容区不会随着网页缩小而改变办法"><a href="#内容区不会随着网页缩小而改变办法" class="headerlink" title="内容区不会随着网页缩小而改变办法"></a>内容区不会随着网页缩小而改变办法</h1><p>   内容区的外边距自适应就可以解决这个问题了</p><p>   <img src="https://s1.ax1x.com/2020/05/07/YmlPHS.png"></p><h1 id="文字属性的问题"><a href="#文字属性的问题" class="headerlink" title="文字属性的问题"></a>文字属性的问题</h1><p>  行级元素</p><pre><code>   inline block</code></pre><p>  行级块元素</p><pre><code>   inline-block -----文本类元素</code></pre><p>  凡是带有inline属性的元素都有文本类特点</p><p>  img 也是文本类属性，当多个图片在一行是就会有文字分隔符将多个图片中间隔开一定的距离</p><p> ** 解决办法：将图片之间的空格去了就可以了**</p><p>  <img src="https://s1.ax1x.com/2020/05/07/Ym1JIg.png"></p><h1 id="内部原理"><a href="#内部原理" class="headerlink" title="内部原理"></a>内部原理</h1><p>  当我们用行级元素span去写网页时，当设置span的宽高时发现不能设置，但当我们添加上   position: absolute;  float: left/right; 这两条语句的其中一个时惊奇的发现可以设置了。</p><p>  原因讲解：<br>     因为span是行级元素，不能设置宽高。但当设置了position: absolute;  float: left/right;这两条属性的其中一个时，浏览器就会自动将行级元素转换成行级块元素，然后我们就可以设置行级元素的宽高了</p><p> 添加浮动元素时就会将行级元素转换成块级元素</p><p>  <img src="https://s1.ax1x.com/2020/05/07/Ym3wfH.png"></p><h1 id="底对齐问题"><a href="#底对齐问题" class="headerlink" title="底对齐问题"></a>底对齐问题</h1><p>  当一个行级块元素或者是文本类元素，里面添加文字时外面的文字就会和里面的文字底对齐到最上面。</p><p>  <img src="https://s1.ax1x.com/2020/05/07/YmttiT.png"></p><p>  position: absolute;  float: left/right; 这两条元素在浏览器执行时会转变成行级块元素，问题来了同样是行级块元素，但position: absolute;  float: left/right;这两条语句添加上去是就会在第一行显示，但当 display: inline-block;添加上去时就会是和边框底对齐，原因是position: absolute;  float: left/right;这两条语句是浮动元素，浮动元素看不到块级元素，所以就会自然而然的显示在第一行，但display: inline-block;不是浮动元素就会显示底对齐了，所以用display: inline-block;这个属性时，标签里面添加文字，就会一起在第一行对齐了。</p><h1 id="调一行元素的对齐线"><a href="#调一行元素的对齐线" class="headerlink" title="调一行元素的对齐线"></a>调一行元素的对齐线</h1><pre><code>     vertical-align: -20%;</code></pre><p>   <img src="https://s1.ax1x.com/2020/05/07/YmNON6.png"></p><h1 id="两个容器在一个大的容器里面左右浮动"><a href="#两个容器在一个大的容器里面左右浮动" class="headerlink" title="两个容器在一个大的容器里面左右浮动"></a>两个容器在一个大的容器里面左右浮动</h1><pre><code> &lt;div&gt;     &lt;!-- 一个大容器里面包裹两个ul --&gt;    &lt;ul&gt;&lt;/ul&gt;     &lt;!-- 一个左浮动 --&gt;    &lt;ul&gt;&lt;/ul&gt;    &lt;!-- 一个有浮动 --&gt; &lt;/div&gt;</code></pre><h1 id="input是行快元素可以设置宽高"><a href="#input是行快元素可以设置宽高" class="headerlink" title="input是行快元素可以设置宽高"></a>input是行快元素可以设置宽高</h1>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS选择器知识点总结</title>
    <link href="/2020/04/30/Web/CSS%E9%80%89%E6%8B%A9%E5%99%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/04/30/Web/CSS%E9%80%89%E6%8B%A9%E5%99%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS-cascading-style-sheet-层叠样式表"><a href="#CSS-cascading-style-sheet-层叠样式表" class="headerlink" title="CSS cascading style sheet 层叠样式表"></a>CSS cascading style sheet 层叠样式表</h1><p>  一、引入CSS</p><p>  1、行间样式</p><pre><code> &lt;div  style=&quot;width:100px;height:100px;&quot;&gt;  123  &lt;/div&gt;</code></pre><p>  2、页面级CSS</p><pre><code>   &lt;style type=&quot;text/css&quot;&gt;      &lt;/style&gt;</code></pre><p>  3、外部CSS文件</p><p>   建立一个新CSS的文件</p><p>  用下面link这条语句链接<br>      <link rel="stylesheet" type="text/css" href="文件地址"></p><p>  用id的方式连接样式</p><p>  域名通过dns解析成网址访问 </p><pre><code> www.baidu.com---- dns ----182.168.00.01</code></pre><h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><p>!important （每一个选择器后面都可以添加这个特定的属性选择器）</p><p>1、id选择器 #demo{}</p><p>2、class选择器 .demo{}</p><p>3、标签选择器（一选择就是选择所有的标签，主要作用就是初始化原始标签）标签 {<br>}</p><p>4、属性选择器 [id] 或者是[class]</p><p>5、通配符选择器（主要作用就是初始化所有标签，减去不需要的属性，自定义自己需要的属性）</p><p>优先级： !important&gt;行间样式&gt;1|4&gt;2&gt;3&gt;5</p><p><strong>class选择器和属性选择器是同一级</strong></p><p>特定的属性选择器，在特定的样式后面添加 !important<br>这样整个特定的属性样式的优先级就是最高的</p><p><img src="https://s1.ax1x.com/2020/04/30/JL35I1.png"></p><h1 id="CSS权重"><a href="#CSS权重" class="headerlink" title="CSS权重"></a>CSS权重</h1><p>！important         Infinity 正无穷<br>行间样式             1000<br>id                   100<br>class|属性|伪类        10<br>标签|伪元素            1<br>通配符                 0</p><p>这个是256进制计算的</p><p>   <strong>在计算机里面正无穷加1就比正无穷大</strong></p><p>  ** 权重更有利于做些不同状态的效果展示**</p><p>   只要写在同一排的选择器，只需要将权重值相加就行了</p><h1 id="父子选择器-派生选择器"><a href="#父子选择器-派生选择器" class="headerlink" title="父子选择器/派生选择器"></a>父子选择器/派生选择器</h1><p>   重要：父子选择器内部原理是从右向左依次查找的，这样能够节省查找到目标的时间。</p><p>  1、一层套一层，每一个层级用空格隔开就好了</p><p>  <strong>2、父子选择器不在于单一的一种选择器写，只要父子关系成立选择器可以用不同的也能达到相同的效果</strong><br>  <img src="https://s1.ax1x.com/2020/04/30/JLYfl6.png"></p><p>  <img src="https://s1.ax1x.com/2020/04/30/JLtMN9.png"></p><p>  <strong>这个1和2都会变色</strong><br>  <img src="https://s1.ax1x.com/2020/04/30/JLNKr8.png"></p><p>  <strong>这个只有1变色</strong><br>  <img src="https://s1.ax1x.com/2020/04/30/JLNoid.png"></p><h1 id="直接子元素选择器"><a href="#直接子元素选择器" class="headerlink" title="直接子元素选择器"></a>直接子元素选择器</h1><p>   如果这里我们需要选择1变色，那我们就可以用直接子元素选择器</p><p> html代码<br>    <div><br>      <em> 1</em></p><pre><code>   &lt;strong&gt;     &lt;em&gt;2&lt;/em&gt;   &lt;/strong&gt;&lt;/div&gt;</code></pre><p> CSS代码</p><pre><code>div &gt; em &#123;background-color: antiquewhite;&#125;</code></pre><p>   <img src="https://s1.ax1x.com/2020/04/30/JLd3Ie.png"></p><h1 id="并列选择器"><a href="#并列选择器" class="headerlink" title="并列选择器"></a>并列选择器</h1><p> html代码：</p><pre><code>   &lt;div&gt;1&lt;/div&gt;  &lt;div class=&quot;demo&quot;&gt;2&lt;/div&gt;  &lt;p class=&quot;demo&quot;&gt;3&lt;/p&gt;</code></pre><p> CSS代码</p><pre><code> div.demo &#123;background-color: antiquewhite;&#125;</code></pre><p>   缩减范围<br>   用一个标签选择器在加上一个类选择器就能够最大限度的缩减范围选择到需要的那个内容</p><h1 id="权重判断多个选择器选择同一个属性时的方法"><a href="#权重判断多个选择器选择同一个属性时的方法" class="headerlink" title="权重判断多个选择器选择同一个属性时的方法"></a>权重判断多个选择器选择同一个属性时的方法</h1><p>   <strong>只要写在同一排的选择器，只需要将权重值相加就行了</strong></p><p>   <img src="https://s1.ax1x.com/2020/05/01/JOrlWD.png"></p><p>   <strong>当权重值相等的时候，后面的代码会覆盖前面的代码</strong></p><p>   <img src="https://s1.ax1x.com/2020/05/01/JOsnXj.png"></p><p>   将权重值相加就可以判断同一排选择器的大小</p><h1 id="分组选择器"><a href="#分组选择器" class="headerlink" title="分组选择器"></a>分组选择器</h1><p><strong>分组选择器就是改变代码耦合度高的情况</strong></p><p>  当多个选择器需要共用同一个代码块的时候，就可以用这个分组选择器，用逗号隔开，就是分开的组，就可以让多个标签共用同一段代码，避免耦合度高的代码。<br>  <img src="https://s1.ax1x.com/2020/05/01/JOyoZR.png"></p><p>  <strong>一般在写代码的时候用的是下面种分组方式，更易于辨识</strong></p><p>  <img src="https://s1.ax1x.com/2020/05/01/JO6VyQ.png"></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTML重点知识点总结</title>
    <link href="/2020/04/29/Web/html%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/04/29/Web/html%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>  &nbsp; 空格</p><p>  &lt;  小于号</p><p>  &gt;  大于号</p><h1 id="html-hyperText-markup-language"><a href="#html-hyperText-markup-language" class="headerlink" title="html (hyperText markup language)"></a>html (hyperText markup language)</h1><p>unicode 万国码（所有国家的语言都包括）</p><p>utf-8 现在常用的万国码</p><p>html语言的构成</p><html lang="en"><head>   <meta charset="UTF-8">   title<p>&lt;\head&gt; 思想类东西编辑器用的，用户看不到</p><body><body> 展现给用户看的<\html> 根标签<p>lang=”en” 告诉搜索引擎爬虫，我们的网站是关于什么内容的，这里的意思是告诉搜索引擎是英文内容的网站，利于抓取</p><p>每一个标签都可以添加属性，每一个属性代表不同的功能（必须添加在头标签）</p><p>属性值必须用双引号引用起来</p><p>style=”风格设计”</p><p>属性名用一个等号连接一个属性值，在双引号里面添加一个属性值</p><h1 id="P标签的作用是成段显示"><a href="#P标签的作用是成段显示" class="headerlink" title="P标签的作用是成段显示"></a>P标签的作用是成段显示</h1><pre><code> &lt;p&gt;     &lt;\p&gt;</code></pre><h1 id="H1-H6标题标签"><a href="#H1-H6标题标签" class="headerlink" title="H1~H6标题标签#"></a>H1~H6标题标签#</h1><pre><code> h$&#123;名称&#125;*6 （快速生成六个标签） &lt;h1&gt;标题&lt;/h1&gt;  &lt;h2&gt;标题&lt;/h2&gt; &lt;h3&gt;标题&lt;/h3&gt; &lt;h4&gt;标题&lt;/h4&gt; &lt;h5&gt;标题&lt;/h5&gt; &lt;h6&gt;标题&lt;/h6&gt;</code></pre><h1 id="strong-加粗标签"><a href="#strong-加粗标签" class="headerlink" title="strong 加粗标签"></a>strong 加粗标签</h1><p>  <strong> 加粗</strong></p><h1 id="em斜体标签"><a href="#em斜体标签" class="headerlink" title="em斜体标签"></a>em斜体标签</h1><p>   <em>斜体</em></p><h1 id="del有中划线的标签"><a href="#del有中划线的标签" class="headerlink" title="del有中划线的标签"></a>del有中划线的标签</h1><h1 id="address地址标签"><a href="#address地址标签" class="headerlink" title="address地址标签"></a>address地址标签</h1><pre><code> &lt;address&gt; &lt;/address&gt;</code></pre><h1 id="div"><a href="#div" class="headerlink" title="div"></a>div</h1><pre><code> &lt;div&gt;&lt;/div&gt;</code></pre><h1 id="span"><a href="#span" class="headerlink" title="span"></a>span</h1><pre><code> &lt;span&gt; &lt;/span&gt;</code></pre><p>有容器可以绑定操作，更加方便，在操作时只需操作容器就好了</p><p>div、span 作用：分块明确，充当容器的作用让功能更加结构化</p><h1 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h1><pre><code>   &lt;ol //列表架      type=&quot;1&quot;  //按什么序列增加      reversed=&quot;reversed&quot; //倒序      start=&quot;3&quot;  //可以从哪一个数字开始增加或者是减小        &gt;             &lt;li&gt;一个&lt;/li&gt;      &lt;li&gt;两个&lt;/li&gt;      &lt;li&gt;三个&lt;/li&gt;      &lt;li&gt;四个&lt;/li&gt;      &lt;li&gt;五个&lt;/li&gt;      &lt;li&gt;六个&lt;/li&gt;      &lt;li&gt;七个&lt;/li&gt;         &lt;/ol&gt;</code></pre><h1 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表#"></a>无序列表#</h1><pre><code>## 使用的 ##&lt;ul&gt;   &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre><h1 id="图片引用处理"><a href="#图片引用处理" class="headerlink" title="图片引用处理"></a>图片引用处理</h1><pre><code>   &lt;img src=&quot;&quot; //添加的是图片的资源地址&gt;scr 是scorce的意思是资源   &lt;img src=&quot;&quot; style=&quot;风格设计&quot; alt=&quot;可是添加文字用来调试图片是否正确展示，展示文字信息&quot;&gt;</code></pre><p>   alt 图片占位符<br>   title 图片提示符</p><p>  等号后面添加的有下面几种情况<br>  1、网上的url<br>  2、本地的绝对路径<br>  3、本地的相对路径</p><h1 id="a标签的作用（超链接）"><a href="#a标签的作用（超链接）" class="headerlink" title="a标签的作用（超链接）"></a>a标签的作用（超链接）</h1><pre><code>   &lt;a href=&quot;https://www.baidu.com（给浏览器用的）&quot;  target=&quot;_blank&quot;&gt;百度一下（给人用的）     这里面的内容可以是任意形式   图片   CSS   文字   这些都是可以放到这里里面的   &lt;\a&gt;href ----&gt;hyperText reference(超文本引用的意思，添加的是你指向的所在地址)</code></pre><p>   还可以放 “target” 是目标的意思，添加这个标识符就可以设置超文本链接在新的标签页中打开，如果你不想在新的标签页中打开就可以不用添加。</p><p>   target=”_blank”等号后面的双引号添加的值是一个空值</p><p>   a标签的作用<br>    1、超链接<br>    2、锚点 id=deng &lt;a href=”#deng” </a><br>    3、打电话  <a href="tel:电话号码">给谁打电话 </a><br>    4、协议限定符  <a href="javascript">可以添加javascript代码</a></p><p>   “a”是英文anchor的英文缩写 意思是锚</p><p>   style意思是类型风格，可以设置类型风格</p><h1 id="form-表单标签"><a href="#form-表单标签" class="headerlink" title="form 表单标签"></a>form 表单标签</h1><p>  可以发送数据，可以将前端数据发送给后端数据</p><pre><code>  &lt;form method=&quot;get&quot; action=&quot;&quot; &gt;    &lt;input: type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot;&gt; 账号   &lt;input: type=&quot;password&quot; name=&quot;password&quot; value=&quot;&quot;&gt; 密码      &lt;input: type=&quot;submit&quot;&gt; 提交数据（提交到后端数据）   &lt;input: type=&quot;radio&quot; name=&quot;将单选框统一到同一道选择题&quot; value=&quot;数据值&quot;&gt; 单选框（必须统一到同一道题用name）</code></pre><p>   提交的数据必须要有数据名和数据值<br>   username 这个数据名（用户在这个框子里面填写的名字就是数据值）<br>   password 这个数据名（用户在这个框子里面填写的密码就是数据值）<br>   &lt;\form&gt;</p><p>  method=”get” 获取的数据</p><p>  action=”” 发送给谁的地址</p><p>  value=”” 属性值</p><p>  复选框（checkbox）</p><p>  把type=”checkbox”的值改成checkbox就可以变成复选框</p><p>  默认选中给用户提供很大的体验</p><p>  checked=”checked”默认选中</p><p>  默认选中例程:<br>      male:<input type="radio" name="sex" value="male" checked="checked"></p><pre><code>  female:&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot; checked=&quot;checked&quot;&gt;</code></pre><h1 id="select-下拉菜单"><a href="#select-下拉菜单" class="headerlink" title="select 下拉菜单"></a>select 下拉菜单</h1><pre><code>&lt;select name=&quot;&quot; id=&quot;&quot;&gt; &lt;option &gt;北京&lt;/option&gt; &lt;option &gt;天津&lt;/option&gt;&lt;/select&gt;</code></pre>   <option > 是一个天然的数据值，可以直接用<p>   也可以添加value=””，这个时候提交的就是value里面的数据值</p><p>  我们还得在select添加数据名这样就可以提交数据了</p>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>串口接收数据可视化</title>
    <link href="/2020/04/27/UARTvisual/"/>
    <url>/2020/04/27/UARTvisual/</url>
    
    <content type="html"><![CDATA[<h2 id="一、问题提出"><a href="#一、问题提出" class="headerlink" title="一、问题提出"></a>一、问题提出</h2><p>数据图形化有利于让数据更加直观，那么我们如何才能让单片机发送出来的数据图形化显示呢？暂且听我慢慢道来！</p><h2 id="二、实验现象"><a href="#二、实验现象" class="headerlink" title="二、实验现象"></a>二、实验现象</h2><p><img src="https://s1.ax1x.com/2020/04/27/Jf2vSP.gif"></p><h2 id="三、实验准备"><a href="#三、实验准备" class="headerlink" title="三、实验准备"></a>三、实验准备</h2><p>1.<a href="http://www.starlino.com/serialchart">Serial Chart软件下载</a></p><p>2.<a href="https://github.com/starlino/serialchart">Serial Chart官方配置资料</a></p><h2 id="四、实验步骤"><a href="#四、实验步骤" class="headerlink" title="四、实验步骤"></a>四、实验步骤</h2><p>1、实验板下载好单片机串口发送数据程序（使用的是<a href="https://liloong.gitee.io/2020/04/20/STM32/">基于STM32Cube HaL库串口中断函数回显字符串的使用</a>中的代码，实现接收数据可视化）</p><p>2、配置Serial Chart软件串口参数及界面参数</p><p>3、开启图形化界面显示图形</p><h2 id="五、Serial-Chart软件配置说明"><a href="#五、Serial-Chart软件配置说明" class="headerlink" title="五、Serial Chart软件配置说明"></a>五、Serial Chart软件配置说明</h2><h3 id="1、Serial-Chart软件界面介绍"><a href="#1、Serial-Chart软件界面介绍" class="headerlink" title="1、Serial Chart软件界面介绍"></a>1、Serial Chart软件界面介绍</h3><p><img src="https://s1.ax1x.com/2020/04/27/JfDUc4.png"></p><h3 id="2、我的配置文件"><a href="#2、我的配置文件" class="headerlink" title="2、我的配置文件"></a>2、我的配置文件</h3><pre><code>[_setup_]port=COM7baudrate=115200width=13500height=2000background_color = transparentgrid_h_origin = 100grid_h_step = 20grid_h_color = limegrid_h_origin_color = limegrid_v_origin = 100grid_v_step = 20grid_v_color = limegrid_v_origin_color = lime[_default_]min=0max=100[Field1]color=red</code></pre><h3 id="3、我的配置文件说明"><a href="#3、我的配置文件说明" class="headerlink" title="3、我的配置文件说明"></a>3、我的配置文件说明</h3><pre><code>[_setup_]  //每个配置文件由此部分开始port=COM7 //这就是软件进行串口通讯的接口啦，比如COM1，COM2.baudrate=115200 /波特率，目前只支持以下几种波特率：110,300,600,1200,2400,9600,19200,38400,57600,115200.width=13500  //chart区域的像素宽度height=2000  //chart区域的像素高度background_color = transparent  //chart的背景颜色,关于颜色的一些提醒，请注意在.SCC文件中（也就是此软件的配置文件）颜色可以用16进制来表示（如 #FFF，#FFFFFF）或者用一些已命名的颜色（白色，蓝色，品 红，粉红，灰色），请注意特殊的颜色“透明”代表“没有颜色”）grid_h_origin = 100 //水平方向和竖直方向都有一条原始的轴线，一般和普通的格点线（每条曲线都是由一个个像素组成 的，所以叫格点线）颜色不同这两个参数确定了轴线在图表中距离顶点、左侧边界的位移，单位为 像素grid_h_step = 20 //确定了每次画线的长度grid_h_color = lime //普通格点线的颜色grid_h_origin_color = lime //原始轴线的颜色grid_v_origin = 0 //水平方向原始的轴线grid_v_step = 5 /确定了每次画线的长度grid_v_color = lime //普通格点线的颜色grid_v_origin_color = lime //竖轴颜色设置[_default_]min=0 //数据最小值max=100 //数据最大值[Field1]color=red //数据区1的曲线颜色定义，下同，你有多少组数据，也就是要画多少条曲线，就要定义多少个field</code></pre><h2 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a>六、参考资料</h2><p><a href="https://blog.csdn.net/HengZo/article/details/66584868?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522158797835519724811862384%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.57653%2522%257D&request_id=158797835519724811862384&biz_id=0&utm_source=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-4">Serial Chart软件使用说明</a></p><p><a href="https://blog.csdn.net/a1174792073/article/details/82928634?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522158797835519724811862405%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=158797835519724811862405&biz_id=0&utm_source=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-2">Serial Chart软件使用经验</a></p>]]></content>
    
    
    <categories>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Serial Chart软件使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于STM32Cube HaL库串口中断函数回显字符串的使用</title>
    <link href="/2020/04/20/STM32UartEcho/"/>
    <url>/2020/04/20/STM32UartEcho/</url>
    
    <content type="html"><![CDATA[<h2 id="一、问题提出"><a href="#一、问题提出" class="headerlink" title="一、问题提出"></a>一、问题提出</h2><p>我们如何才能与单片机取得通信？</p><h2 id="二、实验现象"><a href="#二、实验现象" class="headerlink" title="二、实验现象"></a>二、实验现象</h2><p>单片机通过USB转串口，电脑端通过使用串口助手下发一个数据，单片机接收到数据后就会转发给电脑端，串口助手接收数据区就可以看到刚才下发的数据。</p><p><img src="https://s1.ax1x.com/2020/04/20/JlNgIO.gif"></p><h2 id="三、实验准备"><a href="#三、实验准备" class="headerlink" title="三、实验准备"></a>三、实验准备</h2><p>1.<a href="https://www.st.com/">STM32CubeMX 5.2.1</a></p><p>2.<a href="https://www.st.com/">IAR 8.30.1</a></p><p>3.开发板主控芯片使用的是STM32F401RET6</p><p>4.一个USB转串口工具、一个STlink或Jlink</p><h2 id="三、实验步骤"><a href="#三、实验步骤" class="headerlink" title="三、实验步骤"></a>三、实验步骤</h2><p>1、将单片机与USB转串口工具引脚连接好</p><p>2、编写实验程序</p><p>3、观看实验现象</p><h2 id="四、USART基础了解"><a href="#四、USART基础了解" class="headerlink" title="四、USART基础了解"></a>四、USART基础了解</h2><h3 id="1、USART简介"><a href="#1、USART简介" class="headerlink" title="1、USART简介"></a>1、USART简介</h3><p>   USART数据寄存器(USART_DR)由两个寄存器组成，一个只用于发送数据的可写寄存器TDR，一个只用于接受数据的可读寄存器RDR。当进行发送操作时，写入USART_DR的数据会自动存储到TDR中；当进行读取操作时，USART_DR 会自动获取RDR中的数据。</p><h3 id="2、USART发送数据的几个比较重要的标志位"><a href="#2、USART发送数据的几个比较重要的标志位" class="headerlink" title="2、USART发送数据的几个比较重要的标志位"></a>2、USART发送数据的几个比较重要的标志位</h3><table><thead><tr><th align="left"><img width=60/>名称 <img width=60/></th><th align="center"><img width=255/>描述 <img width=255/></th></tr></thead><tbody><tr><td align="left"><img width=60/>TE <img width=60/></td><td align="center">发送使能</td></tr><tr><td align="left"><img width=60/>TXE<img width=60/></td><td align="center">发送寄存器为空，发送单字节的时候使用</td></tr><tr><td align="left"><img width=60/>TC <img width=60/></td><td align="center">发送完成，发送多个字节数据的时候使用</td></tr><tr><td align="left"><img width=60/>TXIE <img width=60/></td><td align="center"><img width=210/>发送完成中断使能<img width=210/></td></tr></tbody></table><h3 id="3、USART接收数据的几个比较重要的标志位"><a href="#3、USART接收数据的几个比较重要的标志位" class="headerlink" title="3、USART接收数据的几个比较重要的标志位"></a>3、USART接收数据的几个比较重要的标志位</h3><table><thead><tr><th align="left"><img width=60/>名称 <img width=60/></th><th align="center"><img width=255/>描述 <img width=230/></th></tr></thead><tbody><tr><td align="left"><img width=60/>RE <img width=60/></td><td align="center">接收使能</td></tr><tr><td align="left"><img width=60/>RXNE<img width=60/></td><td align="center">读数据寄存器非空</td></tr><tr><td align="left"><img width=60/>RXNEIE <img width=60/></td><td align="center"><img width=170/>接收完成中断使能<img width=165/></td></tr></tbody></table><h2 id="五、程序思路"><a href="#五、程序思路" class="headerlink" title="五、程序思路"></a>五、程序思路</h2><p>   在学习C语言中通常会用到”\n”是回车换行、”\r”回车，这两个转义字符，那么在编程串口回显函数时就可以利用这个转义字符进行区分一串字符是否接收完成（通过查阅资料发现串口软件点击发送按钮时字符串末尾会自动添加一个”\n”这个转义字符）。然后再判断一串字符是否接收完成之前就可以将字符一个接一个的放入数组中，然后利用发送函数将这串字符原路返回，这样就可以实现一个串口的回显功能。</p><h2 id="五、动手实验"><a href="#五、动手实验" class="headerlink" title="五、动手实验"></a>五、动手实验</h2><h3 id="1、使用STM32cubeMX-生成F4串口初始化函数"><a href="#1、使用STM32cubeMX-生成F4串口初始化函数" class="headerlink" title="1、使用STM32cubeMX 生成F4串口初始化函数"></a>1、使用STM32cubeMX 生成F4串口初始化函数</h3><p><img src="https://s1.ax1x.com/2020/04/22/JUSZy4.gif"></p><p>注释：UART选择Asynchronous全双工模式，LED设置为输出模式。特别注意要启动串口中断。在Parameter选项卡中设置波特率(Baud Rate)为115200 Bits/s，字长（Word Length）为 8bits，无奇偶检验（Parity），停止位（Stop Bits）为1，其他选项保持默认。设置TIM1时钟，效果是1s进入一次中断</p><h3 id="2、修改F4串口相关函数"><a href="#2、修改F4串口相关函数" class="headerlink" title="2、修改F4串口相关函数"></a>2、修改F4串口相关函数</h3><h4 id="查看和发送相关的三个函数"><a href="#查看和发送相关的三个函数" class="headerlink" title="查看和发送相关的三个函数"></a>查看和发送相关的三个函数</h4><p>1、阻塞式发送函数(阻塞式发送函数(的意思是这个函数需要等待数据发送完成了这个单片机才能够去做其他事情)</p><p>   <code>HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)</code></p><p>这里有2个重要的参数需要了解:</p><ul><li><p>“UART_HandleTypeDef *huart” :这个参数的意思是选择哪一个串口可供选择参数有huart1、huart2、huart3等。</p></li><li><p>“uint8_t *pData” :需要发送的内容在哪里，是一个指针参数（可能是一个字符串，一个字节，一个数组等等）。指向一个数据发送的缓冲区。</p></li><li><p>“uint16_t Size” :以字节的方式规定发送的数据大小</p></li><li><p>“uint32_t Timeout” :超时时间（因为这个函数是阻塞式发送函数，如果这个函数一直没有发送成功的话，这个时间过了的话也会停止发送数据了），保证了其他程序的正常运行。</p></li></ul><p>2、非阻塞式发送函数(和中断有关，调用这个发送函数就会使能发送中断)</p><p>   <code>HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)</code></p><p>这里有3个重要的参数需要了解:</p><ul><li><p>“UART_HandleTypeDef *huart” :这个参数的意思是选择哪一个串口可供选择参数有huart1、huart2、huart3等。</p></li><li><p>“uint8_t *pData” :需要发送的内容在哪里，是一个指针参数（可能是一个字符串，一个字节，一个数组等等）。指向一个数据发送的缓冲区。</p></li><li><p>“uint16_t Size” :以字节的方式规定发送的数据大小</p></li></ul><p>3、发送完毕中断回调函数（当发送完成后就会进入这个回调函数做接收完数据之后做的事情）</p><p>  <code>void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart);</code></p><p>这里有1个重要的参数需要了解:</p><ul><li>“UART_HandleTypeDef *huart” :这个参数的意思是选择哪一个串口可供选择参数有huart1、huart2、huart3等。</li></ul><h4 id="查看和接收相关的三个函数"><a href="#查看和接收相关的三个函数" class="headerlink" title="查看和接收相关的三个函数"></a>查看和接收相关的三个函数</h4><p>1、阻塞式接收函数(阻塞式接收函数需要等待上位机发送”uint16_t  Size”这么多个字节后才算结束，要不然就是等待”uint32_t Timeout”超时时间过后才能结束这个函数的执行，不灵活)</p><p>   <code>HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)</code></p><p>这里有3个重要的参数需要了解:</p><ul><li>“uint16_t Size” :以字节的方式规定接收的数据大小</li></ul><p>2、非阻塞式接收函数</p><p>   <code>HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)</code></p><p>这里的三个参数同发送的功能基本一样，用”uint16_t Size”规定接收的数据”uint8_t *pData”的大小。</p><p>3、接收完毕中断回调函数（做接收完成规定的数据之后的执行函数）</p><p>   <code>void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)</code></p><p>这里的一个参数同样是指定是哪一个串口。</p><h4 id="添加代码让程序能够得到实验结果"><a href="#添加代码让程序能够得到实验结果" class="headerlink" title="添加代码让程序能够得到实验结果"></a>添加代码让程序能够得到实验结果</h4><p>1、第一步定义三个参数，一个指定一个字符的参数，一个是将接收到的每一个字符都放入数组中的一个数组参数，一个是数组元素个数的参数</p><pre><code> uint8_t RxByte; //接收一个字符 uint8_t RxBuff[256]; //接收一串字符 uint16_t Rx_Count=0; //数组元素计数</code></pre><p>2、第二步添加接收一个字符的的函数</p><pre><code>HAL_UART_Receive_IT(&amp;huart1,&amp;RxByte,1);//接收一个字符</code></pre><p>3、第三步编写接收中断回调函数，首先在这个中断回调函数里面做接收完一个字符放入数组中的工作，然后做是否接收完上位机发送过来的一串字符的判断工作，判断完毕后，紧接着还需将接收完毕之后的字符串发回给上位机。</p><pre><code> void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) &#123;  /* Prevent unused argument(s) compilation warning */   UNUSED(huart);   RxBuff[Rx_Count++]=RxByte;//将每接收到的一个字符放入数组中   if(RxByte==0x0A)//是我们点击发送按键时的ASCII码利用这个结束标志就可以判断一次总的字符是否接收完成   &#123;     while(HAL_UART_Transmit_IT(&amp;huart1,RxBuff,Rx_Count)==HAL_OK); //将接收到的数组里面的字符发送出去     Rx_Count=0;   &#125;   if(Rx_Count&gt;=256)   &#123;     Rx_Count=0;   &#125;    while(HAL_UART_Receive_IT(&amp;huart1,&amp;RxByte,1)==HAL_OK);//重新使能接收一个字节的函数&#125;</code></pre><p>4、测试代码是否编译通过，和得到我上面所写的相应实验现象。</p><h4 id="代码在文件中的具体位置"><a href="#代码在文件中的具体位置" class="headerlink" title="代码在文件中的具体位置"></a>代码在文件中的具体位置</h4><p><img src="https://s1.ax1x.com/2020/04/23/Jad9eK.png"></p><p><img src="https://s1.ax1x.com/2020/04/23/Jadeyt.png"></p><p><img src="https://s1.ax1x.com/2020/04/23/Jaduef.png"></p><h2 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a>六、参考资料</h2><p><a href="https://blog.csdn.net/qq_42041980/article/details/92718642">STM32Cube中断形式串口使用</a></p><p><a href="https://www.cnblogs.com/liufang/p/3990206.html">STM32Cube中断函数学习</a></p><h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p>1、我们再测试我们所写的工程时，需特别注意检查UART转HTT线连接是否正确，串口是否选择正确。<br>2、函数是否选择的是你自己定义的那个串口。</p>]]></content>
    
    
    <categories>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hal库串口中断服务函数的使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于STM32Cube HaL库的串口发送单个字符</title>
    <link href="/2020/04/12/STM32UARTsendone/"/>
    <url>/2020/04/12/STM32UARTsendone/</url>
    
    <content type="html"><![CDATA[<h2 id="博文中所使用到的工具"><a href="#博文中所使用到的工具" class="headerlink" title="博文中所使用到的工具"></a>博文中所使用到的工具</h2><p>1.STM32CubeMX 5.2.1，软件下载地址：<a href="https://www.st.com/content/st_com/en/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-configurators-and-code-generators/stm32cubemx.html">https://www.st.com/content/st_com/en/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-configurators-and-code-generators/stm32cubemx.html</a></p><p>2.IAR软件用于生成后的代码使用,软件下载地址：<a href="https://www.iar.com/">https://www.iar.com/</a></p><p>3.开发板使用的是STM32F401RET6，PS:你也可以选择其他开发板</p><p>4.使用的STlink或者是Jlink</p><h2 id="串口概述"><a href="#串口概述" class="headerlink" title="串口概述"></a>串口概述</h2><p>串口配置好即配置好GPIO和NVIC并初始化相应外设，然后每接受一个data就触发一次中断，转到中断入口处处理，然后清除中断标志位。</p><h2 id="动手实验"><a href="#动手实验" class="headerlink" title="动手实验"></a>动手实验</h2><h3 id="使用STM32cubeMX-生成F4串口初始化函数"><a href="#使用STM32cubeMX-生成F4串口初始化函数" class="headerlink" title="使用STM32cubeMX 生成F4串口初始化函数"></a>使用STM32cubeMX 生成F4串口初始化函数</h3><p><img src="https://s1.ax1x.com/2020/04/20/Jldhz4.gif"></p><p>注释：UART选择Asynchronous全双工模式，LED设置为输出模式。特别注意要启动串口中断。在Parameter选项卡中设置波特率(Baud Rate)为115200 Bits/s，字长（Word Length）为 8bits，无奇偶检验（Parity），停止位（Stop Bits）为1，其他选项保持默认。设置TIM1时钟，效果是1s进入一次中断</p><h3 id="修改F4串口初始化函数"><a href="#修改F4串口初始化函数" class="headerlink" title="修改F4串口初始化函数"></a>修改F4串口初始化函数</h3><p>1、打开之前用STM32cubeMX软件生成的代码，先看main.c文件中的代码部分，我们先定义两个串口发送数据的数组，具体代码如下                 </p><pre><code>uint8_t aTxBuffer[]=&quot;串口发送数据\n&quot;;uint8_t aRxBuffer1[1];        // 用来接收串口1发送的数据，存放字符uint8_t aRxBuffer2[1];        // 用来接收串口2发送的数据，存放字符</code></pre><p><img src="https://s1.ax1x.com/2020/04/12/GOrlAs.png"><br>2、启动接收数据的中断函数，启动发送数据的中断函数，启动定时器函数</p><pre><code>HAL_UART_Receive_IT(&amp;huart1,aRxBuffer1,1);            // 启用 USART1 中断HAL_UART_Receive_IT(&amp;huart2,aRxBuffer2,1);            // 启用 USART2 中断HAL_UART_Transmit(&amp;huart1,aTxBuffer,sizeof(aTxBuffer),100);HAL_UART_Transmit(&amp;huart2,aTxBuffer,sizeof(aTxBuffer),100);HAL_TIM_Base_Start_IT(&amp;htim1);                        // 启动定时器1</code></pre><p><img src="https://s1.ax1x.com/2020/04/12/GORuRA.png"><br>3、查看我们具体的发送和接受数据的函数这个两个函数在”stm32f4xx_hal_uart.c”这个文件中，并且熟悉这两个接收和发送数据的函数，因后面我们还需要调用发送具体的数据。</p><pre><code>HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)&#123;    if(huart-&gt;RxState == HAL_UART_STATE_READY)       &#123;        if((pData == NULL) || (Size == 0U))          &#123;            return HAL_ERROR;          &#125;            /* Process Locked */            __HAL_LOCK(huart);                    huart-&gt;pRxBuffPtr = pData;            huart-&gt;RxXferSize = Size;            huart-&gt;RxXferCount = Size;                    huart-&gt;ErrorCode = HAL_UART_ERROR_NONE;            huart-&gt;RxState = HAL_UART_STATE_BUSY_RX;                    /* Process Unlocked */            __HAL_UNLOCK(huart);                    /* Enable the UART Parity Error Interrupt */            __HAL_UART_ENABLE_IT(huart, UART_IT_PE);                    /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */            __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);                    /* Enable the UART Data Register not empty Interrupt */            __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);          return HAL_OK;        &#125;        else        &#123;          return HAL_BUSY;        &#125; &#125;</code></pre><p><img src="https://s1.ax1x.com/2020/04/12/GOR0s0.png"><br>4、重写HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) 这个弱函数，这里我们先判断用于选择用哪个串口，然后再用接收到的数据发送到串口软件!（这里我解释一下弱函数的意思：弱函数指的是HAL库中带有_weak前缀的函数，我们称之为弱函数。_weak顾名思义是“弱”的意思，所以如果函数名称前面加上_weak修饰符，我们一般称这个函数为”弱函数”。加上了__weak修饰符的函数，用户可以在用户文件中重新定义一个同名函数，最终编译器编译的时候，会选择用户定义的函数，如果用户没有重新定义这个函数，那么编译器就会执行_weak 声明的函数，并且编译器不会报错。）</p><pre><code> void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) &#123;  if(huart-&gt;Instance == USART1)    // 判断是由哪个串   口触发的中断 &#123; HAL_UART_Transmit(&amp;huart1,aRxBuffer1,1,100);    // 接收到数据马上使用串口1发送出去 HAL_UART_Receive_IT(&amp;huart1,aRxBuffer1,1);        // 重新使能串口1接收中断  &#125;  if(huart-&gt;Instance == USART2)   &#123;  HAL_UART_Transmit(&amp;huart2,aRxBuffer2,1,100);    // 接收到数据马上使用串口1发送出去  HAL_UART_Receive_IT(&amp;huart2,aRxBuffer2,1);        // 重新使能串口2接收中断  &#125;&#125;</code></pre><p><img src="http://https//s1.ax1x.com/2020/04/12/GORci4.png"></p><p>5、重写HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) 弱函数用于判断是由哪个定时器触发的中断。这里我用了PB3引脚连接LED灯作为指示灯</p><pre><code>  void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) &#123;    if(htim-&gt;Instance == TIM1)        // 判断是由哪个定时器触发的中断    &#123;        HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_3);    &#125; &#125;</code></pre><p><img src="https://s1.ax1x.com/2020/04/12/GOWr6I.png"></p><p>##观看实验现象 ##</p><p><img src="https://s1.ax1x.com/2020/04/12/GOT1U0.png"></p><p><img src="https://s1.ax1x.com/2020/04/12/GOTFEt.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qq_42041980/article/details/92718642">STM32Cube中断形式串口使用</a></p><p><a href="https://www.cnblogs.com/liufang/p/3990206.html">STM32Cube中断函数学习</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、我们再测试我们所写的工程时，需特别注意检查UART转HTT线连接是否正确，串口是否选择正确。<br>2、函数是否选择的是你自己定义的那个串口。</p>]]></content>
    
    
    <categories>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hal库串口中断服务函数的使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十一届蓝桥杯物联网程序题</title>
    <link href="/2020/04/11/lqbIOT/"/>
    <url>/2020/04/11/lqbIOT/</url>
    
    <content type="html"><![CDATA[<h2 id="蓝桥杯试题解读"><a href="#蓝桥杯试题解读" class="headerlink" title="蓝桥杯试题解读"></a>蓝桥杯试题解读</h2><p>​        本届蓝桥杯试题还是采用上机考试，赛点为我们提供两块网基于STM32L071KBU微控制器和LoRa接收发器。通过赛点提供的资源包以及板子对试题进行编写一个中型项目。本界试题的难度在于对整体如何把握状态机的行为和状态，只要读懂题目并且进行一个整体状态机行为和状态的分化，最后根据流程图编写状态机，再调整细微之处，就是一个完美的中性项目程序了。</p><h2 id="流程图与编程要求讲解"><a href="#流程图与编程要求讲解" class="headerlink" title="流程图与编程要求讲解"></a>流程图与编程要求讲解</h2><p>​        本届试题的流程图如何所示。<br>​        对于终端A，我们需要做的工作是 1）采集温度传感器上的温度值，并将温度值显示在 OLED 上，温度数据保留小数点后 1 位有效数字，单位为摄氏度通过。2） User 按键，切换选择温度显示界面或参数显示界面，参数显示界面包括温度上限和温度下限参数。3）完成命令的通信格式。4）根据当前温度与温度上限、下限参数的关系，控制继电器工作状态。<br>​        对于终端B，1）按下矩阵键盘上的 B1 按键，终端 B 通过通信模块向终端 A 发出查询温度指<br>令，查询一次当前终端 A 采集到的温度数据，并将查询到的结果显示在 OLED上。2）按下矩阵键盘上的 B2 按键，终端 B 通过通信模块向终端 A 发出查询温度参数指令，查询一次当前终端 A 设置的温度参数，并将查询到的结果显示在OLED 上。3）按下矩阵键盘上的 B4 按键，终端 B 通过通信模块向终端 A 发出查询 K1 状态指令,1表示当前终端 A继电器 K1吸合,0表示当前终端 A继电器 K1断开。4）按下矩阵键盘上的 B5 按键，终端 B 通过通信模块向终端 A 发出查询 K2 状态指令,1 表示当前终端 A 继电器 K2 吸合,0 表示当前终端 A 继电器 K2 断开。虽然工作量看起来很大，我们就需要逐个击破分析。<br><img src="https://liloong.gitee.io/my_image/img/27.png"></p><h2 id="连接硬件"><a href="#连接硬件" class="headerlink" title="连接硬件"></a>连接硬件</h2><p>本次比赛硬件需要将主控模块与连接OLED连接、与继电器连接、与LoRa连接。<br>1）将OLED引脚与主控芯片引脚一一对应连接<br>  <img src="https://liloong.gitee.io/my_image/img/29.png"><br>2）将主控芯片引脚与LoRa模块引脚一一对应连接<br>  <img src="https://liloong.gitee.io/my_image/img/28.png"><br>3）将主控芯片引脚与继电器模块引脚一一对应连接<br>  <img src="https://liloong.gitee.io/my_image/img/30.png"><br>4）通用接口 ：矩阵键盘，模拟电压输出模块，温度传感器模块<br>  <img src="https://liloong.gitee.io/my_image/img/31.png"></p><h2 id="具体动手实现程序"><a href="#具体动手实现程序" class="headerlink" title="具体动手实现程序"></a>具体动手实现程序</h2><h3 id="对于终端A-（LoRa）"><a href="#对于终端A-（LoRa）" class="headerlink" title="对于终端A （LoRa）"></a>对于终端A （LoRa）</h3><p>   对于终端A模块，此模块主要负责数据的发送任务</p><h4 id="通过STM32CudeMx初始化STM32L071KBU"><a href="#通过STM32CudeMx初始化STM32L071KBU" class="headerlink" title="通过STM32CudeMx初始化STM32L071KBU"></a>通过STM32CudeMx初始化STM32L071KBU</h4><p>  1）新建工程选择STM32L071KBU芯片设置时钟24MHz；<br>  2）Connectivity配置I2C1，I2C3，SPI1,USART2，引脚配置如上硬件分析；<br>  3）通过上表选择对应设置引脚<br>  4）配置SPI的片选信号PA4为GPIO_Output,OLED电源控制引脚PB5配置为GPIO_Output；<br>  5）生成初始化程序，打开工程文件</p><h4 id="主函数功能实现"><a href="#主函数功能实现" class="headerlink" title="主函数功能实现"></a>主函数功能实现</h4><p>   while(1)循环之前的程序主要是对硬件的各个功能模块的初始化，循环之后的程序主要是整个功能模块的实现逻辑。首先通过20ms检测一次获取到按键键值，并且判断是哪个键按下了，显示相应的功能Task_Recv(handle)函数是可以对终端B接收的数据并执行相关的数据发送。</p><p>`int main(void)<br>{<br>  /* USER CODE BEGIN 1 */</p><p>  /* USER CODE END 1 */</p><p>  /* MCU Configuration——————————————————–*/</p><p>  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */<br>  HAL_Init();</p><p>  /* USER CODE BEGIN Init */</p><p>  /* USER CODE END Init */</p><p>  /* Configure the system clock */<br>  SystemClock_Config();</p><p>  /* USER CODE BEGIN SysInit */</p><p>  /* USER CODE END SysInit */</p><p>  /* Initialize all configured peripherals <em>/<br>  MX_GPIO_Init();<br>  MX_I2C3_Init();<br>  MX_SPI1_Init();<br>  /</em> USER CODE BEGIN 2 */<br>  OLED_PowerControl(ENABLE);</p><p>  HAL_Delay(200);<br>  OLED_Init();<br>  OLED_Clear();</p><p>  handle = radio_zm4xx_inst_init();<br>  if (handle != NULL)<br>    {<br>       radio_mode_set(handle, RX_MODE);//½øÈë½ÓÊÕÄ£Ê½<br>    }//lora³õÊ¼»¯Íê³É<br>  /* USER CODE END 2 */</p><p>  /* Infinite loop <em>/<br>  /</em> USER CODE BEGIN WHILE <em>/<br>  while (1)<br>  {<br>    /</em> USER CODE END WHILE */</p><pre><code>/* USER CODE BEGIN 3 */if(x&amp;0x000f)&#123;    GetStatc(&amp;key);   x = 0;  Task_Send(handle);&#125;if(g_OLED_Flag)&#123;   switch(key)   &#123;      case B1:       OLED_ShowString(0, 0, (unsigned char *)&quot;Temperature&quot;, 16);      OLED_ShowString(0, 2, (uint8_t *)g_lcdLine_1st_line, 16);     break;     case B2:      OLED_ShowString(0, 2, (uint8_t *)g_lcdLine_2st_line, 16);      OLED_ShowString(0, 2, (uint8_t *)g_lcdLine_3st_line, 16);     break;     case B4:      OLED_ShowString(0, 0, (unsigned char *)&quot;K1:Status    &quot;, 16);      OLED_ShowString(0, 2, (uint8_t *)g_lcdLine_4st_line, 16);     break;     case B5:      OLED_ShowString(0, 0, (unsigned char *)&quot;K2:Status    &quot;, 16);      OLED_ShowString(0, 2, (uint8_t *)g_lcdLine_5st_line, 16);     break;   &#125;   g_OLED_Flag = 0;&#125;if(g_Radio_Recv_Flag)&#123;   g_Radio_Recv_Flag = 1;   Task_Recv(handle);&#125;</code></pre><p>  }<br>  /* USER CODE END 3 */<br>}`</p><h4 id="获取按键键值函数实现"><a href="#获取按键键值函数实现" class="headerlink" title="获取按键键值函数实现"></a>获取按键键值函数实现</h4><p><code>void Readkey(void) &#123;    static uint8_t key_o = 0x00, key_n = 0x00;//前次和本次的按键状态    for(uint16_t i = 0;i &lt; KEY_COL; i++)    &#123;       HAL_GPIO_WritePin(GPIOB,key_column[i], GPIO_PIN_SET);       HAL_GPIO_WritePin(GPIOB,key_column[KEY_COL-i-1], GPIO_PIN_RESET);       for(uint16_t i = 0; i &lt; KEY_R; i++)       &#123;         //读取将按键状态依次移入key_n变量中         key_n &lt;&lt;= 1;         if(HAL_GPIO_ReadPin(GPIOB, key_row[i]) == KEY_DNS)         key_n |= 0x01;       &#125;    &#125;    x = (((key_n ^ key_o) &amp; key_o) &lt;&lt; 8) | ((key_n ^ key_o) &amp; key_n);       key_o = key_n;//将本次的按键状态，作为下次检测的比较 &#125;</code></p><h4 id="通过串口发送数据函数实现"><a href="#通过串口发送数据函数实现" class="headerlink" title="通过串口发送数据函数实现"></a>通过串口发送数据函数实现</h4><p><code>void Task_Send(radio_handle_t Radio_handle) &#123;     radio_buf_send(Radio_handle, Cmd_A1, 7);     radio_mode_set(Radio_handle, RX_MODE);//½øÈë½ÓÊÕÄ£Ê½ &#125;</code></p><h3 id="对于终端B-（LoRa）"><a href="#对于终端B-（LoRa）" class="headerlink" title="对于终端B （LoRa）"></a>对于终端B （LoRa）</h3><p>对于终端B模块主要负责接收数据</p><h4 id="串口接收数据函数实现"><a href="#串口接收数据函数实现" class="headerlink" title="串口接收数据函数实现"></a>串口接收数据函数实现</h4><p>`void Task_Recv(radio_handle_t Radio_handle)<br>{<br>    uint8_t index = 0;<br>    if ( radio_buf_recv(Radio_handle, Radio_Rxbuff, &amp;Radio_RxLength) == RADIO_RET_OK)<br>    {<br>        for ( ; index &lt; Radio_RxLength; index++)<br>        {<br>            Cmd_Buff[index] = Radio_Rxbuff[index];<br>        }</p><pre><code>   Compare_Cmd(Cmd_Buff, Radio_RxLength);&#125;</code></pre><p>}`</p><h4 id="按键状态切换函数实现"><a href="#按键状态切换函数实现" class="headerlink" title="按键状态切换函数实现"></a>按键状态切换函数实现</h4><p>`void Task_Send(radio_handle_t Radio_handle)<br>{<br>    switch (key)//根据ADC大小发送相应的指令<br>        {<br>        case B1:<br>            radio_buf_send(Radio_handle, Cmd_B1, 7);<br>            radio_mode_set(Radio_handle, RX_MODE);//进入接收模式<br>            break;<br>        case B2:<br>            radio_buf_send(Radio_handle, Cmd_B2, 7);<br>            radio_mode_set(Radio_handle, RX_MODE);//进入接收模式<br>            break;<br>        case B4:<br>            radio_buf_send(Radio_handle, Cmd_B3, 7);<br>            radio_mode_set(Radio_handle, RX_MODE);//进入接收模式<br>            break;<br>        case B5:<br>            radio_buf_send(Radio_handle, Cmd_B4, 7);<br>            radio_mode_set(Radio_handle, RX_MODE);//进入接收模式<br>            break;</p><pre><code>    default :        ;        break;    &#125;</code></pre><p>}`</p>]]></content>
    
    
    <categories>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hal库应用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS属性内容知识点总结</title>
    <link href="/2020/03/29/Web/cssAttribute/"/>
    <url>/2020/03/29/Web/cssAttribute/</url>
    
    <content type="html"><![CDATA[<h1 id="设置字体"><a href="#设置字体" class="headerlink" title="设置字体"></a>设置字体</h1><p>浏览器默认的字体大小是16px，我们一般使用的字体大小是12px和14px，一般很少使用16px</p><p>设置字体的大小，其实是设置的字体的高</p><p>常用字体是arial</p><p>对于中文字体，cursive 这个字体还是比较好看的</p><p>   <strong>字体代码如下</strong></p><pre><code>font-size: 81px;font-weight: 600;font-style: normal;font-family: arial;color: #fff000;border: 1px solid black /*复合属性 */</code></pre><p>border是给div加上外边框的，叫做盒子，第一个值是定义元素边框厚度，第二个值是定义元素边框样式，第三个值是颜色</p><h2 id="三种设置字体颜色方法"><a href="#三种设置字体颜色方法" class="headerlink" title="三种设置字体颜色方法"></a>三种设置字体颜色方法</h2><p>1、土鳖式 （纯英文单词）color:green; (一般很少使用这种方法)</p><p>2、颜色代码  color ：#ff5500 (一般使用这种方法，用的比较多)</p><p>3、颜色函数  color :rgb(255,255,255)</p><p>透明色 ：transparent</p><h2 id="设置三角形代码"><a href="#设置三角形代码" class="headerlink" title="设置三角形代码"></a>设置三角形代码</h2><pre><code>font-size: 0px;font-weight: 10;font-style: normal;font-family: cursive;color: #030;width: 0px;height: 0px;border: 100px solid red; border-left-color:#029; border-top-color: transparent; border-bottom-color: transparent; border-right-color: transparent;</code></pre><h1 id="文本垂直和水平居中方式"><a href="#文本垂直和水平居中方式" class="headerlink" title="文本垂直和水平居中方式"></a>文本垂直和水平居中方式</h1><p>   代码格式</p><pre><code>   text-align: center; //水平居中   line-height: initial; //垂直居中</code></pre><h2 id="文字在盒子里如何垂直居中"><a href="#文字在盒子里如何垂直居中" class="headerlink" title="文字在盒子里如何垂直居中"></a>文字在盒子里如何垂直居中</h2><p>  文本高度j等于<strong>line-height</strong></p><pre><code>border: 10px solid #069;text-align: center; /*对齐方式*/height: 20px;line-height: 20px;text-indent: 2em /*文本缩进*/text-decoration: underline;  /*文本装饰标识符、设置下划线*/</code></pre><p>em 和px都是相对单位 em相对于总的文本缩进的字符数</p><p>1em = 1 font-size; = 16px</p><p>1em = 16px;</p><h1 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h1><p><strong>鼠标放上去之后能够显示的效果，然后但鼠标移除时恢复原来的状态，就是伪类选择器</strong></p><pre><code>   a:hover&#123;           background-color: turquoise;        &#125;</code></pre><p>在标签选择器后面添加”:hover”，就可以变成伪类选择器</p><h1 id="CSS三大模型-：层模型、盒模型、浮动模型"><a href="#CSS三大模型-：层模型、盒模型、浮动模型" class="headerlink" title="CSS三大模型 ：层模型、盒模型、浮动模型"></a>CSS三大模型 ：层模型、盒模型、浮动模型</h1><h1 id="盒模型分两种（计算方式的不同）"><a href="#盒模型分两种（计算方式的不同）" class="headerlink" title="盒模型分两种（计算方式的不同）"></a>盒模型分两种（计算方式的不同）</h1><p>  1、标准盒模型</p><p>   总宽度 = border(左右) + width + padding(左右)<br>   总高度 = border(上下) + height + padding(上下)</p><p> 2、IE盒模型（怪异合模型）触发方式 ：box-sizing:border-box;</p><p>   总宽度 = width;<br>   总高度 = height;</p><h2 id="层模型"><a href="#层模型" class="headerlink" title="层模型"></a>层模型</h2><p>  层模型就相当于PS中的图片的每一层，可以对每个图层进行精确定位</p><p>  层模型有三种形式：<br>     1、绝对定位（position:absolute）</p><pre><code> 2、相对定位 (position:relative) 3、固定定位 (position:fixed)</code></pre><h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>  需要设置<strong>position:absolute</strong>(表示绝对定位)，这条语句的作用是将元素从文档流中拖出来，然后使用left/right、top/botton属性相对于其<strong>其最接近的一个具有定位属性的父级包含快（组合使用）</strong>进行绝对定位。如果不存在这样的包含快，则相对于body元素，即相对于<strong>浏览器窗口对齐</strong></p><h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><p>  需要设置position:relative(表示相对定位)，它通过left/right、top/botton属性确定<strong>元素在正常文档流</strong>中的偏移位置。相对定位完成的过程时首先按static(float)方式生成一个元素（并且元素像层一样浮动起来），然后相对于<strong>以前的位置移动</strong>，移动的方向和幅度有left/right、top/botton属性确定，<strong>偏移前的位置保留不动。</strong></p><h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><p>  fixed:表示固定定位，与absolute定位类型类似，但他的相对移动的坐标是试图（<strong>屏幕内的网页窗口</strong>）本身。由于视图本身是固定的，他不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，影刺规定定位的元素会始终位于浏览器窗口内视图的么个位置，不会受文档流动影响，这与background-attachment:fixed;属性相同。</p><h3 id="relative与absolute组合使用"><a href="#relative与absolute组合使用" class="headerlink" title="relative与absolute组合使用"></a>relative与absolute组合使用</h3><p>  使用position:absolute可以实现被设置元素相对于浏览器（body）设置定位以后，如何设置相对于其他元素进行定位？这就需要使用positive:relative来帮忙，但必须遵守下面规范：</p><p>  <strong>1、参照定位的元素必须是相对定位元素的前辈元素：</strong></p><pre><code>    &lt;div class=&quot;box1&quot;&gt; &lt;!-- 参照定位的元素 --&gt;        &lt;div class=&quot;box2&quot;&gt;相对参照元素进行定位&lt;/div&gt;&lt;!-- 相对定位元素 --&gt;        &lt;/div&gt;</code></pre><p>   从上面代码可以看出box1是box2的父元素（父元素当然也是前辈元素）</p><p>   <strong>2、参照定位的元素必须加入position:relative;</strong></p><pre><code>   .box1&#123;        position: relative;          width: 100px;        height: 100px;        background-color: antiquewhite;    &#125;</code></pre><p>   <strong>3、定位元素加入position:absolute,便可以使用top、botton、left、right来进行偏移定位了。</strong></p><pre><code>   .box2&#123;        position: absolute;        width: 50px;        height: 50px;        background-color: red;    &#125;</code></pre><p>   这样box2就可以相对于父元素box1定位了（这个注意参照物就可以不是浏览器了，而可以自由设置了）。</p><h2 id="图层定位技术"><a href="#图层定位技术" class="headerlink" title="图层定位技术"></a>图层定位技术</h2><p>  定位： position</p><p>  绝对定位: absolute</p><p>  <strong>在第几层用 z-index: 1;属性进行设置，1就是第一层</strong></p><p>  需要给定位距离距离上边和左边的大小的大小</p><p>  <img src="https://s1.ax1x.com/2020/05/02/JxuemQ.png"></p><p>  <strong>body这个标签有一个最开始外边距为8px，所以一般初始化时会把这个标签的外边距设置为零</strong></p><p>  absolute 绝对定位脱离原来的位置进行定位，每一个都是一个新的层</p><p>  <strong>绝对定位重要解释：相对于最近的有定位的父级进行定位，如果没有，那么相对于文档进行定位</strong></p><p>  relative 保留原来位置进行定位，在原来的基础上进行定位，相对自己原来的位置进行定位</p><p>  <strong>用relative进行参照物，不用relative进行定位，用absolute进行定位</strong></p><p>  <img src="https://s1.ax1x.com/2020/05/02/Jx1Cxx.png"></p><h3 id="固定定位也要配合left、top元素进行使用"><a href="#固定定位也要配合left、top元素进行使用" class="headerlink" title="固定定位也要配合left、top元素进行使用"></a>固定定位也要配合left、top元素进行使用</h3><pre><code> position:fixed; //在网页的一个地方静止不动</code></pre><p>  <img src="https://s1.ax1x.com/2020/05/02/Jx1yo4.png"></p><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>   <strong>是针对html的每一个元素的，每一个元素都可以叫做盒子</strong></p><h3 id="盒子三大部分"><a href="#盒子三大部分" class="headerlink" title="盒子三大部分"></a>盒子三大部分</h3><p>  1、盒子壁 border</p><p>  2、内边距 padding</p><p>  3、盒子内容 width + height</p><p>  <img src="https://s1.ax1x.com/2020/05/02/JxE51e.png"></p><p>  <img src="https://s1.ax1x.com/2020/05/02/JxEx1g.png"></p><p>  四个值的话，分别代表上右下左</p><p>  外边距 margin</p><h3 id="盒子模型应用"><a href="#盒子模型应用" class="headerlink" title="盒子模型应用"></a>盒子模型应用</h3><p>  远视图画法</p><h3 id="一个元素不管网页如何变化都是居中的写法"><a href="#一个元素不管网页如何变化都是居中的写法" class="headerlink" title="一个元素不管网页如何变化都是居中的写法"></a>一个元素不管网页如何变化都是居中的写法</h3><pre><code> position:absolute; left:%50; top:%50; margin-left:-50px; margin-top:-50;</code></pre><p> <img src="https://s1.ax1x.com/2020/05/02/Jx8Sjx.png"></p><h3 id="如何画圆角"><a href="#如何画圆角" class="headerlink" title="如何画圆角"></a>如何画圆角</h3><pre><code> width: 100px; height: 100px; border: 10px solid red; border-radius: 50%;</code></pre><h2 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h2><p>  左一个右一个（让两个块级元素共一行显示）</p><p>  得是真正的两栏布局，而不能是一个块级元素压住另一个块级元素</p><p>  <img src="https://s1.ax1x.com/2020/05/03/YpZ5Ed.png"></p><h2 id="bfc问题"><a href="#bfc问题" class="headerlink" title="bfc问题"></a>bfc问题</h2><p>  问题：父子块级元素，当设置子元素相对于父元素顶部距离不能实现设置</p><p>  <img src="https://s1.ax1x.com/2020/05/03/Ypufzt.png"></p><p>  解决办法（bfc）</p><p>  如何触发一个盒子的BFC</p><p>  触发代码：</p><pre><code>   第一种方法： position:absolute;   第二种方法： display:inline-block;   第三种方法： float: left/right;   第四种方法： overflow: hidden;//溢出盒子的部分要隐藏展示    改变大盒子的渲染规则</code></pre><p>  <img src="https://s1.ax1x.com/2020/05/05/Yka7sx.png"></p><h2 id="浮动模型"><a href="#浮动模型" class="headerlink" title="浮动模型"></a>浮动模型</h2><p>  <strong>浮动元素产生了浮动流对后面的元素的影响不一</strong></p><p>  <strong>所有产生了浮动流的元素，块级元素看不到他们的存在，所以就产生了分层.</strong></p><p>  块级元素看不到浮动元素的测试代码<br>  <img src="https://s1.ax1x.com/2020/05/05/YkdLXq.png"></p><p>  看不到浮动元素的分层效果</p><p>  <img src="https://s1.ax1x.com/2020/05/05/YkwK9H.png"></p><p>  <strong>产生bfc的元素和文本类属性（inline）的元素以及文本都能看到浮动元素。</strong></p><p>  <strong>只有块级才看不到浮动元素</strong></p><p>   父级包含子级浮动流元素解决办法（俗称包裹元素）<br>     clear:both(both将两边的浮动流一块清除，只有一个作用清除浮动流)（加了一个结构，不好用）</p><p>  <img src="https://s1.ax1x.com/2020/05/05/Yk0Wo8.png"></p><p>  <strong>伪元素天生就存在html标签语句上，我们需要用的话就可以通过CSS将其选中伪元素，就可以通过CSS属性将其里面的内容修改</strong></p><p>  <strong>伪元素天生就是行级元素，如果要做块级元素使用，就必须加上语句：（也是行级元素变成块级元素的方法</strong>   </p><pre><code>    display: inline-block;</code></pre><p>  <img src="https://s1.ax1x.com/2020/05/06/YEx3Us.png"></p><p>  <strong>用完浮动流，记得清除，变成原始的行内元素</strong></p><p>  清除浮动流三要素</p><pre><code>   content:&quot;&quot;;   display:block; //行内元素   clear:both;</code></pre><p>  <img src="https://s1.ax1x.com/2020/05/07/YZN9w6.png"></p><h2 id="伪元素用法"><a href="#伪元素用法" class="headerlink" title="伪元素用法"></a>伪元素用法</h2><h3 id="伪元素-before-和-after-这两个伪元素的用法"><a href="#伪元素-before-和-after-这两个伪元素的用法" class="headerlink" title="伪元素 ::before 和 ::after 这两个伪元素的用法"></a>伪元素 ::before 和 ::after 这两个伪元素的用法</h3><p> <strong>为什么叫伪元素：他的元素结构是存在，但是他又没有写在html里面</strong></p><p>  <strong>::before没有html结构,但可以通过CSS来正常操作（可以当元素来正常操作</strong></p><p>  伪元素在最开始设计时就存在，只是我们通过CSS来选中进行了操作</p><p>  content:””;可以修改伪元素里面的内容（只能用在伪元素中）</p><p>  <strong>伪元素就是行级元素，如果要设置宽高之类的就必须改成块级元素或者是行级块元素</strong></p><p>  <img src="https://s1.ax1x.com/2020/05/07/Ymf2hF.png"></p><h3 id="利用伪元素来清除浮动"><a href="#利用伪元素来清除浮动" class="headerlink" title="利用伪元素来清除浮动"></a>利用伪元素来清除浮动</h3><p>   利用伪元素来清除浮动只需修改CSS语句就行</p><p>  <strong>能清除浮动的必须是块级元素，所以得将其设置为块元素，得添加display-block变成块级元素才能清除</strong></p><p>   <img src="https://s1.ax1x.com/2020/05/06/YEzuJ1.png"></p><p>   设置了position:abolute;  float:left/right;</p><p>   这两个属性会打内部把元素转换成inline-black 行级块元素</p><p> <strong>lsit-style:none;控制原点的，可以将自定义序列前面的原点去除</strong></p><h2 id="单行文本溢出打点方法"><a href="#单行文本溢出打点方法" class="headerlink" title="单行文本溢出打点方法"></a>单行文本溢出打点方法</h2><p>  <strong>先让文本失去换行的功能</strong></p><pre><code>   white-space: nowrap;</code></pre><p>  <strong>溢出部分隐藏</strong></p><pre><code>   overflow: hidden;</code></pre><p>  <strong>溢出部分用点点点显示</strong></p><pre><code>   text-overflow:ellipsis;</code></pre><h2 id="特殊点"><a href="#特殊点" class="headerlink" title="特殊点"></a>特殊点</h2><p>   行级元素只能嵌套行级元素<br>   块级元素可以嵌套任何元素</p><pre><code>   例如：div里面可以套任何东西   span里面只能套行级元素</code></pre><p> <strong>特殊 “p”(这是块级元素)标签里面不能套块级元素，套完就会被截断</strong></p><p>  <strong>a标签里面不能套a标签</strong> 写了都不知到跳转哪一个</p><h1 id="内容区不会随着网页缩小而改变办法"><a href="#内容区不会随着网页缩小而改变办法" class="headerlink" title="内容区不会随着网页缩小而改变办法"></a>内容区不会随着网页缩小而改变办法</h1><p>   内容区的外边距自适应就可以解决这个问题了</p><p>   <img src="https://s1.ax1x.com/2020/05/07/YmlPHS.png"></p><h1 id="文字属性的问题"><a href="#文字属性的问题" class="headerlink" title="文字属性的问题"></a>文字属性的问题</h1><p>  行级元素</p><pre><code>   inline block</code></pre><p>  行级块元素</p><pre><code>   inline-block -----文本类元素</code></pre><p>  凡是带有inline属性的元素都有文本类特点</p><p>  img 也是文本类属性，当多个图片在一行是就会有文字分隔符将多个图片中间隔开一定的距离</p><p> <strong>解决办法：将图片之间的空格去了就可以了</strong></p><p>  <img src="https://s1.ax1x.com/2020/05/07/Ym1JIg.png"></p><h1 id="内部原理"><a href="#内部原理" class="headerlink" title="内部原理"></a>内部原理</h1><p>  当我们用行级元素span去写网页时，当设置span的宽高时发现不能设置，但当我们添加上   position: absolute;  float: left/right; 这两条语句的其中一个时惊奇的发现可以设置了。</p><p>  原因讲解：<br>     因为span是行级元素，不能设置宽高。但当设置了position: absolute;  float: left/right;这两条属性的其中一个时，浏览器就会自动将行级元素转换成行级块元素，然后我们就可以设置行级元素的宽高了</p><p> 添加浮动元素时就会将行级元素转换成块级元素</p><p>  <img src="https://s1.ax1x.com/2020/05/07/Ym3wfH.png"></p><h1 id="底对齐问题"><a href="#底对齐问题" class="headerlink" title="底对齐问题"></a>底对齐问题</h1><p>  当一个行级块元素或者是文本类元素，里面添加文字时外面的文字就会和里面的文字底对齐到最上面。</p><p>  <img src="https://s1.ax1x.com/2020/05/07/YmttiT.png"></p><p>  position: absolute;  float: left/right; 这两条元素在浏览器执行时会转变成行级块元素，问题来了同样是行级块元素，但position: absolute;  float: left/right;这两条语句添加上去是就会在第一行显示，但当 display: inline-block;添加上去时就会是和边框底对齐，原因是position: absolute;  float: left/right;这两条语句是浮动元素，浮动元素看不到块级元素，所以就会自然而然的显示在第一行，但display: inline-block;不是浮动元素就会显示底对齐了，所以用display: inline-block;这个属性时，标签里面添加文字，就会一起在第一行对齐了。</p><h1 id="调一行元素的对齐线"><a href="#调一行元素的对齐线" class="headerlink" title="调一行元素的对齐线"></a>调一行元素的对齐线</h1><pre><code>     vertical-align: -20%;</code></pre><p>   <img src="https://s1.ax1x.com/2020/05/07/YmNON6.png"></p><h1 id="两个容器在一个大的容器里面左右浮动"><a href="#两个容器在一个大的容器里面左右浮动" class="headerlink" title="两个容器在一个大的容器里面左右浮动"></a>两个容器在一个大的容器里面左右浮动</h1><pre><code> &lt;div&gt;     &lt;!-- 一个大容器里面包裹两个ul --&gt;    &lt;ul&gt;&lt;/ul&gt;     &lt;!-- 一个左浮动 --&gt;    &lt;ul&gt;&lt;/ul&gt;    &lt;!-- 一个有浮动 --&gt; &lt;/div&gt;</code></pre><h1 id="input是行快元素可以设置宽高"><a href="#input是行快元素可以设置宽高" class="headerlink" title="input是行快元素可以设置宽高"></a>input是行快元素可以设置宽高</h1><h1 id="透明属性"><a href="#透明属性" class="headerlink" title="透明属性"></a>透明属性</h1><p><img src="https://s1.ax1x.com/2020/05/13/YdF2Jx.png"></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS属性内容</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kile软件控制寄存器写LED</title>
    <link href="/2020/03/25/STM32/"/>
    <url>/2020/03/25/STM32/</url>
    
    <content type="html"><![CDATA[<h1 id="GPIO端口应用"><a href="#GPIO端口应用" class="headerlink" title="GPIO端口应用"></a>GPIO端口应用</h1><p>第一步：开启GPIO端口的时钟。</p><p>第二步：控制GPIO的方向（输入和输出方向）</p><p>第三步：控制GPIO的数据输出寄存器</p><p><img src="https://s1.ax1x.com/2020/04/13/GXRRgA.png"></p><p>改进后的代码<br><img src="https://s1.ax1x.com/2020/04/13/GXWUIS.png"></p><p><img src="https://s1.ax1x.com/2020/04/13/GXW4z9.png"></p><h1 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h1><p>  构成：中断、中断源、中断向量、中断优先级、中断服务函数</p><p>  中断向量就是一个入口地址对应的是一个中断源的中断请求，这是一个中断服务函数的指针，在这个指针里面放着一个中断服务函数</p>]]></content>
    
    
    <categories>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hal库应用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟串口软件调试工具</title>
    <link href="/2020/03/25/51/"/>
    <url>/2020/03/25/51/</url>
    
    <content type="html"><![CDATA[<p>###软件仿真所使用到的工具###</p><ol><li>“Configure Virtual Serial Port Driver”建立虚拟串口的软件</li><li>软件下载地址：<a href="https://pan.baidu.com/s/1rftINzFbwjOU3SUz1S2H6w">https://pan.baidu.com/s/1rftINzFbwjOU3SUz1S2H6w</a><br>提取码：vwbh </li></ol>]]></content>
    
    
    <categories>
      
      <category>51单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>串口调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在Quartus II新建工程</title>
    <link href="/2020/03/24/QuartusII/"/>
    <url>/2020/03/24/QuartusII/</url>
    
    <content type="html"><![CDATA[<h3 id="一、Quartus-II新建工程步骤"><a href="#一、Quartus-II新建工程步骤" class="headerlink" title="一、Quartus II新建工程步骤"></a>一、Quartus II新建工程步骤</h3><ol><li>打开安装好的Quartus II软件，点击Fil,在单击New Project Wizard 这个时候我们就进入到新建工程的向导。<img src="https://i.loli.net/2020/03/29/SDQqGf9bBAdJuj6.png"></li><li>直接点击Next<img src="https://i.loli.net/2020/03/29/l16jYSBqyia9LOP.png"></li><li>这一步选择工程放在什么地方，需特别注意工程文件名和顶层文件名可以一致，一个工程中只能有一个顶层文件，路径和工程名不能使用中文。<br><img src="https://i.loli.net/2020/03/29/PYrnzDEB8xUie4a.png"></li><li>填写好工程文件的路径名和顶层文件名的英文名后点击Next。<br><img src="https://i.loli.net/2020/03/29/Y84p7UfKeHuw5BW.png"></li><li>点击Next后进入到加入存在的设计文件这一步（后面有自己之前村在的设计文件的画在这一步是可以添加的），因为我们这里还没有设计文件，所以我们这里直接单击Next就可以了<img src="https://i.loli.net/2020/03/29/h5MHgZyomBzicYa.png"></li><li>这一步选择我们使用的可编程逻辑器件的芯片号，”Device family”这里是选择属于那一个系列的芯片，”Target device”这个是目标设备的选择，”Show in ‘Available devices’list”这一列的选择芯片的封装，引脚数和数度等级，这样我们就能更快的选择出我们需要的芯片。<br><img src="https://i.loli.net/2020/03/29/wuIPTdBib5rZE48.png"></li><li>这一步是EDA工具设置,可直接单击Next<br><img src="https://i.loli.net/2020/03/29/iQ3fOGntsb9RrWu.png"></li><li>这里最后是确认选择的芯片型号的总计,查看是否有错误.<br><img src="https://i.loli.net/2020/03/29/YMIHKa3qJcgwGsW.png"><h3 id="二、工程建立好后如何编写第一个测试工程"><a href="#二、工程建立好后如何编写第一个测试工程" class="headerlink" title="二、工程建立好后如何编写第一个测试工程"></a>二、工程建立好后如何编写第一个测试工程</h3></li><li>点击左上角的File菜单,会弹出选择编程语言和编程方式,这里我们选择Verilog HDL File编程语言编程,后点击OK就可以了.<br><img src="https://i.loli.net/2020/03/29/ulAGHRLnimgK98s.png"></li><li>输入测试程序<br><img src="https://i.loli.net/2020/03/29/FK8cCGYsBnPifyv.png"></li><li>点击File选项进行工程项目保存<br><img src="https://i.loli.net/2020/03/29/ihQ3xdfbcLEOgC6.png"></li><li>点击工具栏上的播放键进行编译,等待编译完成.<br><img src="https://i.loli.net/2020/03/29/6FzVnwgChpUDTvu.png"></li><li>编译直到,最下面一栏没有红色的,和错误就说明编译通过.<br><img src="https://i.loli.net/2020/03/29/a3MkSVwnbtZlx7P.png"><h3 id="三、指定引脚"><a href="#三、指定引脚" class="headerlink" title="三、指定引脚"></a>三、指定引脚</h3></li><li>单击工具栏上面的Assignments下面有一个选项为Pin Planner单击这个选项,后面我们就进入到这个引脚指定模块.<img src="https://i.loli.net/2020/03/29/WNSqMhDKoQXk3xm.png"></li><li>按自己的模块需要用到的哪些引脚进行选择<br><img src="https://i.loli.net/2020/03/29/WNSqMhDKoQXk3xm.png"><br>最后一步,按之前编译程序代码一样在编译一次,通过后就说明用Quartus II第一次建立一个工程完成.</li></ol>]]></content>
    
    
    <categories>
      
      <category>逻辑器件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新建工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
